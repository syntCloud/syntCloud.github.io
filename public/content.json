{"posts":[{"title":"2022强网杯 Crypto","text":"当场做是做不出来的，赛后分析学学吧，不定期更新。 Lattice1234567891011121314151617181920212223242526272829303132from sage.modules.free_module_integer import IntegerLatticefrom Crypto.Cipher import AESfrom base64 import b64encodefrom hashlib import *from secret import flagimport signaln = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] t2 = [ZZ.random_element(N) for _ in range(r*n)] B = matrix(ZZ, n, m, t1) # B为75*150的矩阵 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) # A为10*75的矩阵 C = (A * B) % N # C为10*150的矩阵 return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;signal.alarm(60)token = input(&quot;team token:&quot;).strip().encode()L, C = gen(n, m, r, N)print(C)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()print(ct) 题目生成了一个元素在 $[-2^{15},2^{15}]$ 间的矩阵 $B_{75\\times150}$ ，和 $Z_N$ 上的矩阵 $A_{10\\times75}$ 。然后给了一个两矩阵相乘再模 $N$ 的结果 $C$ ，即 $C=AB(mod\\ N)$ ，需要我们恢复出原来格$B$的最短向量。 比赛时尝试过构造 $\\left[ C \\enspace NI\\right]^T$ ，跑LLL出来的结果很差， BKZ 的话一晚上啥也没出来。。赛后只找到 Nu1L 队的 wp ，but 也只有个 exp ，一句解释都没，像我这样的菜鸡分析起来就十分吃力了，但聊胜于无嘛，其他几个队连个 wp 都不放呜呜呜。 exp中构造了一个 $m+r=150+10=160$ 维的方阵 $A$ 如下：$$A=\\left(\\begin{array}{cccc|cccc}1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 2^{200}\\cdot c_{0,0} &amp; 2^{200}\\cdot c_{1,0} &amp; \\cdots &amp; 2^{200}\\cdot c_{9,0} \\\\0 &amp; 1 &amp; \\cdots &amp; 0 &amp; 2^{200}\\cdot c_{0,1} &amp; 2^{200}\\cdot c_{1,1} &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 2^{200}\\cdot c_{0,149} &amp; 2^{200}\\cdot c_{1,149} &amp; \\cdots &amp; 2^{200}\\cdot c_{9,149} \\\\ \\hline0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 2^{200}\\cdot N &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 2^{200}\\cdot N &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 2^{200}\\cdot N\\end{array}\\right)$$可以看到 $A$ 左上角为一个 $150$ 维的单位阵，左下角为零阵，右上角为 $C$ 的转置数乘 $2^{200}$ ，右下角为一个 $10$ 维的单位阵数乘 $2^{200}\\cdot N$ ，这里乘不乘 $2^{200}$ 得到的结果都是一样的，但神奇的是不乘的话 LLL 耗时会长一些。$A$ 跑一遍 LLL 后，取结果的左上角 $75\\times150$ 矩阵，记为 $B$ ，取 $B$ 的核记为 $D$ ，最后 $D$ 跑一遍 BKZ 后的最短向量即为所求。 这里涉及到矩阵的核的概念，核也叫矩阵的零空间，比如 $M$ 的核是方程 $Mx=0$ 的所有解 $x$ 的集合。 那么就不难看出有 $BD^T=O$ ，即 $B^TD=O$至于 $C$ 为什么左边要拼接一个单位阵，回忆你已经遗忘的线性代数，这种操作是不是似曾相识？没错说的就是矩阵的求逆，求逆矩阵除了伴随矩阵法，还有一种方法就是初等变换法。例如如下一个矩阵求逆$$M=\\begin{pmatrix}1 &amp; -4 &amp; -3 \\\\1 &amp; -5 &amp; -3 \\\\-1 &amp; 6 &amp; 4\\end{pmatrix}$$在右边补上一个单位阵，得到$$A=\\left(\\begin{array}{ccc|ccc}1 &amp; -4 &amp; -3 &amp; 1 &amp; 0 &amp; 0 \\\\1 &amp; -5 &amp; -3 &amp; 0 &amp; 1 &amp; 0 \\\\-1 &amp; 6 &amp; 4 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right)\\stackrel{初等行变换}{\\longrightarrow}\\left(\\begin{array}{ccc|ccc}1 &amp; 0 &amp; 0 &amp; 2 &amp; 2 &amp; 3 \\\\0 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0 \\\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 2 &amp; 1\\end{array}\\right)$$此时右边的矩阵 $M^{-1}$ 即为所求究其原理，在进行初等行变换的时候，右边的矩阵“记录”下了我们的操作，可以表示为$$M^{-1}\\left[ M\\enspace I\\right] =\\left[ I\\enspace M^{-1}\\right]$$回到题目中来，有$$L\\left[ I \\enspace C^T\\right] \\enspace % \\enspace N=\\left[\\begin{matrix} B &amp; O \\\\ R &amp; S\\end{matrix}\\right]$$至于右上角为何是一个 $75\\times10$ 的零阵，我也不知道，但 exp 既然这么断言，姑且就这么认为先，那么我们就推测$$L=\\left[\\begin{matrix} B \\\\ R\\end{matrix}\\right],LC^T=\\left[\\begin{matrix} O \\\\ S\\end{matrix}\\right](mod\\ N)$$即有$$\\left[\\begin{matrix} B \\\\ R\\end{matrix}\\right]C^T=\\left[\\begin{matrix} O \\\\ S\\end{matrix}\\right](mod\\ N)$$得到 $BC^T=O\\ (mod\\ N)$ ，结合上面 $BD^T=O$ ，推测。。。推测不出来了，然后结合队里大手子的分析如下 记题目中给出的两个矩阵为 $\\mathcal{A}$和$\\mathcal{B}$ ，有 $\\mathcal{A}\\mathcal{B} = C\\ (mod\\ N)$若有 $B(\\mathcal{A}\\mathcal{B})^T = BC^T = O\\ (mod\\ N)$ ，则 $B$ 和 $C^T$ 互为左右零空间。因此可以通过构造格 $L$ ，使得对格 $L$ 进行格基规约后可以得到一组基 $B$ 满足 $BC^T = O\\ (mod\\ N)$ ，即 $B$ 的基就是 $C^T$ 在模 $N$ 下的一个左零空间。接下来对 $B$ 求解其零空间 $D^T$ 就得到了 $(\\mathcal{A}\\mathcal{B})^T$ 所在的那个空间上了，这里从有限域化为整数域，即 $D=\\mathcal{A}\\mathcal{B}$ ，然后因为 $\\mathcal{B}$ 中所求的行向量是一个短向量，且矩阵 $D^T$ 的行向量是 $\\mathcal{B}$ 的行向量的线性组合，因此对 $D^T$ 进行格基规约算法就可以把 $\\mathcal{B}$ 的短向量给恢复出来。 至此已经有明悟的感觉，但仍是有少许不解，消化一段时间吧。","link":"/2022/08/08/2022%E5%BC%BA%E7%BD%91%E6%9D%AF%20Crypto/"},{"title":"2022蓝帽杯 - corrupted_key","text":"很有意思的一道题，涉及私钥文件的结构。 题目给了一个priv.pem 123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXgIBAAKBgQDXFSUGqpzsBeUzXWtG9UkUB8MZn9UQkfH2Aw03YrngP0nJ3NwHUFTgzBSLl0tBhUvZO07haiqHbuYgBegO+Aa3qjtksb+bH6dz41PQzbn/l4Pd1fXmdJmtEPNh6TjQC4KmpMQqBTXF52cheY6GtFzUuNA7DX51wr6HZqHoQ73GQQIDAQAByQvOzxy6szWFheigQdGxAkEA4wFss2CcHWQ8FnQ5w7k4uIH0I38khg07HLhaYm1czUcmlk4PgnDWxN+ev+vMU45O5eGntzaO3lHsaukX9461mA==-----END RSA PRIVATE KEY----- 和一个加密的脚本 1234567from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPfrom secret import flagkey = RSA.generate(1024)open(&quot;flag.enc&quot;,'wb').write(PKCS1_OAEP.new(key.publickey()).encrypt(flag))open('priv.pem','wb').write(key.exportKey('PEM')) 然后就是 flag.enc 分析数理部分题目名为 corrupted_key ，意为残损的私钥文件，既然是残损的，那么剩下的部分就是解题的关键了。通过查看 Crypto.PublicKey.RSA 的源码，发现私钥文件的结构是： 123456780 （注意！！！！）nepqd mod (p-1)d mod (q-1)(inverse of q) mod p 完整来说是 123456789101112RSAPrivateKey ::= SEQUENCE {version Version,modulus INTEGER, -- npublicExponent INTEGER, -- eprivateExponent INTEGER, -- dprime1 INTEGER, -- pprime2 INTEGER, -- qexponent1 INTEGER, -- d mod (p-1)exponent2 INTEGER, -- d mod (q-1)coefficient INTEGER, -- (inverse of q) mod potherPrimeInfos OtherPrimeInfos OPTIONAL} 一通操作后发现可以拿到 $n$,$e$,CRT 系数（即 $q^{-1}mod\\ p$ ）和 $d_q$ 低位，至于怎么拿到的等下再说，这里可以构造等式如下：$$ t = q^{-1} \\ (mod \\ p) \\\\ tq-1 = 0 \\ (mod \\ p) \\\\ tq^2 - q = 0 \\ (mod \\ n)$$然后$$ ed_q = 1 \\ (mod \\ q - 1) \\\\ ed_q - 1 = k(q - 1) \\\\ f = (dq_h + dq_l)e - 1 + k = kq$$代入得$$ tf^2 - kf = 0 \\ (mod \\ n)$$显然 $k$ 和 $e$ 数量级是相当的， $dq_h$ 的未知高位有512-120=392位，就可以通过 coppersmith 爆破 $k$ 。 参数提取然后就是有意思的部分了，如何从残损的私钥文件中提取参数呢？对着源码一顿调试了几个钟（太菜了呜呜），发现是先将各个参数塞进一个首位为 0 的数组，然后各个参数前面补上长度，后面 long_to_bytes 转换成 bytes ，最后拼接起来。我的提取脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from binascii import a2b_base64from Crypto.Util.asn1 import DerIntegerfrom Crypto.Util.number import *pem = '''-----BEGIN RSA PRIVATE KEY-----MIICXgIBAAKBgQDXFSUGqpzsBeUzXWtG9UkUB8MZn9UQkfH2Aw03YrngP0nJ3NwHUFTgzBSLl0tBhUvZO07haiqHbuYgBegO+Aa3qjtksb+bH6dz41PQzbn/l4Pd1fXmdJmtEPNh6TjQC4KmpMQqBTXF52cheY6GtFzUuNA7DX51wr6HZqHoQ73GQQIDAQAByQvOzxy6szWFheigQdGxAkEA4wFss2CcHWQ8FnQ5w7k4uIH0I38khg07HLhaYm1czUcmlk4PgnDWxN+ev+vMU45O5eGntzaO3lHsaukX9461mA==-----END RSA PRIVATE KEY-----'''pemlist = pem.split('\\n')decode_b64 = b''for i in pemlist[1:-1]: decode_b64+=a2b_base64(i)decode_b64 = decode_b64[4:] # 丢弃前4个字节der_int = DerInteger()# 提取nn = decode_b64[3:135]der_int.decode(n)print('[+] n =',n:=der_int.value)# 提取ee = decode_b64[135:140]der_int.decode(e)print('[+] e =',e:=der_int.value)# 提取CRT系数for len in range(1,300): try: q_inv_p = decode_b64[-len:] der_int.decode(q_inv_p) print('[+] q_inv_p =',q_inv_p:=der_int.value) except: len+=1 else: # print(len) # 67 break# print(q_inv_p.bit_length()) # 512# 提取dp低位dp_l = decode_b64[-82:-67]# print(dp_l)print('[+] dp_l =',bytes_to_long(dp_l)) 可以看到我一开始直接把前 4 个字节丢了，然后在新 List 里用库函数解析 3 - 134 号位的数据，这部分就是属于 $n$ 的，然而实际上 bytes_to_long 解析 7 - 134 号位的数据得到的也是 $n$ ，那么问题来了， 3 - 6 号位这 4 个字节里放了啥？ 以下是新List： 1\\x02\\x01\\x00\\x02\\x81\\x81\\x00\\xd7\\x15%\\x06\\xaa\\x9c... 这里涉及一个ASN.1（Abstract Syntax Notation dot one，即抽象记法1）的问题，简单来说就是将数据编码成 3 个部分：标志域、长度域、值域标志域中，约定 02 表示整数长度域稍微复杂些，记录的是值域的长度，分为定长和不定长两种情况定长时，若值域长度不超过 127 ，则用短格式表示，也就是直接用 16 进制表示，比如长度为 31 就是 0x1F ，即 0001 1111 ；若长度超过 127 ，则用长格式表示，首字节的首位置 1 表示长格式，后面7位则表示后面再跟多少个表示长度的字节，比如 1000 0001 表示后面 1 个字节表示长度，后面的长度也是直接用 16 进制表示。现在可以看到新 List 中， 0 号位为 02 表示整数， 1 号位 01 表示长度为 1 ， 2 号位 00 表示数据为 0 ，这就是上面提到的私钥文件结构中的那个 0 。再继续分析， 3 号位 02 表示数据为整数， 4 号位中的首比特为1表示使用长格式，后面 7 个比特为 000 0001 意为数据长度用 1 个字节表示，没错就是后面紧跟的 5 号位，表示数据长度为 0x81 ，转换成 10 进制就是 129 ，试了一下 6 - 134 号位用 bytes_to_long 解析出来的数据，也是 $n$那么现在你应该也可以尝试写出 $e$ 的编码： 1\\x02\\x03\\x01\\x00\\x01 细心的你还发现我开头扔了 4 个字节，猜猜是啥呢？答案是整个私钥文件编码后作为值域前面补的标签域和长度域，最前面再补一个 0 ，也就是 10\\x82\\x02^ 后两个字节 bytes_to_long 解码后是 606 ，恰为后面跟的完整数据的长度 后来偶然间发现竟然有类似的题目（）0CTF 2016 Quals equation 参考https://mp.weixin.qq.com/s/A9OmgHAmGLJPEL4cQBU8zQhttps://www.likecs.com/show-40060.html","link":"/2022/07/16/2022%E8%93%9D%E5%B8%BD%E6%9D%AF%20-%20corrupted_key/"},{"title":"Code-server配置","text":"在 Windows 上使用 WSL ，在 WSL 上使用 VSCode ，在 VSCode 上使用 Code-server。 Code-server 感觉不错，免去我远程桌面的麻烦。 安装 下载 Code-serverhttps://github.com/coder/code-server/releases/tag/v4.2.0 解压 tar -xvzf code-server.tar.gz cd 进解压后的目录，./code-server /home /home 可以替换成你想要的目录(这步不要在 VSCode 的终端执行) 配置找到 ~/.config/code-server/config.yaml ， bind-addr 项可以改你想要的端口，如 127.0.0.1：8080 ， password 项可以改密码。然后用 Nginx 代理出去就能在局域网上访问了。 ref:https://www.cnblogs.com/billyme/p/13769847.htmlhttps://blog.csdn.net/mijichui2153/article/details/18880283","link":"/2022/03/30/Code-server%20%E9%85%8D%E7%BD%AE/"},{"title":"Coppersmith","text":"研究一些多元 Coppersmith 前言不知不觉学密码有半年了，从最开始的 RSA 到格再到奇奇怪怪的东西，不禁感慨数学确实有趣。之前的 MRCTF 的题有道三元 Coppersmith ，可惜当时水平太过低微，既做不出来也看不懂 exp ，如今再回来补这个坑，就差不多可以往生 pwn 了。 Coppersmith 的大致思想可以参考 Tover 爷的这篇文章。 模根解模根的关键就是 Howgrave-Graham 定理：令 $h(x_1,…,x_n) \\in Z[x_1,…,x_n]$ 为一个至多含 $\\omega$ 个单项式的整数多项式，若满足$$h(x_1^{(0)},…,x_n^{(0)}) \\equiv 0 \\mod N^m \\enspace for\\enspace some\\enspace |x_1^{(0)}| &lt; X_1,\\dots,|x_n^{(0)}| &lt; X_n ,\\enspace and \\\\||h(x_1X_1,\\dots,x_nX_n)|| &lt; \\frac{N^m}{\\sqrt{\\omega}}$$则 $h(x_1^{(0)},…,x_n^{(0)}) = 0$ 在整数域上成立。 未完待续… 整根似乎是加个合适的模数？ 三元 Coppersmith参数解释论文里 $X,Y$ 和 $Z$ 不难理解是三个变量对应的界，但除此之外还有 $W,\\tau$ 和 $m$ 的选取，这也是我当前很迷糊的点，下面简单探讨一下。 首先是最简单的 $W$ ，论文明确给出 $W=||f(x_1X_n,\\dots,x_nX_n)||_\\infty$ ，而 $||f(x_1,\\dots,x_n)||_{\\infty}$ 的意思就是多项式的最大系数，所以 $W$ 就是多项式对各 $x$ 进行 $Xx$ 代入后的最大系数。如 $f=2x^2+3x+4$ ， $X=2$ ，则 $||f(x_1X_n,\\dots,x_nX_n)||=8x^2+6x+4$ ，显然最大系数在 $x^2$ 那，即 $W=8$ 。然后 $\\tau$ 和 $m$ 目前我也不知道咋算（） 杂谈直到现在才反应过来 paper 的引用名中后面的数字是年份（） 参考 知乎 -「:=」和「=:」的区别是什么？ Santanu Sarkar and Subhamoy Maitra. Some Applications of Lattice Based Root Finding Techniques [ELL06] E. Jochemsz and A. May. A strategy for finding roots of multivariate polynomials with new applications in attacking RSA variants, Asiacrypt 2006, LNCS 4284, pp. 267–282, 2006.","link":"/2022/10/15/Coppersmith/"},{"title":"Linux 学习笔记","text":"最近用到 Linux 挺多，整理一下。 终端美化一个好看的终端确实是第一生产力 123456789# 安装oh-my-poshsudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-poshsudo chmod +x /usr/local/bin/oh-my-posh# 下载主题mkdir ~/.poshthemeswget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zipunzip ~/.poshthemes/themes.zip -d ~/.poshthemeschmod u+rw ~/.poshthemes/*.omp.*rm ~/.poshthemes/themes.zip oh-my-posh get shell看看shell，一般是bash的情况下，就在~/.bashrc（也可能是~/.profile或~/.bash_profile）文件追加一行 1eval &quot;$(oh-my-posh init bash --config ~/.poshthemes/.kali.omp.json))&quot; # kali为主题名称，可以自己更换其他的 说起来这个 kali 主题还是 GZTime 学长提的 pr ，当时他还打成了 kail 来着（笑然后执行以下命令重载配置文件： 1exec bash oh-my-posh 官方文档：https://ohmyposh.dev/docs/ 换源CentOS 默认已经调好阿里源了，就不用换了，以下是 apt 换中大源的方法： 1sudo vim /etc/apt/sources.list 按 i 切换到编辑模式，然后全删了，写入 deb https://mirrors.matrix.moe/kali kali-rolling main non-free contrib，Esc 键退出编辑模式，:wq 保存退出。 更新软件源列表： 1sudo apt update ssh配置想起我闲置的阿里服务器，又折腾了好久。首先新建用户： adduser &lt;用户名&gt; 并设置好密码（网上说 CentOS 下的 adduser 和 useradd 是一样的，但我用的时候他也给我一整套配下来了，home 下也有文件夹。） 1234567su &lt;用户名&gt;ssh-keygen -t rsa #生成密钥对，一路回车就行cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys #把密钥添加到authorized_keys文件中chmod 600 authorized_keyschmod 700 ~/.ssh #权限700的时候，sshd才能读到service sshd restart #重启sshd服务 权限说明一般用三个数字表明文件的权限，第一个数字表示用户，第二个数字表示组，第三个数字表示公共。 4 表示可读， 2 表示可写， 1 表示可执行，加一起就是全部权限。比如 755 表示用户可读，可写，可执行，组可读，可执行，公共可读，可执行。 可能你会问 222 权限啥意思，难道还能只写不读？其实还真是这样，笔者试过可以 cat &gt;&gt; file 进行追加写入，但不能读取文件内容。 遇到文件执行不了的情况，试试 chmod +x [file] ，就有执行权限了。 编辑器（vim）虽然有 VSCode 的存在，但有时候由于 ssh 的用户权限不够等原因不可避免地要用到 vim （当然硬要避免也有在其他地方写好再 cp 过去等诡方法，但总是麻烦着点）vim 的三个模式：命令模式（ Command mode ），输入模式（ Insert mode ）和底线命令模式（ Last line mode ）一般就按 i 进入编辑模式， Esc 退出编辑模式并 :wq 保存退出。在查看模式下，可以 h 左移， j 下移， k 上移， l 右移，按 / 可以搜索。 常用命令 命令行 without 鼠标确实爽。 chown即 change owner ，用于改变文件的所有者。 一般 chown [user] [file] ，如果是目录还要加上 -R 参数，意为改变目录下所有文件的所有者。 ln即 link ，用于创建符号链接，和 Windows 的快捷方式类似。 一般 ln -s [old] [new] ，就是创建一个符号链接，把 old 文件的内容链接到 new 文件，如果后面不加 [new] 参数，那么就会默认创建到当前目录下。 ps即 process status ，用于查看进程状态。 一般加 -aux 显示所有包含其他使用者的进程。不过这只是一个快照，如果想看动态的，就用 top 命令。 top没啥缩写了，就是 top ，用于实时显示进程的状态。 参考https://www.lxlinux.net/1431.html菜鸟教程https://blog.csdn.net/KevinChen2019/article/details/119697489https://blog.csdn.net/lucky__peng/article/details/124268817https://blog.csdn.net/liuxiao723846/article/details/125042549","link":"/2022/07/07/Linux%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Matrix 面试 - Summary","text":"吃一堑，长一智。 第一次正经面试，虽然简历已经填得很谨慎，但是面试官还是没有放过我，从铜锣湾问到上海滩，而我：不清楚，没了解过，没听说过，忘了，不会。（安详） 痛定思痛，在按照学长的指引看书的同时，我也对提的问题作了总结，主要分为三个部分：算法、计算机网络、前端。 算法问了动态规划，计算机网络问了路由转发、https、DNS 和 CDN，这俩内容较少，并作一篇和其他杂项一起总结。前端问了 Promise、xss 注入、csrf 攻击、原生 JS 数据绑定和反射、CSS 盒模型以及行内元素和块级元素。 内容有点多，不定期更新（逃","link":"/2022/04/03/Matrix%20%E9%9D%A2%E8%AF%95%20-%20Summary/"},{"title":"Matrix 面试 - 前端篇","text":"持续懵逼 Promise 所有为你而行的空幻梦想，都不及最后与你许的愿望。——《梦回还》 异步编程JS有个很重要的部分叫异步编程，那么所以谓异步，大概可以通过这样一个例子说明： 一个网页，有文字，有图片，假定按照同步的方式来加载，那么就要等图片下载完了再加载内容，而如此一来，用户看到的就是一个空白了很久的网页突然弹出一堆东西，关键不在突然弹出，而在出现内容前的空白时间，用户一不耐烦给你关了，再花的网页都无用了（）。那么就有一个解决方法，先把文字渲染上去，然后等图片传输完成再渲染图片，这样就有一种99%的感觉，用户就没那么容易跑了。这就是异步的思想。 回调回调是一种早期的异步编程方式，但是由于其嵌套造成的“回调地狱”，现在基本已经不再使用，就不再赘述了。 期约一个简单的 Promise 实例： 123456789let p=new Promise((resolve, reject) =&gt;{ setTimeout(()=&gt;{ resolve('2'); },2000);})console.log('1');p.then((data)=&gt;{ console.log(data);}) 这段代码中定义了一个 Promise 对象 p，这个对象中的 setTimeout 会在 2 秒后调用 resolve 方法，resolve 方法一调用， p.then 就会执行，data 接的是 resolve() 传入的参数，这里是 ‘2’ 。 async/await待更新… xss注入XSS ,也就是 Cross-Site Scripting 的缩写，意为跨站脚本。具体来说就是把恶意代码注入到网页中，用户一打开网页，恶意代码就执行了。常见的 XSS 漏洞类型有如下几种： 反射/存储型 XSS DOM 操作型 XSS 反射/存储型 XSS反射型XSS通常是指恶意代码未被服务器存储，每次触发漏洞的时候都将恶意代码通过GET/POST方式提交，然后触发漏洞。 csrf 攻击最近打 CTF 见着一个叫 ssrf 攻击的，这俩长挺像，就想着是不是一个 Client 一个 Server ，再一搜，发现还真。。。不是。csrf 全称 Cross-site request forgery ，意为跨站请求伪造，而 ssrf 全称 Server-side request forgery ，意为服务器端请求伪造。 原生 JS 数据绑定和反射待更新… CSS 盒模型看吧，就是像个盒子（逃（图源菜鸟教程）Margin 指外边距，Border 指边框，Padding 指内边距，Content 指内容。然后没啥好解释了，实际上就是反复调整这几个部分的宽高，而且功夫不到家（像我这样）很容易被坑到，因为两个盒子之间可能会存在重叠。 行内元素和块级元素表面上说比较突出的特点就是块级元素单独占一行或者几行，而行内元素不占独立区域。 块级元素块级元素一般有下面几种： 123456&lt;h1&gt;~&lt;h6&gt;&lt;p&gt;&lt;div&gt;&lt;ul&gt;&lt;ol&gt;&lt;li&gt; 块级元素的宽度默认是容器的 100% ，也就是说它的宽度和父元素的宽度一样。里面也可以塞进行内元素和其他块级元素。 行内元素行内元素又名内联元素，一般有下面几种： 12345678&lt;a&gt;&lt;span&gt;&lt;b&gt;&lt;i&gt;&lt;em&gt;&lt;strong&gt;&lt;small&gt;&lt;del&gt; 行内元素和相邻行内元素是在同一行上的，而且有个关键的特点——它是不能调宽高的，默认宽高就是内容的宽高。但也不是完全定死，水平方向的 padding 和 margin 就是可调的。行内元素里面只能放纯文本或者其他行内元素，而不能放块级元素。 行内块级元素有这个玩意也是我始料未及的所谓行内块级元素，本质也是行内元素，但不同的是它具有块级元素可调高度的特性，而且和相邻的行内元素在同一行的时候，中间会有空白间隙。行内块级元素一般有下面几种： 123&lt;img/&gt;&lt;input/&gt;&lt;td/&gt; 持续更新中… 参考 《JavaScript高级程序设计》（第4版）——Matt Frisbie[著]李松峰[译] 《从0到1：CTFer成长之路》——Nu1L战队[著] https://blog.csdn.net/qingyafan/article/details/52203663 https://www.runoob.com/css/css-boxmodel.htmlhttps://blog.csdn.net/qq_34821198/article/details/91359274","link":"/2022/04/03/Matrix%20%E9%9D%A2%E8%AF%95%20-%20%E5%89%8D%E7%AB%AF%E7%AF%87/"},{"title":"Matrix 面试 - 算法&amp;计网篇","text":"开局暴击 算法面试官给了我一道力扣上的动态规划题，虽然我之前浅浅看过，但没刷过题，一时确实做不出来，然后他换了一道标着“简单”的动规题———经典爬楼梯，still，我还是不会，甚至思路来到了传说中的——递归（逃 直到面试结束后我才一拍脑门，原来递规与动归的区别是前者从后向前推，而后者从前向后推！ 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 分析不难看出，这题就是求一个斐波那契数列，即有$$ f(n) = f(n-1) + f(n-2)$$如果用递归，那么就是从 $f(n)$ 开始向前推，显然，这样的复杂度是 $O(2^n)$ 。但如果考虑动规，那么就是从 $f(1)$ 开始向后推，不难看出，此时复杂度就神奇般变成了—— $O(n)$ 。 计算机网络 前段时间由于众所周知的原因，学校把我们平时用的论坛屏蔽了，具体表现在用校园网打不开论坛的网页。后来发现是内网 DNS 搞的鬼，也就兴致勃勃地研究起计算机网络来，上课摸鱼的时候粗略看了一下网络层与网络互连的内容，然后写简历的时候就作死住上填了个“计网初步”，再然后——我就寄了。（安详）——引子 问：同一个子网一台主机向另一台主机发送数据，这个数据是否会直接被转发到另一台主机？ 七层网络模型，从底到顶分别是：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层（现在好像简化成四层来着），总之这个问题大概归到网络层和数据链路层的。然后呢，答案就是，我不知道！其实呢，我一开始以为自己知道了，但越看越不知道了，最后可能得把整个计网翻上一遍才能彻底整明白了。（没错这就是传说中的递归学习） 下面简单介绍几个概念，要理解这个问题就逃不开。 物理地址首先有一件事就是，IP 地址是逻辑网络上的东西，数据链路层是不能直接用的，就好像你要寄信给小 X 家，地址总不能直接填个“小 X 家”。而详细地址，在计网中叫物理地址，才是物理网络所认的标识。 ARP现在我们有了 IP 地址，就需要用ARP 协议(Address Resolution Protocol)来找到对应的物理地址。两者并非是简单的映射关系，而且也会动态变化，就像小 X 搬个家，那里就不叫小 X 家了，过一会搬个小 Y 来，又成了小 Y 家。 ARP cache为了解决这个问题，主机里就设置了个 ARP 高速缓存，即 ARP cache，上面存着本局域网上各主机和路由器的 IP 地址和物理地址的映射表。主机 A 向本局域网中的另一台主机 B 发送 IP 数据报时，就先看看里面有没有主机 B 的记录，有的话就好办了，把主机 B 的物理地址写入 MAC 帧里，然后丢进通信链路里就完事。But 事情总不可能这么简单，有相当大的概率表上是没有主机 B 的，这时主机 A 就会在所在局域网上广播一个 ARP 请求分组，这个广播可以类似生活中广播的概念，可以做到无差别攻击，就是局域网上的所有主机都会收到。这个 ARP 请求分组上有主机 A 的 IP 地址和物理地址，也有主机 B 的 IP 地址，主机 B ，说这不是我嘛，当即发一个单播回去，很快啊，上面有主机 B 的 IP 地址和物理地址。注意到，由于已经收到包含主机 A 物理地址的 ARP 请求分组，所以主机 B 能精准投递到主机 A ，而不用再广播了。显然这时双方都知道对方的物理地址，就写进各自的 ARP cache 中，以后通信就能直接扔过去了。至此，问题已经逐渐明朗，但有一个关键点，以上的讨论都是基于同一个局域网，而局域网和子网并无直接联系。 局域网这个概念非常广泛，一般来讲就是指一个小范围的网络，但这样事情就解释不通了，两台网线都不接的主机放在一起算不算同在一个局域网？说不清。所以较真点讲局域网指的是VLAN（Virtual LAN），即虚拟局域网，虚拟局域网 待更新… 参考https://blog.csdn.net/jeffleo/article/details/54174835","link":"/2022/04/03/Matrix%20%E9%9D%A2%E8%AF%95%20-%20%E7%AE%97%E6%B3%95&%E8%AE%A1%E7%BD%91%E7%AF%87/"},{"title":"Reed-Solomon 纠错码","text":"终于有时间整理一下了，爆破毕竟还是太粗鲁了。 羊城杯的一道题，题目中只破坏了消息的随机两个位置，消息又在 256 以内，所以可以直接暴力枚举。下面探寻优雅点的解法。 编码先来看看题目的代码，如下是编码的核心函数： 1234567891011121314m = 257F = Zmod(m)alpha = F(223)PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def encode_block(message): assert isinstance(message, list) f = PR([0] * 4 + message) px = f % gx mx = f - px c = [_ for _ in mx] return c + (8 - len(c)) * [0] 分析一下，代码中取一个生成多项式 $g(x)=(x-\\alpha^0)(x-\\alpha^1)(x-\\alpha^2)(x-\\alpha^3)$ ，然后将消息多项式 $M(x)$ 模 $g(x)$ ，得到余数多项式 $P(x)$ ，最后得到编码后的消息 $S(x)=M(x)-P(x)$ 。这时有 $S(x)\\equiv 0\\mod g(x)$ 。这里解释一下各个参数，当时我也是看了好久 sagemath 的文档也没搞懂。生成多项式 $g(x)=\\prod\\limits_{j=1}^{n-k}(x-\\alpha^j)$// TODO 解码照着这篇文章搓了个 PGZ 解码器，代码如下： 1234567891011121314151617181920212223242526def decode_block(r_x): S = [PR(r_x)(alpha^i) for i in range(4)] nu = 2 A = matrix(F,nu,nu) for i in range(nu): for j in range(nu): A[i,j] = S[i+j] b = vector(F,[-S[nu+i] for i in range(nu)]) x = list(A.solve_right(b)) x.append(1) x.reverse() Lambda = PR(x) I = [] for i in range(8): if Lambda(alpha^(-i))==0: I.append(i) I = I + [0] * (2 - len(I)) X = [alpha^I[i] for i in range(2)] A = matrix(F,2,2) for i in range(2): for j in range(2): A[i,j] = X[j]^i b = list(A.solve_right(vector(F,S[:2]))) for i in range(len(I)): r_x[I[i]] -= b[i] return r_x[4:] 参考 https://zhuanlan.zhihu.com/p/104306038 https://eprint.iacr.org/2017/733.pdf","link":"/2022/09/17/Reed-Solomon%20%E7%BA%A0%E9%94%99%E7%A0%81/"},{"title":"Squid 代理简记","text":"ChatGPT 确实是好东西 前言之前一直用的 ChatGPT 的号还是当时淘宝买的，还充了 Plus，但是不能改密码，有点强迫症，就想自己开个号。现在 ChatGPT 的号注册越来越麻烦了，万人骑的机场的 IP 已经被 ban 干净了，前几天就拜托一个新加坡的学长帮忙用自己邮箱的号开了个号，后继又想再帮同学开几个，但总不好一直叨扰学长，就想自己搭个梯子。 服务器问一个微软学生大使的同学在 Azure 开了台美国的机子（学生邮箱也可以白嫖），但是 SSH 老是连不上，一试发现是校园网的问题，用我阿里云的服务器去 SSH 就能稳定连上，再不久也发现原来我机场梯子老掉也是校园网的缘故，用阿里云的机子走机场稳定秒开 Google，当时我就气炸了。最终的方案是用阿里云的机子当跳板机去 SSH 美国的机子，./ssh/config 配置如下 12345Host &lt;你想叫啥就叫啥&gt; HostName &lt;x.x.x.x&gt; User &lt;user&gt; IdentityFile &lt;~/.ssh/US.pem&gt; ProxyCommand ssh -W %h:%p &lt;aliyun&gt; &lt;&gt; 里的内容自行替换。 SquidSquid 这个东西是 ChatGPT 推荐的，可以直接在机子开个 http 代理，简单方便。安装也是直接 sudo apt install squid 就行，然后把 /etc/squid/squid.conf 改成如下（不会用 vim 可以用 nano）： 123456789101112131415161718192021222324252627282930313233# ACLs all, manager, localhost, and to_localhost are predefined.acl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT# 拒绝所有非 Safe_ports 的请求http_access deny !Safe_ports# 拒绝所有非 SSL_prots 的 CONNECT请求http_access deny CONNECT !SSL_ports# 允许来自本地的请求http_access allow localhost# 拒绝所有请求，最后兜底的规则http_access deny all# 端口设为 3128http_port 3128# 高匿代理配置request_header_access Via deny allrequest_header_access X-Forwarded-For deny allrequest_header_access From deny all 然后 sudo systemctl restart squid，要等上一会，我应该等了差不多半分钟。 然后我端口转发搞了一天，失败得莫名其妙的，最终就直接用 VSCode SSH 后自带的端口转发顶着先了。 更新：后来用 SSH 的端口转发了，命令如下： 1ssh -N -L 0.0.0.0:55555:localhost:3128 &lt;your-azure&gt; 这样就可以在本地的 55555 端口访问到远程的 3128 端口了，0.0.0.0 是想给同一局域网的其他机子接，不需要的话可以只写端口，-N 意思是不启动远程 shell，如果你希望在后台运行可以再加个 -f。但是这样不够优雅，就再搞了个 systemd 的服务，配置如下： 123456789101112# /etc/systemd/system/ssh-tunnel.service[Unit]Description=SSH tunnel serviceAfter=network.target[Service]ExecStart=/usr/bin/ssh ssh -N -L 0.0.0.0:55555:localhost:3128 &lt;your-azure&gt;User=&lt;你的用户名&gt;Restart=always[Install]WantedBy=multi-user.target 然后 sudo systemctl daemon-reload 一下，再 sudo systemctl start ssh-tunnel 就行了，sudo systemctl enable ssh-tunnel 可以设置开机自启。 参考 https://zhuanlan.zhihu.com/p/562014043","link":"/2023/05/14/Squid%20%E4%BB%A3%E7%90%86%E7%AE%80%E8%AE%B0/"},{"title":"VSCode 写 C","text":"一句话：VSCode 确实是一个好东西 前言 在用 VSCode 前，我写 C 一直用的是 VS2019 ，直到我看见了 GZTime 学长写的 Visual Studio Code Guide 一文并照着配了后，我乐了，原来 VSCode 如此好用。首先作为一个编辑器，它比 VS2019 这个 IDE 小了太多（一个几十 MB ，一个 10 个 GB ），其次，它配上 gcc 可以避免 VS2019 由于 msvc 导致的 scanf_s 等一堆 _s（或许我的表述不是太严谨，但差不多是这个意思）。本文高度概括了学长的文章，说是转载也不为过，读者根据自身水平可酌情移步至原文。 安装链接下载链接 注意事项 安装 gcc 时取消勾选 Check for updated files on the TDM-GCC server。 安装 VSCode 时在附加任务中“其他”中的四项全部勾选，即将用 Code 打开加入文件和文件夹添加入右键菜单中，并注册为受支持的文件类型的编辑器。 不推荐更改默认文件夹（别抠这点空间了）。 普通配置安装好 VSCode 和 gcc 后，重启电脑，运行 VSCodeCppHelper ，如果你对在哪创建文件夹没有好的选择，就把 VSCodeCppHelper 放 C 盘随便一个地方里运行，然后傻瓜式 enter 。 机房里配置 由于 GZTime 学长写的 VSCodeCppHelper 小工具需要重启才能识别出 VSCode 和 gcc 的安装，但是机房的电脑一重启所有东西又会全部重置，此时便只能手动配置了。（以下均为转载）更新：如今 VSCodeCppHelper 已经支持在没检测到环境变量的情况下进行配置了。 打开 VSCode 至你的文件夹（此处以 C:\\Coding 为例）。 打开左侧 Extensions 选项卡，搜索 C++ 并安装 C/C++ 和 C/C++ Intellisence 两个扩展。 在根目录新建文件夹 Scripts 以及 Debug 在 Scripts 文件夹中新建文件 helloworld.cpp ，写下传统的 helloworld 程序： 1234567#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; return 0;} 单击左侧菜单中的运行并点击运行和调试，选择 C++(GDB/LLDB) 。 此时 VSCode 会在你的根目录下新建 .vscode 文件夹，此文件夹中用于存放 VSCode 的相关配置文件，打开 launch.json 替换或修改为如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;C++ Run&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceRoot}/Debug/${fileBasenameNoExtension}.exe&quot;, //运行文件的路径 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;console&quot;: &quot;internalConsole&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:/TDM-GCC-64/gdb64/bin/gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Compile&quot; //运行前需要完成的任务 }, { &quot;name&quot;: &quot;C Run&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceRoot}/Debug/${fileBasenameNoExtension}.exe&quot;, //运行文件的路径 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;console&quot;: &quot;internalConsole&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:/TDM-GCC-64/gdb64/bin/gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Compile_C&quot; //运行前需要完成的任务 } ]} 在 .vscode 文件夹中新建文件 tasks.json 并输入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Compile&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, //指定编译源代码文件 &quot;-o&quot;, &quot;${workspaceRoot}\\\\Debug\\\\${fileBasenameNoExtension}.exe&quot;, // 指定输出文件名，不加该参数则默认输出a.exe &quot;-ggdb3&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-std=c++2a&quot;, &quot;-Wno-format&quot;, &quot;-finput-charset=UTF-8&quot;, //输入编译器文本编码 默认为UTF-8 &quot;-fexec-charset=UTF-8&quot; //编译器输出文本编码 自行选择 ], &quot;type&quot;: &quot;shell&quot;, &quot;presentation&quot;: { &quot;echo&quot;: true, &quot;reveal&quot;: &quot;silent&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never &quot;focus&quot;: false, &quot;panel&quot;: &quot;shared&quot;, // 不同的文件的编译信息共享一个终端面板 &quot;clear&quot;: true, &quot;showReuseMessage&quot;: true }, &quot;problemMatcher&quot;: { &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;\\\\&quot;], &quot;pattern&quot;: { &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 } } }, { &quot;label&quot;: &quot;Compile_C&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, //指定编译源代码文件 &quot;-o&quot;, &quot;${workspaceRoot}\\\\Debug\\\\${fileBasenameNoExtension}.exe&quot;, // 指定输出文件名，不加该参数则默认输出a.exe &quot;-ggdb3&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-Wno-format&quot;, &quot;-finput-charset=UTF-8&quot;, //输入编译器文本编码 默认为UTF-8 &quot;-fexec-charset=UTF-8&quot; //编译器输出文本编码 自行选择 ], &quot;type&quot;: &quot;shell&quot;, &quot;presentation&quot;: { &quot;echo&quot;: true, &quot;reveal&quot;: &quot;silent&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never &quot;focus&quot;: false, &quot;panel&quot;: &quot;shared&quot;, // 不同的文件的编译信息共享一个终端面板 &quot;clear&quot;: true, &quot;showReuseMessage&quot;: true }, &quot;problemMatcher&quot;: { &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;\\\\&quot;], &quot;pattern&quot;: { &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 } } } ]} 类似的，配置 c_cpp_properties.json ，这个我不知道要不要（逃 123456789101112131415161718192021222324252627{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;C:/TDM-GCC-64/bin/g++.exe&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++20&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;, &quot;macFrameworkPath&quot;: [], &quot;browse&quot;: { &quot;path&quot;: [ &quot;C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/10.3.0/include/*&quot;, &quot;C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/10.3.0/include/c++/*&quot; ] } } ], &quot;version&quot;: 4} 搬砖完毕（逃 中文乱码VSCode 中默认终端常为 PowerShell ，Windows 10 中 PowerShell 默认编码跟随系统，可以通过修改区域设置来改变默认编码： 控制面板-&gt;区域-&gt;更改系统区域设置-&gt;勾选 Beta版：使用Unicode:UTF-8以获取全球语言支持，但这样可能会造成其他应用乱码，笔者就因为这个事情改回去了。 VSCode 使用的注意事项 虽说 VSCode 好，但有几点注意的，被坑过。。。 不要直接在文件夹双击打开 .c 文件启动 VSCode 不要给 .c 文件起中文名 不要在其他文件夹（除了你最初配置好的文件夹，比如桌面）中启动 VSCode 以上配置无法进行多文件编译 以上说法仅针对初学者，均不严谨 参考 Visual Studio Code Guide by GZTimehttps://blog.csdn.net/m0_55005568/article/details/119960552","link":"/2021/12/29/VSCode%20%E5%86%99%20C/"},{"title":"pwn 入门","text":"浅记一下这些天学 pwn 的历程 前言本文默认读者具有一定的汇编基础。 ELF文件的结构ELF（Executable and Linkable Format）即 Linux 下的可执行文件格式，和 Windows 下的 PE 格式类似，但 Linux 中的可执行文件一般不会加后缀名。ELF 文件中有多个节（ Section ），主要有： .text 节：即代码段，用来放代码 .rodata 节：ro 即 read only ，只读数据段，用来放静态数据，如果尝试修改会报错 .rdata和.rodata的区别：两者都是只读数据段，但.rdata是 Windows 的常用说法，而 Linux 中则一般称.rodata .data 节：数据段，存放可修改的数据 .bss 节：中文不知道叫什么名字的段，也是放可修改的数据，但是没有初始化，所以不占ELF文件的空间，程序运行时会自动分配内存 .plt 节和 .got 节：外部调用段（也不知道叫什么名字，这个是 AI 给我打的），调用动态链接库的函数的时候会用到 Linux下的漏洞缓解措施有攻就有防，为了不被攻击者随便打烂，一些防范措施是必不可少的。在终端里可以执行checksec --file=文件名来查看 ELF 文件的保护机制。 NX ( No eXecute )(没错 X 就是大写，没打错) 基本规则为可写权限与可执行权限互斥，即可被修改写入 shellcode 的内存都不可执行，被执行的代码数据不可修改，至于 shellcode 是啥，后面再提。 gcc 默认开启，编译加-z execstack参数可以关闭 Stack Canary Canary 意为金丝雀，以前矿工进入矿井时都会随身带一只金丝雀，通过观察金丝雀的状态来判断氧气浓度等情况。这个保护专门针对栈溢出攻击。 gcc 同样默认开启，编译加fno-stack-protector参数关闭 ASLR ( Address Space Layout Randomization ) 将程序的堆栈地址和动态链接库的加载地址进行一定的随机化 ASLR 是系统级的保护机制，关闭要修改 /proc/sys/kernel/randomize_va_space 文件，写入 0 即可 PIE ( Position Independent Executable ) 和 ASLR 类似，让 ELF 的地址随机化加载 高版本 gcc 默认开启，编译加-no-pie参数可以关闭，旧版本则需加-fpic-pie参数开启 Full RELRO ( Read-Only Relocation ) 禁止写入.got.plt表 gcc 编译加-z relro参数开启。 GOT和PLT.plt表是一段代码，可从内存中读取一个地址然后进行跳转，而.got.plt表则存放函数的实际地址。实际上，.got.plt表是一个函数指针数组，存放 ELF 所有用到的外部函数在内存中的地址，由操作系统初始化。题目中如果没开Full RELRO保护，那么就有可能通过修改.got.plt表中的函数地址来偷梁换柱，比如把表中puts的地址换成system的地址就能使puts(&quot;\\bin\\sh&quot;)变成system(&quot;/bin/sh&quot;)，从而拿到 shell 。 常用工具 IDA 拿到程序第一件事——用 IDA 看看伪代码 分 32 位和 64 位两个版本，这个打开不行就换另一个，虽然我也不知道为啥不加个自动识别（） 把程序拖进去，弹出一个奇怪的选项框，初学者直接enter或者点OK就完事，然后进到IDA View-A标签页，这里初始时一般是流程图的形式，在此标签页按空格可以切换到普通模式，记住不是在Pseudocode-A按 这时候按F5生成伪代码，看到顶上的标签页切到了Pseudocode-A， Pseudocode 是伪码的意思，至于这个 A ，你如果再按一次 F5 就能新建一个Pseudocode-B了（） 然后就可以这点点那点点发现新世界了，嘿嘿 如下是一些常用的快捷键： 按 Esc 可以返回刚才的页面 按 Tab 可以在 IDA View-A 和 Pseudocode-A 等标签页之间切换 双击函数或者变量可以跳转到它所在的地方 点一下变量再按 N 可以对变量重命名，有时方便分析 Shift+F12 查找字符串 pwntools python 的一个库，可以用与远程服务器或者本地程序交互，但不保证在 Windows 下能正常使用（反正我 Windows 跑 pwntools 是有问题的 常用操作： r = process(&quot;./pwn&quot;) 本地运行程序（其实本地一般用 p 作变量表示process或者io兼顾本地和远程，看个人习惯了 r = remote(ip, port) 连接服务器 r.sendline(data) 发送数据，末尾补 \\x0a（换行符） r.send(data) 发送数据，末尾不补 \\x0a r.recvline() 接收一行数据 r.recvuntil(str) 接收直到遇到 str 为止 r.recv(n)接收 n 个字节 r.interactive() 开始人工手动交互 pwntools 在 python3 中使用的话，交互的数据都是 bytes 类型，而不是 str 类型，意思就是 send 里的东西要是字节串， recv 出来的也是字节串，字符串转字节方法一般是 str.encode() ，或者 send(b'hello') pwndbg pwn 里面少不了本地调试，正常人都不能肉眼分析，那么就要用到 gdb ，but 裸的 gdb 太朴素了，不能满足人们日益增长的对优雅的追求，所以就有了颜值极高的 gdb 插件—— pwndbg 安装方式： 123git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh 然后康康 ~/.gdbinit 里有没有 source ~/pwndbg/gdbinit.py ，如果没有就加上，然后 source ~/.gdbinit ，然后就可以愉快地玩耍了 在 VSCode 里起 gdb 要用 tmux ，直接 sudo apt-get install tmux 安装 tmux的简单使用： tmux 进入窗口 tmux ls 查看会话列表 Ctrl+B 左右键 切换会话窗口，一般默认左右分布，也可调成上下 Ctrl+B D 退出当前会话但不关闭，可以 tmux attach -t &lt;会话名&gt; 再次进入 脚本里可以使用如下语句起 gdb： 123p = process('./pwn')context.terminal = ['tmux','splitw','-h']gdb.attach(p,gdbscript=&quot;b main&quot;) pwndbg 界面由上至下依次为 legend：图例，一般指示黄色为 Stack（栈），蓝色为 Heap（堆），红色为 Code（代码），紫色为 Data（数据），白色下划线为RWX（不知道啥），白色为 Rodata（只读数据） registers：显示 CPU 的寄存器值 disasm：显示当前地址的反汇编代码 stack：显示栈的内容 backtrace：显示调用堆栈（我也不知道具体干嘛的） 常用操作： x/4xg 0x400000查看内存中地址0x400000开始的 4*16 个字节，以 8 个字节每组的 16 进制形式显示，一般在分析 64 位程序时使用，因为 64 位程序的地址是 8 个字节， 32 位时，命令可以换成 x/4x ，每组 4 个字节，适用 32 位程序的地址 ni 也就是 next into ，执行下一条指令，如果是函数调用，就进入函数 si 也就是 step into ，执行下一条指令，如果是函数调用，就进入函数，但是不会执行函数内的第一条指令，而是停在函数内的第一条指令上 c continue ，继续执行，直到遇到断点或者程序结束 q quit ，退出 gdb vmmap 查看内存映射，可以看到程序的基地址，栈地址，堆地址等，后面加个 libc 可以单看 libc 的基地址（白色的那行 常见攻击方式整数溢出这个比较简单，大概就是通过溢出绕过一些大小判断，不再赘述。 栈溢出先说几个概念执行 call 指令时， CPU 会先把 call 指令的下一条指令地址压栈再跳转，返回时 ret 指令会从栈中把存放的地址弹出到 EIP 。gets 不检查读入的字符串长度，所以可能会出现栈溢出。当栈作为缓冲区时，如果输入的数据长度超过缓冲区的长度，就会发生栈溢出，从而覆盖返回地址，从而控制程序流程。 未完待续… 参考 《从0到1：CTFer成长之路》——Nu1L战队[著] 《CTF竞赛权威指南.Pwn篇》——杨超[著] https://blog.csdn.net/sui_152/article/details/121650341 https://stackoverflow.com/questions/65745514/what-is-the-difference-between-rodata-and-rdata https://blog.csdn.net/weixin_52553215/article/details/120690453 https://blog.csdn.net/zino00/article/details/122716412 https://blog.csdn.net/Demondai999/article/details/123875264","link":"/2022/07/18/pwn%20%E5%85%A5%E9%97%A8/"},{"title":"一个简单的作业提交平台","text":"这个项目大概是上星期五晚开始做的，之所以现在才写这篇文，纯粹是因为没有时间，刚好今早把高数写完了， CAD 又不想动，于是便借此时间简单总结一下。 首先写这个网站的起因是邮箱发作业实在是过于麻烦，看着隔壁广州计算机的都用着 Matrix（一个我们大学学生运维的 OJ ，即在线判题平台），一点提交就有结果，而我们交作业却是原始的上交源文件和运行截图，我也无何办法，谁让我们是材料计算机呢（并无歧视材料的意思，只是单纯地憎恶化学，高中本就没选）。等我和课代表商量的时候，他也表示早已被不按规则提交的作业搞得苦不堪言（乐），想了想，虽然费劲写个小破站有些浪费时间，与大卷之势相悖，但毕竟也算有点意思，便做了下去。 开始最初的文件是直接抄中国人民公安大学的一道信安题的，代码附上： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465header(&quot;Content-type: text/html;charset=utf-8&quot;);error_reporting(0);//设置上传目录define(&quot;UPLOAD_PATH&quot;, dirname(__FILE__) . &quot;/upload/&quot;);// define(&quot;UPLOAD_URL_PATH&quot;, str_replace($_SERVER['DOCUMENT_ROOT'], &quot;&quot;, UPLOAD_PATH));if (!file_exists(UPLOAD_PATH)) { mkdir(UPLOAD_PATH, 0755);}if (!empty($_POST['submit'])) { if (!$_FILES['file']['size']) { echo &quot;&lt;script&gt;alert('请添加上传文件')&lt;/script&gt;&quot;; } else { $name = basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], UPLOAD_PATH . $name)) { echo &quot;&lt;script&gt;alert('上传成功')&lt;/script&gt;&quot;; echo &quot;上传文件相对路径&lt;br&gt;&quot; . &quot;/upload/&quot; . $name; } else { echo &quot;&lt;script&gt;alert('上传失败')&lt;/script&gt;&quot;; } }}$myfile = fopen(&quot;log.txt&quot;, &quot;a&quot;) or die(&quot;Unable to open file!&quot;); fwrite($myfile,$_SERVER[&quot;REMOTE_ADDR&quot;]); $txt=&quot;\\n&quot;; fwrite($myfile,$txt); fclose($myfile);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;PPSUC 文件上传 - js前端验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;PPSUC 文件上传 - js前端验证&lt;/h1&gt; &lt;p&gt;本题从PPSUC窃取得来&lt;/p&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;return checkfilesuffix()&quot;&gt; &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt;&lt;script&gt;function checkfilesuffix(){ var file=document.getElementsByName('file')[0]['value']; if(file==&quot;&quot;||file==null) { alert(&quot;请添加上传文件&quot;); return false; } else { var whitelist=new Array(&quot;.jpg&quot;,&quot;.png&quot;,&quot;.gif&quot;); var file_suffix=file.substring(file.lastIndexOf(&quot;.&quot;)); if(whitelist.indexOf(file_suffix) == -1) { alert(&quot;:(该文件不允许上传:(&quot;); return false; } }}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这题考的是 JS 前端验证的绕过，解出题后的我深知前端验证的不可靠，便知道敏感的操作限制应该加在后端了。但毕竟前端也得有点拦一下不是，否则累死后端不说，代码冗杂也是一个问题。上百度抄一抄，后端的后缀限制也完成了（解释一下，之所以限制文件后缀，一方面是因为提交的文件格式问题，一方面是安全问题，假若给你上传了一个 php 木马而我又没加限制访问的情况下， RCE 就是件很简单的事情了，之后你可以查看和操作任意权限允许的文件，总之是很危险的事）。在完成后缀的限制后，我又加了如下的诸多验证： 文件大小非空且大小须小于512KB(后来改成了666KB) ：否则给你当网盘使那我服务器也是难顶，而且源文件最大也没什么可能超过 10 KB，截图预计也是几十 KBupload目录的访问限制：可不能给随便偷了作业看姓名不能为空且不多于4个字：这个问过课代表，我们班的名字没有超过 3 个字的学号范围：086-199 ，但有一个人的学号孤悬在外，有些奇怪（乐）姓名和学号的联合验证：这个是前两天才加上去的，主要是忘了之前的军事课有份名单（但是那位竟然是没有的，再处理吧） 后端处理逻辑重构一开始我是设置先新建（姓名+学号）的一个目录，再逐个文件进行判断，若符合条件则放进目录里，但这就会引发一个问题，如果有文件不符合条件的话目录仍会存在，而为了防止有意或是无意的重复上传导致原文件被覆盖，我又设置了若目录已存在则不能继续放文件,于是我在上机课的时候改成了先全部验证通过再上传目录。 管理员端毕竟作业也不是我收的，如果每次都要我来登录服务器下载未免也太过麻烦，于是我抄了段多级目录压缩的代码，在管理员通过验证后将提交上的作业打包成了个 zip ，再存储于基于 SHA256 算法生成的时间哈希值命名的目录中，这样大概便无法被直接扫描出来了。管理员的登录验证我采用的是RSA公钥加密出的一段 base64 编码的字符串，若在后端用私钥解密后得到明文”admin”便通过验证，但想了想似乎没必要用非对称加密，有空再改。除此之外，我还加了个验证码，但是在 Firefox 上似乎不能正常刷新，于是就没加在学生端了。 前端的样式这个是我最无奈的地方，个人的美术功底着实是捞得亚匹，布局和配色搞得乱七八糟，在此就希望同学多多与我反馈了。 一些问题开源本来打算上传到 github 的，但是还没处理好重要文件的放置（总不能学号和姓名也开源不是）。 更新：项目已发布于https://github.com/weyung/A-simple-homework-submission-platform JQuery说来有些可笑，我一开始是用原生 Javescript 写的前端，代码繁琐且在使用 ajax 的时候被异步坑了一把：我写了一个函数调用后端的接口然后 return 数据，却发现主函数中得到的结果总是 undefined ，后来才知道是先 return 再接收数据，晕。而用 JQuery 一个回调函数就搞定了，虽然 JQuery 似乎的确有些过时，但有空再看 React、Vue 什么的吧。 SSH之前是想用 VSCode 写代码的，但是 SSH 一直显示什么管道不存在，直到今晚才瞎搞接通了。用宝塔的在线文本编辑器写了一个星期的代码，现在终于能有舒服点的高亮了。至于调试也是个问题，因为懒得搭本地环境，我至今还是肉眼调试，有空也得处理下。","link":"/2021/12/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E5%B9%B3%E5%8F%B0/"},{"title":"一个简单的本地判题脚本","text":"在做程序设计作业的时候，题目经常是要输入 10 个数字，但用不起 Matrix 的我只能手动输入，不但麻烦，而且也很难模拟随机过程，想过做一个 OJ （在线判题平台），但又苦于不会用 Docker ，思来想去，就用 Python 写了个本地判题脚本，虽然还不能防恶意代码，也无法实现内存检查，但基本的输入输出还是能够做到，供君一乐。 源码Windows下鉴于本人是追求实用（能跑就行），同理猜测读者也不关心这到底怎么实现，或者说不着急关心，于是直接附上 Windows 环境下的 Python 源码，开盒即用，只需要你有一点 Python 的基础，会装 subprocess 和 tqdm 库就行，然后在脚本所在的目录新建一个名为标准代码的文件夹，并在里面放入一个std.c作为测试输出的基准参照，同理新建一个测试代码的文件夹并放入test.c作为被测试的代码，同时安装好gcc，运行脚本，就能大功告成了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import subprocessimport randomimport sysfrom tqdm import tqdmdef random_int_list(start, stop, length): start, stop = (int(start), int(stop)) if start &lt;= stop else ( int(stop), int(start)) length = int(abs(length)) if length else 0 random_list = [] for i in range(length): random_list.append(random.randint(start, stop)) return random_listdef iotest(filename, path, data): obj = subprocess.Popen([filename], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=path, encoding=&quot;utf-8&quot;,shell=True) obj.stdin.write(data) out_info, out_error = obj.communicate() # 简单写法，out_info：标准输出 # print(out_info,out_error) return out_infoif __name__ == '__main__': stdpath = &quot;%s\\\\标准代码\\\\&quot; % sys.path[0] # 标准代码所在路径 testpath = &quot;%s\\\\测试代码\\\\&quot; % sys.path[0] # 测试代码所有路径 #编译标准及测试代码 result = subprocess.check_output(&quot;gcc -std=c99 -o std std.c&quot;, shell=True, cwd=stdpath) result = subprocess.check_output(&quot;gcc -std=c99 -o test test.c&quot;, shell=True, cwd=testpath) f = open('%s\\测试结果.txt' % sys.path[0], 'w+', encoding='utf-8', newline=&quot;&quot;) print('随机测试中...') pas=0 # 通过次数 freq=10 # 测试次数 for index in tqdm(range(freq)): # 生成测试数据 rtest = random_int_list(0, 99, 10) s = '' for i in rtest: s = &quot;%s%s &quot; % (s, i) s = &quot;%s\\n&quot; % s # 进行测试 output = iotest(&quot;.\\\\test.exe&quot;, testpath, s) stdoutput = iotest(&quot;.\\\\std.exe&quot;, stdpath, s) f.write(&quot;随机测试 - r,%d数据点\\n&quot;%index) f.write(&quot;标准输入\\n%s&quot; % s) f.write(&quot;实际输出\\n%s\\n&quot; % output) f.write(&quot;期望输出\\n%s\\n\\n&quot; % stdoutput) if output==stdoutput: f.write('通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) pas=pas+1 else: f.write('未通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) f.close() print('随机测试 %d/%d'%(pas,freq)) print('测试完成') 同时附上样例标准代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#define N 10void inputarray(int *arr);void handlearray(int *arr);void outputarray(int *arr);void swap(int *p,int *q);int main(){ int array[N]= {0}; inputarray(array); handlearray(array); outputarray(array); return 0;}void swap(int *p,int *q){ int temp=*p; *p=*q; *q=temp;}void handlearray(int *arr){ int *p=arr; int max_index=0; int min_index=0; int max=arr[0]; int min=arr[0]; for(int i=1;i&lt;N;i++) { if(*(p+i)&gt;max) { max=*(p+i); max_index=i; } if(*(p+i)&lt;min) { min=*(p+i); min_index=i; } } swap((p+max_index),(p+9)); swap((p+min_index),(p+0));}void inputarray(int *arr){ int *p=arr; for(int i=0; i&lt;N; i++) { scanf(&quot;%d&quot;,(p+i)); }}void outputarray(int *arr){ int *p=arr; for(int i=0; i&lt;N; i++) { printf(&quot;%d &quot;,*(p+i)); }} 以及样例测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(){ void inv(int *x, int n); int i, a[10]; for (i = 0; i &lt; 10; i++) scanf(&quot;%d&quot;, &amp;a[i]); //printf(&quot;\\n&quot;); inv(a, 10); //printf(&quot;The array has been inverted:\\n&quot;); for (i = 0; i &lt; 10; i++) printf(&quot;%d &quot;, a[i]); //printf(&quot;\\n&quot;); return 0;}void inv(int *x, int n){ int *i, max, min, p, q, *c, *d; max = *x; min = *(x + 1); c = x + 0; d = x + 1; for (i = x; i &lt; x + 10; i++) if (*i &gt; max) { max = *i; c = i; } for (i = x; i &lt; x + 10; i++) if (*i &lt; min) { min = *i; d = i; } p = *x; *x = *d; *d = p; q = *(x + 9); *(x + 9) = *c; *c = q;} Linux 下的 Python 源码一个现象就是， Linux 下进行测试的速度明显比 Windows 下快，我测试的时候两者甚至相差 100 余倍，其中原因可留给读者细究。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import subprocessimport randomimport sysfrom tqdm import tqdmdef random_int_list(start, stop, length): start, stop = (int(start), int(stop)) if start &lt;= stop else ( int(stop), int(start)) length = int(abs(length)) if length else 0 random_list = [] for i in range(length): random_list.append(random.randint(start, stop)) return random_listdef iotest(filename, path, data): obj = subprocess.Popen([filename], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=path, encoding=&quot;utf-8&quot;) obj.stdin.write(data) out_info, out_error = obj.communicate() # 简单写法，out_info：标准输出 # print(out_info,out_error) return out_infoif __name__ == '__main__': stdpath = &quot;%s/标准代码/&quot; % sys.path[0] # 标准代码所在路径 testpath = &quot;%s/测试代码/&quot; % sys.path[0] # 测试代码所有路径 #编译标准及测试代码 result = subprocess.check_output(&quot;gcc -std=c99 -o std std.c&quot;, shell=True, cwd=stdpath) result = subprocess.check_output(&quot;gcc -std=c99 -o test test.c&quot;, shell=True, cwd=testpath) f = open('%s/测试结果.txt' % sys.path[0], 'w+', encoding='utf-8', newline=&quot;&quot;) print('随机测试中...') pas=0 # 通过次数 freq=100 # 测试次数 for index in tqdm(range(freq)): # 生成测试数据 rtest = random_int_list(0, 99, 10) s = '' for i in rtest: s = &quot;%s%s &quot; % (s, i) s = &quot;%s\\n&quot; % s # 进行测试 output = iotest(&quot;./test&quot;, testpath, s) stdoutput = iotest(&quot;./std&quot;, stdpath, s) f.write(&quot;随机测试 - r,%d数据点\\n&quot;%index) f.write(&quot;标准输入\\n%s&quot; % s) f.write(&quot;实际输出\\n%s\\n&quot; % output) f.write(&quot;期望输出\\n%s\\n\\n&quot; % stdoutput) if output==stdoutput: f.write('通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) pas=pas+1 else: f.write('未通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) f.close() print('随机测试 %d/%d'%(pas,freq)) print('测试完成')","link":"/2021/12/28/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%88%A4%E9%A2%98%E8%84%9A%E6%9C%AC/"},{"title":"变量指针指向的常量","text":"关于 char *s=&quot;ABCDE&quot; 为什么是有问题的 前言之所以会注意到这个问题，是因为老师布置的课堂小测的一道题，原题如下： 下面能正确进行字符串赋值操作的是____。A. char s[5]={“ABCDE”};B. char s[5]={‘A’,’B’,’C’,’D’,’E’};C. char *s;s=”ABCDE”;D. char *s;scanf(“%s”,s); 当看到答案选 B 的时候，我人傻了，因为我上网查的答案是C，纳闷着调试，结果如下： B 选项的做法不会在后面补零终止符'\\0'，此时执行printf(&quot;%s&quot;,s);会打印出ABCDE后面跟着一串乱码。C 选项的做法会在后面补零终止符，且编译器编译不报错，运行同样不报错。 此时的我更加疑惑，B 选项这不是有问题了吗？询问老师，老师给出的解释是： 题干说进行字符串赋值操作，而 C 选项是给指针赋值 这个解释离大谱。 后来在 GZTime 及 Hanmur 学长的无语点拨下，我注意到了 C 选项的一个问题。 常量指针与变量指针首先先引入常量指针与变量指针的概念，顾名思义，变量指针就是指向变量的指针，如： 12int a=0;int *p=&amp;a; 此时 a 是一个变量， p 则是一个指向变量 a 的指针，即为变量指针。而同理，常量指针是一个指向常量的指针，如： 12const int a=0;const int *p=&amp;a; 此时 a 是一个常量， p 是一个指向常量 a 的指针，即为常量指针。注意： 常量指针的声明格式为 数据类型 const * 指针变量 或者 const 数据类型 *指针变量。 变量还是常量？那么问题来了，char *s=&quot;ABCDE&quot;一句中， s 指向的字符串是常量还是变量？一个很简单的区分方式是，尝试改变字符串的字符。 1234char t[]=&quot;ABCDE&quot;;t[0] = 'F';char *s=&quot;ABCDE&quot;;s[0]='F'; 运行结果是：前两句可以正常执行，而执行第 4 句时则会弹出 Segmentation fault。对程序进行分析可以知道，char *s=&quot;ABCDE&quot;;一句会把字符串存储到只读的 rdata 段，所以无法改变其中的内容。也就是说，char *s=&quot;ABCDE&quot;一句中，s 指向的字符串是常量。 总结那么回到开始的问题，char *s=&quot;ABCDE&quot;; 为什么是错的答案是，它用一个变量指针指向了一个常量！正确的写法应为：const char *s=&quot;ABCDE&quot;;也许当你编译时不会报错，甚至运行时不去改变里面的值时也不会发生中断，但这个语句的的确确是有问题的。","link":"/2021/12/30/%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%B8%B8%E9%87%8F/"},{"title":"宿舍影院搭建 &amp; 五刷《铃芽之旅》后的浅评","text":"越来越不务正业乐！ 前言初三时基本将宫崎骏和新海诚的电影都看了一遍，比较喜欢日本动画的风格，这次的《铃芽之旅》终于是在电影院看了，为了对比不同影院的观影效果，特意去了五次，然后，就破产了。 宿舍影院搭建之前用的显示屏是 16:9 27 英寸屏，但现在很多电影都是宽幕，在宿舍用投影仪也不现实 （其实也不是完全不现实），所以就买了一个 21:9 34 英寸的带鱼屏。因为对床开着灯会导致屏幕反光，就买了个桌帘挡着，效果就很好了。音响用的是漫步者的 R501BT，5.1声道，759 入的，看到上一年双十一最低价有到 600，但本着早买早享受的原则，就没等了。桌子左边是衣柜，隔板会增强回音，导致声场不平衡，就买了块 50*50 的吸音棉，回音基本消了，还顺便起到吸光的效果。后面的两个音箱架高，可以感觉到天上的雨声。 显示屏主要看分辨率、色深、色域、色准、防蓝光、亮度、对比度、刷新率、响应时间、HDR、曲率。 分辨率这个其实没啥好讲的，越高越好，不追求带鱼屏的话直接 4K，比 1080P 和 2K(1440P) 清晰得多。 色深色深会影响颜色过渡的平滑度，一般都是 8 位，很多 10 位也是 8 位抖出来的，原生 10 位价格很高，一般人也看不出来。 色域这个讲究比较多，有空细写。 色准看 $\\Delta$E，越小越好，一般 2 以内就可以了，但是这个参数是不一定准的，看自己运气，不过一般人看不出色偏。 防蓝光优先硬件级防蓝光。 亮度这个高当然好，但比较看个人需求。我这个显示屏是 350 nit，宿舍里没有阳光直射，开 70% 都绰绰有余。 对比度一般 VA 屏的对比度要高点，如果不打游戏就直接 VA 屏，对比度会比较高，4000:1 以上比较好了。 刷新率这个有点曾经沧海难为水的，如果用过了高刷就回不来了，就算不打游戏，窗口的最大最小化也能看出来高刷很自然而低刷有明显卡顿。如果是办公的话 144 Hz 就行了。 响应时间游戏方面比较需要这个，办公的话就不用太在意。一般选 IPS 屏响应时间会好点，但是 IPS 屏一般漏光会比较严重，意思就是就算放一张全黑的图片显示屏的边缘也会有光，这个是 LED 屏的通病，要么买会烧屏的 OLED，富哥可以考虑 Micro LED。 HDRHDR10 基本负优化，就一个宣传的噱头，只有 OLED 的 HDR400 才有用。 曲率一般大屏曲一点是好的，有环绕感，边上也不会太远。 投影仪总是虽然现在的体验已经相当不错了，但是谁能拒绝巨幕呢？ 分辨率 亮度 对比度 音响2.1 就是左右音箱加一个低音炮，5.1 就是左右音箱加一个中置音箱加一个低音炮加两个环绕音箱，7.1 不是富哥又没需求的话不建议买，因为音源也少，用不着。 影院对比 数字 IMAX头两次都是在金逸影城（深圳光明区大仟里店）看的，基本只顾着看剧情了，所以观影效果基本忘了。第三次在 CINESKY 新天影院（深圳龙华区壹方天地店），只记录这个。体验：第一反应就是银幕很大（但是走近看也不会明显看到像素点，如果《铃芽之旅》是 4K 片源的话那我觉得现在 8K 电视完全就是没必要了），工作人员服务也好，指引招呼都很热情，里面的声学设计也很不错，吸音棉沟壑多，错落有致，总体声场很好。唯一缺点：票有点贵。 二代 IMAX影院：万达影院（深圳龙岗万达广场 IMAX 激光店）体验：去的是早上 10 点的场，检票员都还没来上班，理论上可以随便进，进到里面也没人，算是我包场了，乐。银幕较小，亮度与数字 IMAX 相比看不出有明显区别，12.0 声道，但是天空声道听不出声音，基本可以判断《铃芽之旅》是 5.0 声道片源。 杜比影院影院：万象影城（深圳罗湖万象城店）体验：首先这是我第一次去万象城，非常不适应，全是卖奢侈品的，几乎所有店名都是英文，一家吃的也没，最后实在赶时间，花 38 买了一桶爆米花，纯纯大冤种。影院排场过密，开场前 10 分钟才给进。杜比视界的对比度确实高，黑的地方很黑，银幕边缘基本不会像 IMAX 厅有类似显示屏漏光的现象，亮度对比 IMAX 也稍有提高。但是影院似乎把音量调小了，《铃芽之旅》关门的情节中，上锁的声音最后会有一声极为高频的清鸣，在 IMAX 厅感觉非常明显，但在这个厅没有，感觉就没那么燃，且时不时会传来隔壁影院的低音振动。此外，我坐的位置观影时能看到左右两边有非常亮的安全出口绿光，十分影响观影体验，如果能往前坐一排的话应该不会有这个问题。 总结：2D 电影基本都可以在数字 IMAX 厅或杜比影院看，激光 IMAX 应该只有在 3D 电影才会体现出亮度优势。 浅评《铃芽之旅》第一次比较认真地鉴赏电影，感觉还是挺有意思的。期间也看了很多关于《铃芽之旅》的评论，很多都是不加思考的主观臆断，并不是说电影没有问题，每个人都可以有其对作品的理解和看法，但没有依据地一味批评显得十分无脑，只能说可能是短视频刷多了，遇到需要思考的东西就回避，直接贴上一个“逻辑混乱”的标签掩饰自己的懒惰。在我看来，电影和阅读理解一样，不是一遍就能读透的，赏析时也不能光给观点不给理由。首先我觉得最不合适的就是分类在爱情片里，《铃芽之旅》的爱情线虽然完整，但着笔确实太少，只能说能圆上。对草太的人物刻画也略显单薄。其次这个电影并不是逻辑混乱的，当然也不能说逻辑十分完整。第一遍看的时候我也很懵，但后来越看越合理，许多情节都是伏笔。 铃芽真的是恋爱脑吗？首先我们要知道一个设定，那就是铃芽的母亲是在 311 地震中丧生的，这带给铃芽很大的打击，电影开头里，铃芽梦见她小时候在常世找妈妈，表明铃芽对母亲的逝去始终无法释怀。我认为铃芽一开始带草太回家一方面是因为她跟随母亲当护士的职业操守，一方面自然是好奇。铃芽跟着草太和大臣一起上船也不难理解，椅子是她妈妈留下的遗物，总不能不管吧。 黄蝴蝶的含义是什么？我比较赞同黄蝴蝶是铃芽母亲的说法。如果说前面只是普通的暗示，那么电影结尾铃芽看着小时的自己哭着说“妈妈，我该怎么办”时，黄蝴蝶围着椅子飞，就是新海诚明着说这就是铃芽妈妈了。 东京的要石是被谁拔出的？我的猜测是大臣拔出的。 其他的小细节： 三部曲都有人抽烟，《你的名字》是奥寺，《天气之子》是大叔，《铃芽之旅》是芹泽。 游乐场的往门能进去。 千果为了搭铃芽去废弃的学校，橙子都没带上车。 铃芽房间里的《看护师》给了两次镜头，第一次是草太到房间里的时候，第二次是结尾，表明铃芽也继承了母亲的职业。 草太坠落时的背景是燃烧的常世。","link":"/2023/04/19/%E5%AE%BF%E8%88%8D%E5%BD%B1%E9%99%A2%E6%90%AD%E5%BB%BA%20&%20%E4%BA%94%E5%88%B7%E3%80%8A%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85%E3%80%8B%E5%90%8E%E7%9A%84%E6%B5%85%E8%AF%84/"},{"title":"密码学论文记","text":"记录一下读的 Papers 常见词汇devise 发明permutation 置换reciprocal 倒数cardinality 基数corollary 推论canonica 规范的symmetric 对称的determinant 行列式regarding 关于map 映射projection 投影coordinate 坐标denote 标示rational 有理的thus 因此alternatively 或者optimize 优化anew 重新tedious 乏味的non-trivial 不平凡的derive 得到hence 因此composite number 合数or else 否则scenario 方案implicit 隐式的analogous 相似的asymptotical 渐进的sake 目的notation 符号 文章汇总1. Cryptanalysis of Unbalanced RSA with Small CRT-Exponent第一篇正经详细读的论文，作者 Alexander May 挺 nb 的，多元 coppersmith 也是他和另一个人写的，有机会也读一下。这篇 paper 主要讲 $p$ 和 $q$ 不平衡时的 RSA 攻击，还要满足 $d_p$ 足够小。具体如下：$$\\beta = q_{bits}/n_{bits} \\\\\\delta = d_{p_{bits}}/n_{bits} \\\\s.t. \\enspace 3\\beta &lt; 1+\\beta^2+2\\delta$$ 2. Modulus Fault Attacks Against RSA-CRT Signatures3. Merkle-Hellman Revisited: A Cryptanalysis of the Qu-Vanstone Cryptosystem Based on Group Factorizations4. A Strategy for Finding Roots of Multivariate Polynomials with New Applications in Attacking RSA Variants","link":"/2022/08/18/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%AE%BA%E6%96%87%E8%AE%B0/"},{"title":"小 CRT 指数非平衡 RSA 的密码分析论文分析","text":"直接读头晕，翻译更看不懂，就写篇文一点点细啃吧。 前言第一次认真看英文论文，也是第一次看论文。这篇是 NSSCTF 中 Crypto 题的出题论文，题目非常简单，但是零解（）后来在 Destog3 迎新赛的压轴题又看到了几乎一样的题，照着 NSSCTF 的 wp 改了下参数中跑出来了，既然在短时间内能碰见两次，也是缘分，就读读罢。 论文翻译引言论文中写到 $ed=1\\mod\\frac{(p-1)(q-1)}{2}$ （这个我没见过），然后 $ \\gcd(p-1,\\frac{q-1}{2})=1$ ，再然后由CRT给出 $ed=1\\mod p-1$ 且 $ed=1\\mod\\frac{q-1}{2}$ 。为了加速 RSA 的解密，有人想用小解密指数 $d$ ，然而 Wiener 先生指出 $d&lt; \\frac{1}{3}N^{\\frac{1}{4}}$ 时可以在多项式时间内爆破出来。虽然不能使用小解密指数 $d$ ，但还有一个方法，就是计算 $d_p=d\\ mod \\ p-1$ 和 $d_q=d\\ mod \\ \\frac{q-1}{2}$ 是比较小的，这样一个 $d$ 称为小CRT指数。为了对消息 $m$ 进行签名，可以计算 $m^{d_p}\\ mod \\ p$ 和 $m^{d_q}\\ mod \\ q$ ，在之前，由于 $d$ 看起来是比较大的，所以也没法攻击（意思应该就是现在可以了）。攻破这个系统的最优的算法的时间复杂度在 $O(min(\\sqrt{d_p},\\sqrt{d_q}))$ ，同时有趣的是， $p$ 和 $q$ 不平衡时往往会降低 RSA 的安全性。令 $q &lt; N^\\beta$ 且 $d_p \\le N^\\delta$ ，当满足 $3\\beta + 2\\delta \\le 1 - log_N(4)$ 时可以在 $O(log^2(N))$ 复杂度内分解 $N$ ，显然，这个方法只能在 $\\beta &lt; \\frac{1}{3}$ 时有效。关键部分来了，这里说到，文章中给出了一种构造任意维度的格的方法来将条件提升到 $3\\beta - \\beta^2 + 2\\delta \\le 1 - \\epsilon$ ，这个 $\\epsilon$ 是一个小错误的意思（我也不知道干嘛的）。因此只要 $\\beta &lt; \\frac{3-\\sqrt{5}}{2}=\\hat{\\phi}^2$ ，这个方法就是有效的，当 $\\hat{\\phi}$ 时是黄金比例的共轭（这一段我又不知道在干嘛了）。 准备工作记模 $N$ 环为 $\\mathbb {Z}_N$ ，整数模 $N$ 乘法群为 $\\mathbb{Z}^*_N$ 真相1（原文就叫Fact 1，随便翻译意思一下）$(Lenstra, Lenstra and Lov´asz)$令 $L$ 为一个由 ${v_1,…,v_n}$ 张成的格，那么 $L^3-reduction$ 算法可以在多项式时间内输出一个以 ${v_1^\\prime,…,v_n^\\prime}$ 为基的格且这组基满足$$ |v_1^\\prime| \\le 2^{\\frac{n-1}{4}} \\ det(L)^\\frac{1}{n} \\ and \\ |v_2^\\prime| \\le 2^{\\frac{n}{2}} \\ det(L)^\\frac{1}{n-1}$$ 用 CRT 生成 Key一个模 $p$ 的方法同余式改写等式过程如下：$$ ed_p=1 \\ mod \\ p-1 \\\\ ed_p+k(p-1)=1 \\ over \\ \\mathbb{Z} \\\\ ed_p-(k+1)=-kp$$下面假设 $q$ 不整除 $k$ ，否则右式是 $N$ 的倍数然后我们可以获得更强的结果（又是奇怪的翻译），等下再讨论这个。此时有多项式$$ f_p(x,y)=ex-y$$且该多项式有一根 $(x_0,y_0)=(d_p,k+1) \\ modulo \\ p$构造时我们有 $d_p \\le N^\\delta$ ，又 $e &lt; \\frac{(p-1)(q-1)}{2}$ ，就有$$ \\lvert k+1\\rvert=\\lvert \\frac{ed_p-2}{p-1}\\rvert &lt; \\frac{ed_p}{p-1} &lt; \\frac{q-1}{2}d_p &lt; N^{\\beta + \\delta}$$定义两个上界 $X=N^\\delta$ 和 $Y=N^{\\beta + \\delta}$ ，则模二元多项式方程 $f_p$ 有一个小根 $(x_0),y_0$ 满足 $\\lvert x_0 \\rvert \\le X$ 且 $\\lvert y_0 \\rvert \\le Y$ ，这个模方程可以用 Howgrave_Grahm 定理转变为一个整数上的方程。 真相2 $(Howgrave-Graham)$令 $f(x,y)$ 为一个至多 $\\omega$ 个单项式的和的多项式，假定 $f(x_0,y_0)=0\\mod \\ p^m$ ( $m$ 为正整数)， $\\lvert x_0 \\rvert \\le X$ 且 $\\lvert y_0 \\rvert \\le Y$ 。若 $|f(xX,yY)| &lt; \\frac{p^m}{\\sqrt{\\omega}}$ ，则 $f(x_0,y_0)=0$ 在整数上成立。 用格约化算法可以找到一个小欧里几得范数的多项式 $f(xX,yY)$ ，第一个方法是构造一个二维的格，这时高斯约化算法可以找到一个最短向量。我们选择 $m=1$ ，然后我们使用同样含根 $x_0 \\ modulo \\ p$ 的辅助多项式 $f_0(x)=Nx$ ，因为 $N$ 是 $p$ 的倍数。因此， $f_0$ 和 $f_p$ 的每个整数线性组合都有根 $(x_0,y_0) \\ modulo \\ p$ 。此时构造一个由多项式 $f_0(xX)$ 和 $f_p(xX,yY)$ 的系数向量张成的格 $L_p$ 。这些系数向量是如下 $(2x2)$ 格基矩阵 $B_p$ 的行向量$$B_p=\\begin{bmatrix} NX \\\\ eX &amp; -Y\\end{bmatrix}$$然后找到一个向量 $v$ 使其欧里几得范数小于 $\\frac{p}{\\sqrt{2}}$ ，这个向量可以被转换成一个满足真相2的多项式 $f(x,y)$ 。 引理3 令 $X=N^\\delta$ 和 $Y=N^{\\beta + \\delta}$ 满足$$ 3\\beta + 2\\delta \\le 1 - log_N(4)$$则 $L_p$ 有一个最小向量 $v$ 满足 $|v|&lt;\\frac{p}{\\sqrt{2}}$证明 由 Minkowski 定理，…呃先不说这个，能用就行（逃 通过引理3，我们知道，对每个固定的 $\\epsilon &gt; 0$ ，条件 $3\\beta + 2\\delta \\le 1 - \\epsilon$ 有适当的模量 $N$ （这里我感觉不应该是这么翻译，后面再改）。假定我们通过格约化找到了一个 $L_p$ 中的向量 $v$ ，其范数小于 $\\frac{p}{\\sqrt{2}}$ ，令 $v$ 为多项式 $f(xX,yY)$ 的系数向量，应用真相2，我们知道 $f(x,y)$ 在整数上有一根 $(x_0,y_0)=(d_p,k+1)$ ，下一个定理将表明这个根可以很容易被找到。 引理4 令 $v=(c_0,c_1)\\cdot B_p$ 为 $L_p$ 的最短向量且满足 $|v|&lt;\\frac{p}{\\sqrt{2}}$ 则 $\\lvert c_0 \\rvert = k$ 且 $\\lvert c_1 \\rvert = qd_p$证明 略 总结如下结论就有如下定理： 定理5 给定一个 RSA 公钥对 $(N,e)$ ，令 $q&lt;N^\\beta,d_p \\le N^\\delta$ 且$$ 3\\beta + 2\\delta \\le 1 - log_N(4)$$则 $N$ 可以在时间 $O(log^2(N))$ 内被分解。证明 还是略（ 在之前的分析中，我们假设 $q$ 不整除 $k$ ，特殊情况下若 $k=qr$ ( $r \\in \\mathbb{Z}$ )，我们得到了类似于以下更强结果之前的推理（百度翻译的） 定理6 给定一个RSA公钥对$(N,e)$，令$q&lt;N^\\beta,d_p \\le N^\\delta$且$$ k=qr \\ and \\ 3\\beta + 2\\delta \\le 1 - log_N(4)$$则 $N$ 可以在时间 $O(log^2(N))$ 内被分解。证明 又双叒叕是略（ 有趣的是，在定理 6 中选择 $\\beta=\\frac{1}{2}$ 会有一个界 $\\delta \\le \\frac{1}{4}-log_N(4)$ ，这与 Wiener 的界差不多。 将界提升到 $\\beta &lt; N^{0.382}$这里将界提升到 $\\beta &lt; \\frac{3-\\sqrt{5}}{2} \\approx N^{0.382}$ 。上面我们使用真相2的时候选择 $m=1$ ，现在一般化方法到任意 $m$ 。定义 $x$ 移位多项式（这个也是百度翻译）$$ g_{m,i,j}(x,y)=N^{max(0,m-j)}x^if^j_p(x,y)$$注意到，每个多项式 $g_{m,i,j}$ 的线性组合都有零点 $(x_0,y_0)=(d_p,k+1)\\ modulo \\ p^m$ 。确定一个格维数 $n$ ，然后用 $g_{m,i,j}(xX,yY)$ 的系数向量来构造一个 $n$ 维格 $L_p$ ，其中 $j=0…n-1$ ， $i=n-j-i$ 。参数 $m$ 是 $n$ 的函数且须进行优化。比如选取 $n=4$ ， $m=2$ ，格 $L_p$ 由如下行向量张成$$B_p=\\begin{bmatrix} N^2X^3 \\\\ eNX^3 &amp; -NX^2Y \\\\ e^2X^3 &amp; -2eX^2Y &amp; XY^2 \\\\ e^3X^3 &amp; -3e^2X^2Y &amp; 3eXY^2 &amp; -Y^3\\end{bmatrix}$$注意到，之前的 $L_p$ 和这里的 $L_p(2)$ 是一样的。为了满足真相2，我们一个满足范数小于 $\\frac{p^m}{\\sqrt{n}}$ 系数向量 $v$ ，如下引理给出了一个找这样一个向量的条件 引理7 对每个确定的 $\\epsilon&gt;0$ ，令 $X=\\frac{n+1}{2}N^\\delta$ ， $Y=\\frac{n+1}{2}N^{\\beta+\\delta}$ 满足$$ 3\\beta - \\beta^2 + 2\\delta \\le 1 - \\epsilon$$然后用 LLL 算法可以在 $L_p(n)$ 中找到一个向量 $v$ 满足范数小于 $\\frac{p^m}{\\sqrt{n}}$ 。证明 略（ 现在我们可以用上面的引理7与真相2结合来构造一个次数为$n$的双变量多项式 $f(x,y)$ ，该多项式最多由 $n$ 个单项式组成，有一根 $(x_0,y_0)$ ，现在问题来到如何提取根 $(x_0,y_0)$ 。与引理4类似，等下写这 引理8 令 $X=\\frac{n+1}{2}N^\\delta$ ， $Y=\\frac{n+1}{2}N^{\\beta+\\delta}$ ，多项式 $f_p(x,y)=ex-y$ 有一根 $(x_0,y_0)\\ modulo \\ p$ 满足 $\\lvert x_0 \\rvert \\le N^\\delta$ ， $\\lvert y_0 \\rvert \\le N^{\\beta +\\delta}$ ，令 $v$ 为 $L_p(n)$ 中范数小于 $\\frac{p^m}{\\sqrt{n}}$ 的向量（ $v$ 为项式 $f(xX,yY)$ 的系数向量），然后多项式 $p(x,y)=y_0x-x_0y \\in \\mathbb{Z}$ 一定整除 $f(x,y)$ ，我们就可以通过在 $\\mathbb{Z}[x,y]$ 上分解 $f$ 找到 $p$ 。证明 略（ 总结这些结论，就有如下定理： 定理9 给定一个 RSA 公钥对 $(N,e)$ ，令 $q &lt; N^\\beta,d_p \\le N^\\delta$且$$ 3\\beta - \\beta^2 + 2\\delta \\le 1 - \\epsilon$$其中对于适当大的 $N$ （啥叫适当大）， $\\epsilon&gt;0$ 任意小，则我们可以在 $log(N)$ 确定的时间多项式内分解 $N$ 。证明 略（ 一个模 $e$ 的方法好像没啥用？？？不写了 方法间的比较懒得写了（逃 实现Section31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!sagedef attack(N, e, beta, delta): N = int(N) e = int(e) if 3*beta+2*delta &gt; 1-log(4, N): print('[-] Attack failed') return None else: X = int(pow(N, delta)) Y = int(pow(N, (beta+delta))) Bp = matrix(ZZ, [[N*X, 0], [e*X, -Y]]) print('[+] LLL reduction...') sv = Bp.LLL()[0] c = sv*Bp ^ -1 c1 = -abs(c[0]) # k c2 = abs(c[1]) # q*dp q = abs((e*c2+c1*N)//(c1+1)) p = N//q print('[+] Attack successed') print('[+] p = {}'.format(p)) print('[+] q = {}'.format(q)) return p, qif __name__ == '__main__': # from random import * # qbits = 900 # pbits = 3138 # dpbits = 66 # print('[+] Generating parameters...') # p = random_prime(2 ^ pbits) # q = random_prime(2 ^ qbits) # dp = random_prime(2 ^ dpbits) # while True: # d = (p - 1) * (randint(1 &lt;&lt; 895, 1 &lt;&lt; 905)) + dp # if GCD(d, (p - 1) * (q - 1)) == 1: # break # e = pow(d, -1, (p - 1) * (q - 1)) # N = p * q # Nbits = int(N).bit_length() # beta = qbits/Nbits # delta = dpbits/Nbits # print('[+] N = {}'.format(N)) # print('[+] e = {}'.format(e)) # print('[+] beta = {}'.format(beta)) # print('[+] delta = {}'.format(delta)) N = 634629908805216799355967956917035397016752766546070169887547308032924761760891699780399214796824214567267154390070522978483366198289411019582748412313710079216359358255867558259121819712947017660972562997658767364245468900343296627500215831311492976020519937654664907394551244233281196085084301881491720946011495516095312100438461444736650645875530160635314476776379821792685906378511085849924665878291761636238890281686290340422138558891124650561389417569572198766305774737557276999432569512459279457704718190818264594575715474945778743504600307881900481338218715405869829242732728780155929040869667117191128487515003629576385308251284254186650906711925117856043812344169291478611645877809590138625462171489233257786403238243625811812424843820945935661305236547254826569192218598933115538295435575896652227458056744204696170806637821332028265957534034435423213071725773547809761130059315592010070432661283749890121832768362711638162670468266766356808625866527581349441814512302739394082651200775637526523353517769267014266507198162521714133402947845712189448974860772495360651769766890958881349140536387282266034095164827944286428551415655867359896643466364963634800962833486281066681776967479689689507887525855059 e = 222449729494346666756992460607761795081627331408633195158207067801306565329147681510898658030387508242070227143765893175513890166451777866451978064721778354202341750518999213529606354327894502393449664534948211789294499720405305147950904692085956769722064799513485397504251091294784655828560748848569365844048162038115977508383792426755701835564072424447439243657439872604411430842404037279822672689499520052597008624952368711035998877339177834448061486065262519442303882787242038252503252910254536179033495248788991658972894666551977962064604651051056420818328840034050064445699641044377207422145434076180424757570241966515333860523020888095363402812210233331161015473008660090443148983742164413532587125663777942637230471840611787651285227528953723973668762432241634488008559578459289516131455221246160389933755148774233018937472092674461794244671504900737970090655485320247064558891268178725955788668940079001559604584196657982775865643371046971752485475409807795707098733502124948500727883742572495725371711913411783312068234668792482799143907403909681456144274826087394298716593721198894233809352032011315411881752188433540351647062223660868815946885574427181940281003433351179379410815810916817304563532735699 beta = 225/1009 delta = 33/2018 attack(N, e, beta, delta)","link":"/2022/05/27/%E5%B0%8F%20CRT%20%E6%8C%87%E6%95%B0%E9%9D%9E%E5%B9%B3%E8%A1%A1%20RSA%20%E7%9A%84%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%BA%E6%96%87%E5%88%86%E6%9E%90/"},{"title":"日常问题小记","text":"记录一下平时遇到的问题和解决方法，以备后用。 无 WSL 运行后 CPU 占用过高 在 User 文件夹下新建一个 .wslconfig 文件，内容如下： 12[wsl2]guiApplications=false","link":"/2023/05/21/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"},{"title":"汇编学习笔记","text":"进行一些笔记的整理 前言上年暑假就学了 x86 汇编的实模式部分，当时用 Onenote 记了一些笔记，后来发现了 Markdown 这个好东西，就决定搬迁一下，也方便我上课查（bushi 格式有待整理（逃 寄存器通用寄存器 寄存器 全称 中文名称 CS Code Segment 代码段寄存器 DS Data Segment 数据段寄存器 ES Extra Segment 附加段寄存器 SS Stack Segment 栈段 SP Stack Pointer 栈指针寄存器 IP Instruction Pointer 指令指针寄存器 SI Source Index 源索引（变址）寄存器 DI Destination Index 目标索引寄存器 AX Accumulator 累加器 BX Base Address Register 基地址寄存器 CX Counter 计数器 DX Data 数据寄存器 标志寄存器 Index 名称 说明 第0位 CF 进位标志，进行算术操作时，如果最高位有向前进位或借位的情况发生，则CF=1，否则CF=0，少数指令除外（如inc和dec） 第2位 PF 奇偶标志，运算结果最低8位，有偶数个为1的比特则PF=1，否则PF=0 第4位 AF 第6位 ZF（Zero Flag） 零标志，当处理器执行一条算数或者逻辑运算指令后，抓住逻辑部件送出的结果除了送到指令中指定位置，还送到一个或非门，如果计算结果为0，ZF被置成1，表示计算结果为零是“真”的，否则清除此位（0） 第7位 SF（Sign Flag） 符号位，如dec计算结果的最高位是比特“0”，SF置“0”，否则置“1” 第8位 TF 第9位 IF 第10位 DF（Direction Flag） 方向标志，可控制movsb和movsw的传送方向 第11位 OF 即溢出标志，用于指示两个有符号数的运算结果是否错误，如果结果正确，则OF=0，否则OF=1 指令mov示例：mov ah,bhmov ax,dxmov [0x02],blmov ax,[0x06]mov ah,0x05mov word [0x1c],0xf000 db（Declare Byte）伪指令，跟在后面的操作数都占一个字节的长度，如果要声明超过一个以上的数据，各个操作数之间必须以逗号隔开 div 用16位的二进制数除以8位的二进制数：被除数必须在寄存器AX中，必须先传送到AX寄存器里，除数可以由8位的通用寄存器或者内存单元提供执行后：商在AL中，余数在AH中 用32位的二进制数除以16位的二进制数：被除数的高16位在DX中，低16位在AX中执行后：商在AX中，余数在DX中 xor0 xor 0 = 00 xor 1 = 11 xor 0 = 11 xor 1 = 0常用于清零 times伪指令，重复后面的指令若干次例：times 100 db 0 movsb和movsw原始数据串的段地址由 DS 指定，偏移地址由 SI 指定，简写为 DS：SI ，目的地址为 ES：DI ，传送的字节数或者字数由 CX 指定，每传送一次， CX 内容减一正向传送时传送操作方向是从内存区域低地址端到高地址端，每传送一个字节或一个字时， SI 和 DI 加 1 或者加 2 ，反向传送则相反 cld和stdcld:将 DF 标志清零，指示传送是正方向的std:与 cld 相反 loop执行时 CX 减一，若 CX 内容不为零，转移到指定的位置执行，否则顺序后面的指令 rep指令前缀，即 repeatCX 不为零则重复 inc和decinc:加一指令，inc bx 和 add bx,1 功能一样，但前者机器码更短，速度更快dec:减一指令，与 inc 格式相同 neg用 0 减去指令中指定的操作数 cbw和cwd两条指令后都没有操作数cbw（Convert Byte to Word）：将 AL 中的有符号数扩展到整个 AXcwd（Convert Word to Double-word）：将 AX 中的有符号数扩展到 DX：AX 中 idivdiv 为无符号除尘指令（Unsigned Divide）idiv 指令格式与 div 相同，专门用于计算有符号数 sub与加法指令 add 类似，但处理器没有减法运算电路，故 sub ah,al 等效neg aladd ah,al cmp功能上和 sub 指令相同，但仅影响相应标志位（CF、OF、SF、ZF、AF和PF），而不保留计算结果，因此不会改变两个操作数的原有内容 or和and or and 0 xor 0 = 0 0 xor 0 = 0 0 xor 1 = 1 0 xor 1 = 0 1 xor 0 = 1 1 xor 0 = 0 1 xor 1 = 1 1 xor 1 = 1 对标志寄存器影响： OF 和 CF 位被清零， SF、ZF、PF 的状态依计算结果而定 push和pop操作数可以是寄存器或者内存单元，逻辑地址为 SS：SP ，不影响任何标志位push：执行时将 SP 内容减去操作数的字长，从高地址端向低地址端推进pop：执行时将 SP 内容加上操作数的字长 in和outin 指令是从端口读，一般形式是in al,dxin ax,dxin 指令的操作数必须是寄存器 AL 或者 AX ，用于访问 8 位或 16 位的端口，源操作数应当是寄存器 DX ， in 指令为 2 字节形式时，后一字节是立即数 out 指令和 in 指令相反两个指令均不影响任何标志位 call、ref和retf指令8086处理器支持四种调用方式 i. 16位相对近调用。近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，故只需得到偏移地址即可，计算过程为：用目标过程的汇编地址减去当前call指令的汇编地址，再减去当前call指令以字节为单位的长度(3)，保留16位的结果，近调用的特征是在指令中使用关键字”near”，若没有提供任何关键字，则编译器认为该指令是近调用，其机器指令操作数是一个16位的有符号数，被调用过程的首地址必须位于距离当前call指令-32768~32767字节的地方 ii. 16位间接绝对近调用。这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址，该偏移地址不直接出现在指令中，而是由16位的通用寄存器或者16位的内存单元间接提供，机器指令的操作是16位的绝对地址，故可以调用当前代码段任何位置处的过程 iii. 16位直接绝对远调用。这种调用属于段间调用，即调用另一个代码段的过程，”16位”是针对偏移地址来说的，而不是限定段地址，”直接”的意思，段地接和偏移地址直接在call指令中给出，先后将CS和IP进行压栈和出栈 iv. 16位间接绝对远调用。同样属于段间调用，”16位”同样用于限定偏移地址，必须使用关键字”far”，例： proc_1 dw 0x0102,0x2000 call far [proc_1] 0x0102是偏移地址，0x2000是段地址，指令执行时，处理器访问DS指向的数据段，从指令中指定的偏移地址处取得两个字（段地址0x2000和偏移地址0x0102），再将CS和IP分别压栈和取代ref是近返回指令，从栈中弹出一个字到IP中retf是远返回指令，分别从栈中弹出两个字到IP和CS中 shr、shl、ror、rolshr（Shift logical Right），即逻辑右移指令，将AX中的内容右移4位，执行时将操作数连续右移指定次数，每次溢出的比特被移到CF位，空出的位置用“0”填充，目的操作数可以是8位或16位通用寄存器/内存单元，源操作数可以是1或8位立即数或寄存器CL，当使用CL时，对于目的操作数是内存地址的情况，须使用关键字byte或word等来加限定，如： shr al,cl shr byte [bx],clror（Rotate Right），即循环右移指令，执行时每右移一次，移出的比特既送到CF位，也送进左边空出的位 jmp若JMP之后是标号，则编译为相对转移指令0xE9，操作数为相对偏移题，执行时IP+操作数+长度，此时为相对近转移8086处理器的无条件转移指令（“16位”意为要转移到的目标位置的偏移地址是16位的） 相对短转移。操作码为0xEB，操作数是相对于目标位置的偏移量，仅1字节，且为有符号数，故该指令属于段内转移指令，且只允许转移到距离当前-128~127字节的地方，该指令须使用关键字“short”，例： jmp shor infinite 16位相对近转移。转移范围较相对短转移稍大，操作码为0xE9，操作数为2字节，属于段内转移，可转移到距当前指令-32768~32767字节的地方，该指令应使用关键字“near” 16位间接绝对近转移。转移到的目标偏移地址不是在指令中直接给出，而是用一个16位的通用寄存器或者内存地址间接给出，关键字“near“可以省略，例： jmp near bx jmp near cx jump_dest dw 0xc000 jmp [jump_dest] jmp [bx] 16位直接绝对远转移。在指令中直接给出段地址和偏移地址的转移指令，例： jmp 0x0000:0x7c00 16位间接绝对远转移。该指令要使用关键字”far”，例： jump_far dw 0x33c0,0xf000 jmp far [jump_far] resb（REServe Byte）、resw和resd指令resb:从当前位置开始，保留指定数量的字节，但不进行初始化 mul可以用8位的通用寄存器或者内存单元中的数和寄存器AL中的内容相乘，结果是16位，在AX寄存器中，也可以用16位的通用寄存器或者内存单元中的数和寄存器AX中的内容相乘，结果是32位，高16位和低16位分别在DX和AX中，指令执行后，若结果的高一半全为0，则OF和CF清零，否则置1 参考《x86汇编语言——从实模式到保护模式》——李忠 著","link":"/2022/04/06/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"灯，等灯等灯","text":"线性同余方程组与格基约化问题 前言 没有听到吗？在耳边回荡着的钟声。 传闻中，远古文明能够捕猎闪电，将其封印在蜿蜒曲折的法阵中，用以驱动炼金术的最高成就——机械之心。 而在诸多机械之心的流派里，蔚蓝是曾经的王者。无信者窃取神明的奇迹，沉湎于蔚蓝创造出来的虚幻之间，得以逃避残酷的现实。 只是，火已渐熄，位不见王影。那一抹纯净的蔚蓝也逐渐染上铜锈和铁锈的颜色。破落的圣殿中只剩无名的巡礼者，还在追寻当年先知摩尔留下的足迹。 此时才明白，那则预言的含义：火焰熄灭之时，钟声响起，余灰纷沓而来，解开沉寂千年的机关，点亮传承的图腾。无火的余灰不能成为柴薪，可也许正因这样，才会如此向往光明吧。 还没有听到吗？那回荡在耳边的，古老而熟悉的，钟声—— 灯，等灯等灯 以上是 Hackergame 2021 的一道点灯题的题文。 解这题的时候连线代都不会，拿到神的题解也跑不起来，后来才知道 Sagemath 要另行安装， pip install sage 是无用的。前些天在单人豪华房里坐了几天牢，趁机也入门了一下格密码，隐约联想到这道题有点类似 CVP 的感觉，而再回头看神的题解果真也是这个思路，如今便借着学习一下 Python 和格。考虑到读者水平可能与我相近，故以下的分析我尽可能做到详细，几乎每一步都有分析，相应的，文章篇幅也会比较长。如果能认真读完并理解，相信会有不小的收获。 题目链接http://202.38.93.111:12768/login?token=1:MEQCIBY0ubN3BOXYsuRdXzqWIWNf8Jx0Y6giZCSp/Rg8zdNwAiBMZGWaiIGLD33KTfQ5TTLejp9PwGp8Gg4HsJbdo8sVig==如果还没关的话应该能打开（） 好吧已经 Hackergame 2022 了，关了。 灯 by mcfx详解注：此题共 3 关，为 Level0 、 Level1 及 Level2 ，由于 Level1 综合了三关的解法，故以下均以 Level1 为例。 准备数据及函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from sage.all import *import sys, requeststarget = [ [189, 189, 189, 189, 189, 33, 33, 33, 189, 189, 189, 189], [189, 189, 189, 33, 33, 33, 189, 33, 44, 189, 189, 189], [189, 189, 189, 189, 189, 33, 33, 33, 33, 189, 189, 189], [189, 189, 189, 189, 189, 33, 189, 33, 33, 189, 189, 189], [189, 189, 189, 33, 33, 189, 189, 33, 33, 33, 189, 189], [189, 134, 33, 33, 189, 189, 189, 189, 33, 33, 189, 189], [189, 144, 33, 33, 189, 189, 189, 189, 33, 189, 189, 189], [189, 142, 33, 33, 189, 189, 189, 189, 33, 33, 33, 189], [189, 100, 142, 33, 189, 189, 189, 189, 33, 33, 33, 189], [189, 142, 142, 189, 189, 189, 189, 189, 189, 33, 189, 189], [189, 59, 142, 33, 189, 189, 189, 189, 33, 189, 189, 189], [189, 189, 33, 33, 189, 189, 189, 189, 189, 189, 189, 189],]def level01_val(i, j, x, y): if (x == i or y == j): return 3 - (abs(x - i) + abs(y - j)) return 0def level2_val(i, j, x, y): return [31, 63, 127][max(abs(x - i), abs(y - j))]levels = [ (level01_val, '''................................................................................................................................................'''), (level01_val, '''..........................X.X.........XXX.........X.X..........................XXX.........X...........X.X.........XXX..........................'''), (level2_val, '''..........................X.X...XX....X.X...X.....XXX..XX.............................XXX..XXX.....X...X.......X...XXX..........................''')]def id(x, y): return x * 12 + ylevel_id = int(sys.argv[1])ban = list(map(lambda x: [y == 'X'for y in x], levels[level_id][1].split())) from sage.all import *首先要安装 Sagemath，因为 Sagemath 在 Windows 下运行也是要虚拟出一个 Unix 环境，故建议在 WSL 里 sudo apt install sagemath ，可能中途要 apt-get upgrade 。 sys.argv[1]argv[0] 是脚本名称（它是否为完整路径名取决于操作系统）。则 argv[1] 为省去后缀名的文件名，如 Level0 时为脚本名为 0.py ， argv[1] 为 0 。 ban = list(map(lambda x: [y == 'X'for y in x], levels[level_id][1].split()))lambda 是 Python 的一个关键字，可以用来定义匿名函数。所谓匿名函数，就是没有名字的函数，与命名函数类似，都有参数和返回值，只是没有名字。如 add=lambda x, y: x+y 这个函数就将传入的两个参数相加，返回结果，即 add(1, 2) 等于 1+2 ； map(lambda x: x+1, [1, 2, 3]) 将列表 [1, 2, 3] 中的元素分别加 1 ，其结果 [2, 3, 4] 。这里 map(lambda x: [y == 'X'for y in x], levels[level_id][1].split()) 一句是将上面定义的 12 阶方阵中 X 转为 True ， . 转为 False ，然后放入一个列表 ban 中，此时 ban 为两级列表。 准备矩阵系数 12345678910111213m = []free = []for i in range(12): for j in range(12): if ban[i][j]: continue free.append((i, j)) t = [0] * 144 for x in range(i - 2, i + 3): for y in range(j - 2, j + 3): if (0 &lt;= x &lt; 12) and (0 &lt;= y &lt; 12): t[id(x, y)] = levels[level_id][0](i, j, x, y) m.append(t + [0]) levels[level_id][0](i, j, x, y)这里是在元组里放函数，注意到上面的 Levels=[(levev01_val, '''...'''),(...),(...)] ，所以 levels[level_id][0] 是 levev01_val 函数。这样的用法如： 1234def add(x,y):return x+ytup=(add,1,2)print(tup[0](tup[1],tup[2]))# 3 list也可以实现类似操作，Python确实花.jpg。 不难发现， free[] 里放的是可以点的坐标，如 $(0,0),(0,1)…$ 注意到， level01_val 函数在上面已经定义： 1234def level01_val(i, j, x, y):if (x == i or y == j): return 3 - (abs(x - i) + abs(y - j))return 0 这个函数的参数中 i,j 为操作的点(即按下的点)坐标， x,y 为受影响的点坐标，返回值为受影响坐标的增量。 如 (i,j) 为 $(2,3)$ 时，若 x,y 为 $(2,3)$ ，则根据规则，返回值为 3 ，若 x,y 为 $(2,4)$ ，则返回值为 2 ，若 x,y 为 $(3,3)$ ，则返回值为 2 ，若 x,y 为 $(3,4)$ ，则返回值为 0 。如下表： x\\y\\返回值 2 3 4 1 0 2 0 2 2 3 2 3 0 2 0 12345for x in range(i - 2, i + 3): for y in range(j - 2, j + 3): if (0 &lt;= x &lt; 12) and (0 &lt;= y &lt; 12): t[id(x, y)] = levels[level_id][0](i, j, x, y)m.append(t + [0]) 上面已经定义函数 def id(x, y): return x * 12 + y ，即 id 函数把给定的坐标转为方阵一维展开后的位置，则此处把每个操作点对整个方阵 144 个位置影响(增量)后面补一个 0 （下面会解释为什么加一个 0 ）放入 t[] 中，此时t可以看作一个向量。 每个 t[] 补入 m[] 后，此时 $m$ 是一个 (144-16)x(144+1) 即 128x145 的矩阵，且第 145 列全为 0 ( 16 为 X 即不可操作点的数量)，如下： $$ m=\\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 2 &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{pmatrix} $$ 注意：上面打省略号的地方不全为0！ 比如第一行是由如下一个 12x12 的矩阵展开为一维形式： $$ \\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{pmatrix} $$ 123456789for i in range(144): m.append([(i == j) * 256 for j in range(144)] + [0])t = []for i in range(12): for j in range(12): t.append(target[i][j])C = 256m.append([-x for x in t] + [C]) 不难看出，此时的 $m$ 为如下形式： $$ m=\\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 2 &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; 0\\\\ 256 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 256 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 256 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 256 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 256 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 256 &amp; 0 \\\\ -189 &amp; -189 &amp; -189 &amp; -189 &amp; -189 &amp; \\cdots &amp; -189 &amp; 256\\\\ \\end{pmatrix} $$ 此时矩阵 $m$ 的前272个行向量(即除开最后一个行向量)的整系数线性组合即为操作后可以得到的方阵化为一维后的向量， Level0 时只需令该向量与解向量相等，而 Level1 和 Level2 则需要算出离解向量最近的可由这 272 个向量整数系线性表出的向量作为新的解向量，因为我们不保证在一些点不可操作的前提下仍能整数系线性表出解向量(重点，敲黑板) 。 同时由于题目在模意义下进行，所以若解出的系数为负整数也可以模 256 化为正整数。 而 $m$ 的最后一个行向量为负的解向量，这里留给后面解释。 1234n = len(m)print('pre ok')m2 = Matrix(m).LLL()print('lll ok') 这里 n 取得 m 的行向量数，即 (144-16+144+1)=273 ，然后对 m 跑 LLL 算法进行格基规约，仍然得到一个 273x145 的矩阵。 我最常用的求 CVP 的近似解的办法是，给原来每个向量后面加个 0，然后再加个新向量，前面的位置是欲求 CVP 的向量，最后是一个很大的常数。给这个新的格跑一遍 LLL，结果中最后是大常数的那一行，就是我们想要的答案。—— mcfx 这就是为什么最后要补一列零向量的原因。 同时上面有一个细节，那就是 $m$ 的最后一个行向量为负的解向量，结合神的解释，我发现，若矩阵中最后一个行向量的最后一个维度为大常数，其他行向量的最后一个维度为 0 ，那么 LLL 后最后这个行向量只是与其他行向量的线性组合进行一次相加(或相减)，也就是说，这个方法将 CVP 化为 SVP 问题时，求解 SVP 的过程中不会对这个特殊行向量进行任何数乘！ 那么将这个向量直接乘上-1然后加上原来的解向量再抹去最后一维就是CVP的解了。 同时我观察了 m2 (即 m.LLL 后的结果)的特征，发现 273 个行向量中的 128 个均为零向量，恰为 273-145 个。这里有一个有趣的问题，那就是这 273 组基是否可以互相线性表出。 在线性代数中，一般的，我们在欧几里得空间即实数域里讨论向量的实数系组合问题，此时 145 维向量空间里的每个向量都可以由 145 个线性无关的向量线性表出。而格中是在向量的整数系组合下讨论问题，此时情况就有所不同了，比如以 $(1,1)$ 和 $(-1,1)$ 为基张成的格并不包括 $(1,0)$ 等向量，即不存在整数 $m,n$ 满足 $m*(1,1)+n*(-1,1)=(1,0)$ 。 找到 CVP 的答案 123456for i in range(n): if m2[i][144]: for j in range(144): m[-1][j] = m2[i][j] - m[-1][j] print(sum(abs(m2[i][j]) for j in range(144))) break 由上面分析可知，此时 m[-1] 的前 144 维就是新的解向量。至此， Level1 和 Level2 就可以化为 Level0 的解法了。 跑高斯消元求解 1234567s = []for i in range(144): t = [] for j in range(len(free)): t.append(m[j][i]) t.append(m[-1][i] % 256) s.append(t) 上面知道 free[] 是可以操作的点的坐标列表，故 len(free[]) 即为 144-16=128 。 这里取 $m$ 的前 (144-16)=128 个行向量的前 144 维进行转置作为系数矩阵与 $m$ 的最后一行向量的前 144 维变为列向量，合成增广矩阵，即为一个标准的非齐次线性方程组，即 $s$ 为一个如下的 144x145 的矩阵： $$ s=\\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 189\\\\ 2 &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 190\\\\ 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; \\cdots &amp; 0 &amp; 191\\\\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; \\cdots &amp; 0 &amp; 189\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; 189 \\end{pmatrix} $$ 12345678for i in range(len(free)): for j in range(i + 1, 144): while s[j][i]: t = s[i][i] // s[j][i] for k in range(len(free) + 1): s[i][k], s[j][k] = s[j][k], (s[i][k] - s[j][k] * t) % 256for i in range(len(free), 144): assert s[i][len(free)] == 0 经以上消元后 $s$ 的第 129 行到最后一行均为 0 ，且系数矩阵与增广矩阵等秩，方程组有唯一解， $s$ 为如下的上三角矩阵： $$ s=\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 188\\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 188\\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 189\\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 189\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; 190\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 127 \\end{pmatrix} $$ 12345678ans = [0] * len(free)for i in range(len(free) - 1, -1, -1): t = s[i][len(free)] for j in range(i + 1, len(free)): t = (t - ans[j] * s[i][j]) % 256 for j in range(256): if j * s[i][i] % 256 == t: ans[i] = j 提交答案 12345678910111213sol = [[0] * 12 for _ in range(12)]for i, (x, y) in enumerate(free): sol[x][y] = ans[i]print(sol)data = { 'level': level_id, 'solution': str(sol),}headers = {'Cookie': 'xxx'}r = requests.post('http://202.38.93.111:12768/submit', headers=headers, data=data)print(r.text) 遇到的一些问题 Latex 矩阵无法正常显示 有少少离奇，这个博客主题要在矩阵的每行结尾加四个反斜杠才能正常换行，否则就挤作一行。 参考 https://mcfx.us/posts/2021-10-30-hackergame-2021-writeup/ https://docs.python.org/3/library/sys.html https://zhuanlan.zhihu.com/p/67978661","link":"/2022/03/31/%E7%81%AF%EF%BC%8C%E7%AD%89%E7%81%AF%E7%AD%89%E7%81%AF/"},{"title":"群","text":"有人问一个小女孩，3+4 等于几啊？小女孩说：“不知道，但我知道 3+4 等于 4+3 .”这人只好接着问：“为什么呀？”小女孩答道：“因为整数与整数加法构成了阿贝尔群。” 前言虽然之前大概也能 get 到笑点，但只觉得阿贝尔群是个高深的概念，也没有细究。后来我接触到密码学，然后就开始学习近世代数，才知道了阿贝尔群就是交换群（即群上的代数运算满足交换律）。一开始是在 B 站看的视频，后来发现那个系列是纯数学的，不大适合我，于是转回来看一本叫《近世代数及其应用》的书，正式开始记下笔记。 思来想去，我还是把之前写的一堆定义公式删了，那些个符号我当时不想看，现在也不想写，就试着科普向一点吧，毕竟我写文章也不是为了自娱自乐。 群的定义群，一个概念，也并非什么高深的东西，就是一个集合和集合上的运算，注意这个集合上的，已经包含了封闭律的意思，所谓封闭律，就是集合上的两个元素的运算结果还在这个集合，比如整数的加法和乘法，而整数的除法就不是了。而在这里的运算已经是一种泛义的说法，包括但不限于加法、乘法、除法、求余等等，甚于我定义出来的运算也是一种运算。在群中的运算一般用$\\circ$或$\\cdot$表示，有时也姑且称之为乘，但注意大多时不是指数的乘法。同时，群还满足结合律，存在单位元和逆元。 结合律不必多说，就是括号随便加，而单位元的意思就是，集合中任意元素与这个单位元运算后还是本身，比如任意整数加 0 都不变，那么 0 就是整数加群中的单位元，同理1是有理乘法群中的单位元。而逆元同样是针对集合上每个元素，性质就是任意元素与其逆元作运算后都等于单位元，比如整数加群中，1 的逆元是 -1，10086 的逆元是 -10086 ；有理乘法群中，1 的逆元还是 1 ，10086 的逆元是 1/10086 。注意到，对于整数和数的乘法而言，10086 并没有逆元，故整数和数的乘法不作成群。 插播一下：混进一个抽代群时有一个进群验证，题目是给出 A5 的全部正规子群，而我甚至连 A5 是啥都不知道，but 我有sagemath，嘿嘿，直接跑出单位元和 A5 本身，我又试了几下，发现只有 A4 除开单位元和自身外有其他正规子群，非常奇妙。代码如下： 1234567891011#!sagex=5Ax = AlternatingGroup(x)for i in Ax.conjugacy_classes_subgroups(): if i.is_normal(Ax): if(i==Ax): print('Ax') else: print(i) for j in i.list(): print(j)","link":"/2022/03/08/%E7%BE%A4/"},{"title":"记一次在局域网搭网站","text":"在学校里用自己电脑( Windows10 环境)当服务器搭了个网站，仅可在校园网下访问，图一乐。 基础安装 flask 框架Flask 是一个好用且简单的 web 框架，更多操作可以参考 Flask官网。pip install flask当然前提得先装好 python ，不提。在 VSCode 下可以直接用 Code runner 运行下面代码。 1234567891011from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'Hello World!'if __name__ == '__main__': app.run( host='0.0.0.0', # 加了这个参数局域网内部才可以通过本机ip访问 port=5000, # 端口也可以设成80，访问的时候不用加端口号 debug=True, # 开启调试模式，可以实时监控代码更改 ) 这样，一个基础的网页就搭建好了，在同一个局域网用浏览器访问 http://&lt;你电脑的内网IP&gt;:5000 就能看到 Hello World! 了。但是我在连着无线网的笔记本部署却不能访问，也 ping 不通笔记本的 ip ，其中原因有待细究。 更新：无线网无法访问是因为学校防挖矿病毒，把低端口封了。 进阶Nginx有域名的可以下个 Nginx 玩，体验感高很多(bushi)。Nginx 下载地址 http://nginx.org/en/download.html建议下载稳定版的，即 Stable version 。下载后直接解压即可，不要双击 Nginx.exe。用终端打开 Nginx 的目录，然后使用命令 start nginx 运行。以下是一些 Nginx 的常用命令：( Windows 下没有添加环境变量的情况下 nginx 需要换成 ./nginx xxx ) 1234nginx -s reload # 重载配置文件，更改配置文件后记得重载nginx -s reopen # 重启Nginxnginx -s stop # 强行停止Nginxnginx -s quit # 正常退出Nginx 有个小坑就是有时不一定能通过上面的两个命令停止 Nginx ，这时在任务管理器是能看见 Nginx 的进程还在的，需要手动杀掉，否则可能无法正常重载配置文件(即 config 文件)。同时觉得用命令行太麻烦了，就写了个 Python 的脚本配合 Flask 操作，如下： 1234567891011121314151617181920212223242526272829303132333435363738from subprocess import Popen, PIPEimport psutilimport osclass Nginx: def __init__(self, path): self.path = path # Nginx的目录(绝对路径) def start(self): obj = Popen(&quot;start nginx&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) def quit(self): obj = Popen(&quot;nginx -s quit&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) out_info, out_error = obj.communicate() return (out_info, out_error) def reload(self): obj = Popen(&quot;nginx -s reload&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) out_info, out_error = obj.communicate() return (out_info, out_error) def restart(self): obj = Popen(&quot;nginx -s reopen&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) out_info, out_error = obj.communicate() return (out_info, out_error) def killall(self): pids = psutil.pids() for pid in pids: p = psutil.Process(pid) if p.name() == 'nginx.exe': print(pid) p.kill() def status(self): pids = psutil.pids() nginxpid=[] for pid in pids: p = psutil.Process(pid) if p.name() == 'nginx.exe': nginxpid.append(pid) if len(nginxpid)==0: return('Nginx未运行') else: return('%d 个Nginx进程正在运行中' % len(nginxpid)) nginx.conf 文件(即 Nginx 配置文件，位于 Nginx 的 conf 目录下)的 server 配置如下： 1234567server { listen 80; server_name example.com; location / { proxy_pass http://127.0.0.1:5000; } } proxy_pass 后面那个地址必须是本地能访问的，此时我已经将上面python代码中的 host='0.0.0.0' 删掉了。server_name 后面填写域名，记得要先添加 A 记录到局域网 ip ，我为了图方便直接添加了泛域名解析(即 *.example.com )。 SSL证书证书申请由于个人有一丢丢强迫症，看到浏览器 http 的不安全提示总是有点膈应，就想着部署个 SSL 证书解决。然而，其中过程非常麻烦，我最终还是在阿里租的服务器上用宝塔申请了个 Let’s Encrypt 证书(免费的，白嫖永不过时)，然后一开始浏览器竟然显示证书是我那个服务器用的域名，折腾了两下换回去又好了，也是莫名其妙的。 更新：https://letsencrypt.osfipin.com/这个网站似乎不错 一些问题DNS 的验证逻辑非常奇怪，建议添加 TXT 记录后等待10分钟左右再提交验证申请(我就是栽了几次都验证失败，浪费好多时间)。同时我在 Windows 用 Certbot 申请的时候出现了写入权限的错误，也是莫名其妙的，既然日志文件都能写在目录下，证书却写不了。 Nginx配置如下： 1234567891011121314151617181920212223server { listen 80; listen 443 ssl http2; listen [::]:443 ssl http2; server_name example.com; location / { proxy_pass http://127.0.0.1:5000; } # 强制使用 HTTPS，可选 # if ($server_port !~ 443) { # rewrite ^(/.*)$ https://$host$1 permanent; # } ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_certificate 证书文件路径; ssl_certificate_key 私钥文件路径; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on;}","link":"/2022/03/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E6%90%AD%E7%BD%91%E7%AB%99/"},{"title":"高数上笔记","text":"忽然能转了，尝试速成高数上。 前言有空再写。 笔记正文第一章 函数与极限连续函数间断点的分类第二章 微积分的基本概念不定积分积分表 $\\int x^\\alpha\\mathrm dx = \\frac{1}{\\alpha+1}x^{\\alpha+1}+C(\\alpha\\neq-1)$ $\\int\\cos x\\mathrm dx = \\sin x+C$;$\\int\\sin x\\mathrm dx = -\\cos x+C$ $\\int\\sec^2x\\mathrm dx = \\tan x+C$;$\\int\\csc^2x\\mathrm dx = -\\cot x+C$ $\\int\\frac{\\mathrm dx}{1+x^2} = \\arctan x+C$;$\\int\\frac{\\mathrm dx}{\\sqrt{1-x^2}} = \\arcsin x+C$ $\\int\\alpha^x\\mathrm dx = \\frac{1}{\\ln\\alpha}\\alpha^x+C(\\alpha&gt;0,\\alpha\\neq1)$ $\\int\\frac1x\\mathrm dx = \\ln|x|+C$ 第三章 积分的计算及应用第四章 微分中值定理与泰勒公式微分中值定理又称为拉格朗日中值定理：设 $y=f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导，则必存在一点 $c\\in(a,b)$，使得$$f’(c) = \\frac{f(b)-f(a)}{b-a}$$ 例 证明当 $e &lt; a &lt; b &lt; e^2$ 时，$(b-a)\\frac{2}{e^2}&lt;\\ln^2b-\\ln^2a&lt;\\frac4e(b-a)$解 泰勒公式常用 $\\ (x\\rightarrow0)$： $e^x=1+x+\\frac{1}{2!}x^2+\\cdots+\\frac{1}{n!}x^n+o(x^n)$ $\\sin x = x - \\frac{1}{3!}x^3 + \\cdots + (-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!} + o(x^{2n})$ $\\cos x = 1 - \\frac{1}{2!}x^2 + \\cdots + (-1)^n\\frac{x^{2n}}{(2n)!} + o(x^{2n+1})$ $\\ln(1+x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} + \\cdots + (-1)^{n-1}\\frac{x^n}{n} + o(x^n)$ $(1+x)^\\alpha = 1 + \\alpha x + \\frac{\\alpha(\\alpha-1)}{2!}x^2 + \\cdots + \\frac{\\alpha(\\alpha-1)\\cdots(\\alpha-n+1)}{n!}x^n + o(x^n)$ 第五章 向量代数与空间解析几何","link":"/2023/05/05/%E9%AB%98%E6%95%B0%E4%B8%8A%E7%AC%94%E8%AE%B0/"},{"title":"2022巅峰极客 Crypto","text":"有瓜吃，美滋滋。 题目质量一般，知识问答还全是搬运今年 ciscn 的。然后三个队友都没啥空，就我一个做了两道密码，排 88 名，对我这个菜鸡来说也还行吧。 point-power1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import *from random import *from secrets import flagassert len(flag)==42p=getPrime(600)a=bytes_to_long(flag)b=randrange(2,p-1)E=EllipticCurve(GF(p),[a,b])G=E.random_element()x1,y1,_=GG=2*Gx2,y2,_=Gprint(f&quot;p = {p}&quot;)print(f&quot;b = {b}&quot;)print(f&quot;x1 = {x1}&quot;)print(f&quot;x2 = {x2}&quot;)'''p = 3660057339895840489386133099442699911046732928957592389841707990239494988668972633881890332850396642253648817739844121432749159024098337289268574006090698602263783482687565322890623b = 1515231655397326550194746635613443276271228200149130229724363232017068662367771757907474495021697632810542820366098372870766155947779533427141016826904160784021630942035315049381147x1 = 2157670468952062330453195482606118809236127827872293893648601570707609637499023981195730090033076249237356704253400517059411180554022652893726903447990650895219926989469443306189740x2 = 1991876990606943816638852425122739062927245775025232944491452039354255349384430261036766896859410449488871048192397922549895939187691682643754284061389348874990018070631239671589727''' 这题完全是现学现卖，之前只听说过椭圆曲线，然后就跑去学抽代忘记回来了。。。首先查到椭圆曲线的加法（两点相同的情形）：$$x_2=m^2-2x_1\\pmod p \\ with \\ m=\\frac{3x_1^2+a}{2y_1}$$又在 Sagemath 文档查到曲线定义 $y_1^2=x_1^3+ax_1+b$ ，就能联立出一个一元二次方程，exp 如下： 1234567891011121314151617p = 3660057339895840489386133099442699911046732928957592389841707990239494988668972633881890332850396642253648817739844121432749159024098337289268574006090698602263783482687565322890623b = 1515231655397326550194746635613443276271228200149130229724363232017068662367771757907474495021697632810542820366098372870766155947779533427141016826904160784021630942035315049381147x1 = 2157670468952062330453195482606118809236127827872293893648601570707609637499023981195730090033076249237356704253400517059411180554022652893726903447990650895219926989469443306189740x2 = 1991876990606943816638852425122739062927245775025232944491452039354255349384430261036766896859410449488871048192397922549895939187691682643754284061389348874990018070631239671589727K = GF(p)n=(K(x2+2*x1)).sqrt()P.&lt;x&gt;= PolynomialRing(K)A=1B=6*x1**2-4*n**2*x1C=-(4*n**2*x1**3+4*n**2*b-9*x1**4)f=A*x**2+B*x+Croots=f.roots()print(roots)flag=roots[1][0]from Crypto.Util.number import *print(long_to_bytes(int(flag))) strange curve123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from Crypto.Util.number import *from gmpy2 import *from secrets import flagimport randomdef add(P,Q): (x1,y1)=P (x2,y2)=Q x3=(x1+x2)*(1+y1*y2)*invert((1+x1*x2)*(1-y1*y2),p)%p y3=(y1+y2)*(1+x1*x2)*invert((1-x1*x2)*(1+y1*y2),p)%p return (x3,y3)def mul(e,P): Q=(0,0) e=e%p while e: if e&amp;1: Q=add(Q,P) P=add(P,P) e&gt;&gt;=1 return Qdef Legendre(a,p): return (pow((a%p+p)%p,(p-1)//2,p))%pdef get_ts(p): p=p-1 count=0 while p%2==0: count+=1 p=p//2 return count,pdef get_nonre(p): a=random.randint(1,p) while Legendre(a,p)==1: a=random.randint(1,p) return adef amm2(a,p): t,s=get_ts(p) ta=pow(get_nonre(p),s,p) tb=pow(a,s,p) h=1 for i in range(1,t): d=pow(tb,2**t-1-i,p) if d==1: k=0 else: k=1 tb=(tb*pow(ta,2*k,p))%p h=(h*pow(ta,k,p))%p ta=pow(ta,2,p) return h*pow(a,(s+1)//2,p)%p def solve(a,b,c,p): tmpa=1 tmpb=b*inverse(a,p)%p tmpc=c*inverse(a,p)%p assert Legendre(tmpb**2*inverse(4,p)-tmpc,p)==1 res1=(amm2(tmpb**2*inverse(4,p)-tmpc,p)-tmpb*inverse(2,p))%p res2=(-amm2(tmpb**2*inverse(4,p)-tmpc,p)-tmpb*inverse(2,p))%p return (res1,res2)def lift(x,a,b,p): tmp=b*(x**2-1)*inverse(a*x,p)%p return solve(1,-tmp,-1,p)[0]p=9410547699903726871336507117271550134683191140146415131394654141737636910570480327296351841515571767317596027931492843621727002889086193529096531342265353a=54733430689690725746438325219044741824500093621550218736194675295708808435509b=75237024593957256761258687646797952793573177095902495908321724558796076392871x=bytes_to_long(flag)while True: try: y=lift(x,a,b,p) break except: x+=1 continueassert a*x*(y**2-1)%p==b*y*(x**2-1)%pP=(x,y)e=65537eP=mul(e,P)print(f&quot;P = {P}&quot;)print(f&quot;eP = {eP}&quot;)'''P = (56006392793427940134514899557008545913996191831278248640996846111183757392968770895731003245209281149, 5533217632352976155681815016236825302418119286774481415122941272968513081846849158651480192550482691343283818244963282636939305751909505213138032238524899)eP = (mpz(8694229840573103722999959579565187489450818138005222030156495740841851804943200684116883831426548909867463656993852596745698999492932194245562062558787005), mpz(9279986963919197374405152604360936066932975197577643570458423456304679111057526702737279809805694360981565554506626018364382736924914907001214909905449002))''' 这题真的是蚌不住，刚放出来解出数就蹭蹭往上涨，还有点怀疑人生，然后仔细观察题目，一看上面，什么玩意，再看下面，什么玩意。。。直接拿第一个数 long_to_bytes ，得到flag。 Learning with fault1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from Crypto.Util.number import *from gmpy2 import *from secrets import flagimport osclass RSA(): def __init__(self,p,q,e): self.p=p self.q=q self.e=e self.phi=(p-1)*(q-1) self.d=invert(self.e,self.phi) self.dp=self.d%(p-1) self.dq=self.d%(q-1) self.n=p*q self.N=getPrime(512)*getPrime(512) def sign(self,message): m=bytes_to_long(message) sig_p=pow(m,self.dp,self.p) sig_q=pow(m,self.dq,self.q) alpha=q*invert(q,p) beta=p*invert(p,q) return long_to_bytes((alpha*sig_p+beta*sig_q)%self.n) def corrupt_sign(self,message): m=bytes_to_long(message) sig_p=pow(m,self.dp,self.p) sig_q=pow(m,self.dq,self.q) alpha=q*invert(q,p) beta=p*invert(p,q) return long_to_bytes((alpha*sig_p+beta*sig_q)%self.N) def verify(self,message,sign): return long_to_bytes(pow(bytes_to_long(sign),self.e,self.n))==messagep=getPrime(512)q=getPrime(512)e=65537rsa=RSA(p,q,e)with open(&quot;sign.txt&quot;,&quot;w&quot;) as f1: with open(&quot;corrupted_sign.txt&quot;,&quot;w&quot;) as f2: for _ in range(6): message=os.urandom(64) sign=rsa.sign(message) corrupted_sign=rsa.corrupt_sign(message) assert rsa.verify(message,sign) f1.write(str(sign)+'\\n') f2.write(str(corrupted_sign)+'\\n')enc=pow(bytes_to_long(flag),rsa.e,rsa.n)print(f&quot;n = {rsa.n}&quot;)print(f&quot;N = {rsa.N}&quot;)print(f&quot;e = {rsa.e}&quot;)print(f&quot;enc = {enc}&quot;)'''n = 99670316685463632788041383175090257045961799409733877510733415402955763322569510896091638507050126669571444467488936880059210773298729542608112756526719533574432327269721804307073353651955251188547245641771980139488000798458617636759823027148955008149512692983471670488580994385743789385091027299901520585729N = 81332992898551792936282861980393365170738006789835182134055801566584228471896473385776004610279937176800796971820133195300006470892468060034368863410462219133248069442508287516929262751427926825122839525496671527936622212986733708071962237633082743396115729744192159064241674410003857168101669882043743570731e = 65537enc = 2476965183785968993595493003363618829317072815989584886372189393899395623714779397354978469504773556228655475355703015337932838278988328384587983506790841663233499939173166353582189202860394411808445422387063648198432242875738065748287034529713834303346017134249834382745931627301273142828893469374138264396''' 出题论文：https://eprint.iacr.org/2011/388.pdf这题一开始是搜到了论文，瞟了两眼，以为不是，就没看下去了。。。后来学长发给我这篇，我焯了两个钟复现出来了，说不定真有机会现场解出，唉还是太菜。照着论文的 Attack Summary 敲就行了，一开始没理解到 $z$ 向量的意思，直接从格子拿，跑不出来，学长问我 $a$ 和 $b$ 的选取是不是有问题，我才知道要枚举出所有 $x$ 和 $y$ 。然后 $a$ 和 $b$ 在 0 到 10 间选取也不行，改成了 -10 到 10 。exp 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from tqdm import tqdmfrom itertools import combinationsfrom sage.all import *from Crypto.Util.number import *co_sig = [b&quot;\\x17\\x8bb3\\x11\\x1b\\xb9\\xb9\\xc6M\\xb0\\xaa\\x07-\\x1ar\\xff\\xfb\\xb4&amp;H7!\\xb8\\xa1\\xce\\x07\\x8b\\x84M\\x0bw=m\\x193Oc\\x97w\\x8f\\xffy4\\xa1\\x99\\xfcW\\xf9|\\xeb\\xa4\\x00\\x1eD*\\xe8-'\\xa9\\xef\\x9d\\x13*\\xf4\\xbe\\x9d\\x9b&amp;w\\xcb\\xfd\\xb3\\xb6\\xa3n\\xb8\\xb4\\x97vT\\xec@\\x86\\xd1R\\xb0\\n\\xe1uC\\xbc\\x14\\xeb\\xceSu&amp;'{\\xb9\\x12\\x90\\x82\\xc7,\\xdbr\\xebP\\xe1j\\x11E\\xd5\\x17\\xe1\\xd0D\\xe7z\\x94vt\\xbf\\x1a\\xc4+&quot;, b'\\x1dJ\\xc5\\xb2\\xbe\\x05\\xe6\\xc8T\\n\\xbe&quot;\\xbeU\\xed\\xba\\xec\\x85\\x05\\x8b\\x8ayE\\xa3}0\\x1dk\\xa7\\x10\\xe2E\\x19\\xfe\\x10\\x90\\xef\\r\\xdbV\\x8b\\x87|(\\xd1\\xb5\\xfd\\xb9\\x14\\x84\\x05\\x03\\x81\\xc8\\xf6\\xe5\\x8a\\x92\\xa0\\x01I\\x8aG:\\xc19\\x9e\\xf0\\x8eZ\\\\Yx\\x80|\\xb7\\x80\\x0e\\xcd\\xa3\\xba6\\xf8\\x98\\xb1pB\\x05\\x8aT#\\xbf\\x1e\\x1b~\\xcb\\xf5\\t\\xa2H9\\xc9n\\x81e\\xa2\\x15\\x97\\x11\\xe4\\x93\\xf2\\xe6\\x80\\x97\\x99G\\xb5\\xfe\\x07/\\xd2\\xbd\\xad\\xcf\\x04\\x9e\\xd0', b'Gs\\xda\\xb8\\x8a\\x85\\xccK\\xf7\\xa8y\\x16\\xa5\\xf0\\x06\\xbe\\xeb\\x83&amp;}a\\x85q\\x8d:\\x1fSb\\xb8\\xc5\\x84\\xba*[\\xe7\\xbb{\\x86\\xd3\\xb3r\\xb6\\xaaCN\\x93\\x1d&lt;(\\xe2\\x1c;\\x8crU\\x8fD=W\\xa7\\x0b\\xc7\\xeag\\x96\\x06\\xd6\\xbb\\xe4\\x04b\\xd8\\x02\\x12\\xd6\\xfa2\\x1e#\\xf0\\xde\\x8b\\x88M\\xd2\\xf47\\\\\\x98\\xe0\\x04Fu\\x1bsy\\xf2\\xc4\\xad\\xd6Y\\x81u~B:\\xd2\\x1f\\xb3\\xab\\x01:\\xfa\\xdf\\x19J8\\xd0\\x18RN\\xfe,CA\\x15\\xb3\\xe0', b&quot;0I\\xda5\\x9f\\x05v\\x17\\xdc\\xd4q\\xd6\\x83,\\x9d\\r\\xccc\\x8a\\xa1\\xd4U\\xd3\\x18\\xc9\\xc6g\\xcd\\nX\\x99Ah\\xed}\\xf3\\xb1(\\xd5I\\xc6\\x0f@yw9\\x9d\\xfdv\\x15x\\xeaRA\\xd6\\xb0\\x1e\\xb5B\\xe5\\x05cc\\x06m\\xf4NN'\\x02q\\x1a\\x11\\xe4\\x87P:\\xc8\\x11a\\x9f\\xbd\\x9c\\x98x\\xda\\xea\\xc4\\xa8f\\x89s\\xcaJ\\x7f\\xeb\\xd8\\xc1G#\\xf4\\xdc\\xe2\\x01\\xf2\\xa5\\x95\\x19`)2!\\xf5\\xb9\\xf0\\xf2\\xbb\\xf8\\x0bF&amp;&amp;`\\xfd*\\xe1\\xf2\\x9c&quot;, b':\\x99/Hxt\\xd1\\xd4\\xaaB\\xd6H\\x16\\xe1\\xc9\\xe2\\xb3\\xc3\\xa9b\\xd3\\x96\\x9c\\x05x6\\xf1\\xc3d\\xa2\\xd1U+.\\x1b\\xac^\\xf6Mh7\\xb7\\x03\\x8e\\xdc\\xca\\x0bn\\xac\\xed\\x92\\xb8x\\x04)\\x0f|\\x11\\xcc\\xfa\\xf2\\\\\\xba\\xee\\xc4X\\xa8(\\x05\\xf2\\xb5\\x8f&amp;\\xf3\\xff\\x1eB\\xe7\\x94\\xf4\\xa6\\x00!\\xe5v\\xd9x\\xf0s\\x94\\xf4D(\\xa9g\\x118\\xa7z\\x83\\xad\\xdb\\xe6\\xe3\\xe7\\xf8\\xf2\\xef\\xe5@\\xe9\\x13\\x00OB\\xcc\\x05\\xd1,_=\\xd2/Og\\x81\\xa6+', b'\\x1c|\\xb6\\xcc\\xdfj\\xc5\\xa0s\\xac w\\xa6\\xf2\\x87D\\xe3\\xf9Y\\xf5=\\xf0\\x0b\\xd9\\xea\\x89,+e\\x1e\\xb7m#\\x99\\xd1\\x87\\x17Z\\xed\\x1d\\xc8\\x97;\\xa0K\\x05.\\xaa&lt;\\xc6s\\xcf\\xa2\\xa2\\\\PO\\x12&amp;\\xb4\\x11\\xec\\xad\\x10\\xf8\\xf7\\xd1\\xd3_\\x80\\x17\\xe0\\x1eP\\x93\\xe3\\xc2\\x1e\\x03\\xea]^\\xc6a\\x9c\\xcb\\x90\\xbb\\x9f\\x8by\\xa5dhM\\xce\\xc7\\xbc\\xf7\\xafe\\xcf\\xc1\\xf1\\x18@\\x1e\\xe2\\xdb\\xfb\\xe4^\\xc8\\xe7\\x19\\xccnY\\xc6o\\x7fL\\x9fV\\xd4\\xc4\\x15\\xe8', ]sig = [b'\\t\\x8b\\xde\\x98\\x84\\x1d\\x9e\\xd4\\xa0\\xb7f\\xe0\\x05\\xb1\\xbd8\\xb9G\\xe3\\x0c\\x83\\x8a\\xe5\\xf0G7\\x12\\x1eT\\x85o-B\\xe4_\\xd2\\x04\\xd9:\\xab\\xdf\\xa1 \\x8f\\xedt+\\x0f\\xce\\xb5\\x90\\xaaK\\xf0U~v=\\x84\\xe7$G\\xf5\\xfb\\xd3ok~V\\x1a\\xec&amp;\\x15\\x18Y\\x0c\\x80u\\xafF\\xf1\\x10\\x9f\\xf2\\xe6\\xa6\\x9a\\xbb\\xbd+\\xa4l\\xa9\\x11\\xd5\\t\\x13\\x16\\xa3\\xde\\xe1\\xdfZ\\xa9$r\\xb5`\\xc9&quot;\\x11\\xab\\xc5\\x87\\xc4\\x1d@\\x9e\\xa4t\\xdb#\\xbdj\\xcb\\x95\\xefK', b'z/\\xd6\\xfb\\xd8\\xfa\\xc4\\xed\\xbd\\x99\\xd0\\xa0\\x90\\xcb\\xca\\x83\\xd8B\\xa7\\xf4\\xbd\\xe0\\xc2&amp;\\x1aQl(\\xd6p\\x8f\\x89=tT\\xf1(\\xeb\\xab\\x84[oR\\x1fl=\\xda\\xf5\\x18q\\x8f\\xa7k\\x00\\x1b\\x1a\\x0ei\\x1fa.ho\\x15\\x04\\x12\\xe4\\xc2\\xd7\\x19\\x92\\xc3\\x9b\\xfe\\xd5\\xb6R\\xf8\\x95\\x9fr\\x93\\xddD\\x1c[\\x873\\xd5\\x06\\x1b\\xa5\\x82/6\\x9a\\x13\\xcf\\xa4\\xcd\\x0e]\\t\\xad?\\xd6\\x84\\r\\x90\\xef\\x86\\xf15)\\xe34\\xf7\\xb77\\xef\\x0c&amp;\\xdb8\\xa6\\xe0\\xa5a', b'U\\x0b\\xf6\\x9cm])1\\xe2\\xad\\xf9G\\x8f\\xa2\\xbc}\\xd7\\x18\\x89\\xa4\\xfdFQ\\x80m&quot;\\xf9\\to^\\xd9A\\x98\\xd2\\xca\\x1e(b\\xa8\\xbe\\xc2m\\xf7\\n[O\\x00\\xbc\\x87\\x17\\xed\\x0cG\\xf2=H\\x0e\\xc0\\x14+\\xcb\\xd0\\x1feT2\\xf2Th\\xec\\xc2\\xcf&gt;6,&lt;\\x88X\\x8f\\xe9g\\xa8\\x00\\xafr\\x05\\x95\\rj\\x9c\\xc6\\n\\xbb\\x8a\\x019\\xc1\\x1ef#\\x02[Rh\\xd8\\xdc|{6\\xeb\\xe8U\\x91\\xa4\\xeb}\\xf4s;E\\xe72$i\\xdft\\xff\\'', b'[\\x94\\x95T\\xf4\\xc4\\xca\\x8drO\\x80\\x14\\xc9&lt;H\\xa2a\\xdc\\xf4`\\xac&gt;\\xab\\x03\\xfa\\x80Sx\\x99\\x14\\x83$U\\x0b\\xfa\\x8fv\\xfd\\xda\\x1a\\xa0\\xebY\\xaa\\x01\\xe2XsG\\t\\xcf\\xae\\xa0\\xbf\\x82iG\\tQ \\xb1\\xfe\\xa5k\\x12\\xd9\\x12\\xf7\\x95\\xa3\\xa5\\x8d`z\\x19\\x1a\\x90-\\x9aj\\x15\\xf6f&gt;\\x18\\x08\\xb8\\x1f\\x88\\x1a\\x80Th\\xd0\\x15\\x9bw#\\'`K\\xa5\\xf1\\xbf&quot;\\xe79\\xaf\\xc7z%p\\xa5\\x9f\\x14\\xef\\'1\\x11\\x05Gg\\xe9\\xda\\xc9\\x18~[', b':\\xefRE\\xd7\\xa1?\\xf3\\xb5\\xf7\\xdd\\xe2\\xb6~\\x85014\\xc0\\x8a\\x80\\xe1\\xb5#\\x94\\x10\\xb2\\xa0\\xfe\\x87\\xd1t\\xc3$&amp;\\xde8\\x195\\xcd\\xf4@3\\x15\\xcaK\\xcc\\xcd\\r:\\x83*\\xd7l\\xb6\\xf2} \\tJ\\xb5xKfjh.\\xfb\\xb5\\x91\\xc6\\xf2x\\x8e\\x83\\xdc\\xc3\\xef\\x8b\\x8dW\\xa6\\xa6\\xb0w\\xd8\\xf2G\\xa5-\\xc3\\x87\\x17;\\xedH`:\\xcd\\x08ts\\x9eqPE\\xd7\\xfc\\xc4\\x98\\xb5\\xe0\\xad\\xb7A\\x7f\\xcb\\x01\\xbd\\x98\\xd3Ea\\xb9\\x07\\x80\\xf8\\x19', b&quot;8\\xca\\x7f!;\\\\\\xde\\x1b\\x80i\\x9b!\\x1c??u\\x13\\x955\\xd0xG\\xff\\xd7\\xba\\xfe+\\x95\\x0eu^\\x15\\x1a\\x0e*\\xfe\\x8a\\xafM\\xc0\\xd1Ty\\xd7\\xf1\\xa7@\\xd6\\xa6\\xee\\x0c:It\\x1a\\xeag\\xfc\\x0c\\xaf\\x02&lt;\\x03T)\\xeb\\xb0\\x15\\x1cz\\x85\\x992\\xa9\\xbe\\x9bm\\xc4D\\x83\\xf7\\xb5T\\xdd9?\\x94\\xd4\\x13\\xb4\\xb3\\x8d\\xa9\\x92\\x9dt\\x86\\xdb\\x0b$\\x19l\\xb1\\xb9\\x05'o\\xf3!\\t\\x01\\x93'z\\x15P\\x88\\xd7iN\\n\\x8bA\\xb5\\xd2}\\xe8\\x10&quot; ]n = 99670316685463632788041383175090257045961799409733877510733415402955763322569510896091638507050126669571444467488936880059210773298729542608112756526719533574432327269721804307073353651955251188547245641771980139488000798458617636759823027148955008149512692983471670488580994385743789385091027299901520585729N = 81332992898551792936282861980393365170738006789835182134055801566584228471896473385776004610279937176800796971820133195300006470892468060034368863410462219133248069442508287516929262751427926825122839525496671527936622212986733708071962237633082743396115729744192159064241674410003857168101669882043743570731e = 65537enc = 2476965183785968993595493003363618829317072815989584886372189393899395623714779397354978469504773556228655475355703015337932838278988328384587983506790841663233499939173166353582189202860394411808445422387063648198432242875738065748287034529713834303346017134249834382745931627301273142828893469374138264396def orthogonal_lattice(B): _d, _n = B.nrows(), B.ncols() _c = 2 ** min(((_n-1)/2+(_n-_d)*(_n-_d-1)/4), 20) for b in B: _c *= b.norm() B_bot = (ceil(_c)*B).stack(identity_matrix(ZZ, _n)) B_r = B_bot.transpose().LLL() LB = B_r.matrix_from_rows_and_columns(range(_n-_d), range(_d, _n+_d)) assert (B*LB.transpose()).is_zero() return LBv = [crt([bytes_to_long(co_sig[i]), bytes_to_long(sig[i])], [N, n]) for i in range(6)]Lv = orthogonal_lattice(matrix(ZZ, v))result = orthogonal_lattice(Lv.matrix_from_rows(range(0, 6-2)))for x, y in combinations(result, 2): for a in tqdm(range(-10, 10)): for b in range(-10, 10): z = a*x+b*y if z.norm() &gt; sqrt(6*n): continue else: vv = vector(v)-z for i in vv: if gcd(i, n) != 1: p = gcd(i, n) assert n % gcd(i, n) == 0 q = n//p phi = (p-1)*(q-1) d = inverse_mod(e, phi) m = long_to_bytes(int(pow(enc, d, n))) print(m) exit() 原理RSA-CRT签名中计算了：$$\\sigma_p=\\mu(m)^d\\mod \\ p \\\\ \\sigma_q=\\mu(m)^d\\mod \\ q$$然后签名 $\\sigma=\\sigma_p\\cdot\\alpha+\\sigma_q\\cdot\\beta$ ，其中 $\\alpha=q\\cdot(q^{-1}\\mod\\ p)$ ， $\\beta=p\\cdot(p^{-1}\\mod\\ q)$ 。题目中给出 6 对签名，每对签名用 CRT 不难算出$$v=\\sigma_p\\cdot\\alpha+\\sigma_q\\cdot\\beta \\mod N\\cdot N’$$其中 $\\sigma_p$ 和 $\\sigma_q$ 和 $N/2$ 一个数量级， $\\alpha$ 和 $\\beta$ 又和 $N$ 一个数量级，故右式远小于 $N\\cdot N’$ ，那么上式在整数域上是成立的。一对算不出，但是多对可以，组成向量，有：$$\\boldsymbol{v}=\\alpha\\boldsymbol{x}+\\beta\\boldsymbol{y}$$其中 $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 是分量 $n/2$ 位的未知向量， $\\alpha$ 和 $\\beta$ 是有关 $p$ 和 $q$ 的 CRT 系数。不难计算出一组与 $\\mathbb{Z}^\\ell$ 中正交于 $\\boldsymbol{v}$ 的向量的格 $\\boldsymbol{v}^\\bot \\in \\mathbb{Z}^\\ell$ 的约化基 ${\\boldsymbol{b}_1,…,\\boldsymbol{b}_{\\ell-1}}$ 。（可能此时你会疑惑为什么是 ${\\ell-1}$ 个向量，下面的拓展里有解释）特别地，我们有：$$\\alpha \\langle \\boldsymbol{b}_j,\\boldsymbol{x} \\rangle + \\beta \\langle \\boldsymbol{b}_j,\\boldsymbol{y} \\rangle = 0 \\quad \\mathrm{for} \\ j=1,2,\\ldots,\\ell-1$$（也不是很特别的感觉）现在观察方程 $\\alpha\\cdot u+\\beta\\cdot v=0$ ，最小的非零解 $(u,v)\\in \\mathbb{Z}^2$ 是 $\\pm(\\beta,-\\alpha)/g$ ，其中 $g=\\gcd(\\alpha,\\beta)$ 盲猜是非常小的（经测试基本在10以内），意味着 $|u|,|v|\\geq\\mathit{\\Omega}(N)$ 中 $\\mathit{\\Omega}$ 常量是非常小的。（啥玩意？）对 $j=1,2,\\ldots,\\ell-1$ ，有以下两种可能： 情形1：$\\langle \\boldsymbol{b}_j,\\boldsymbol{x} \\rangle = \\langle \\boldsymbol{b}_j,\\boldsymbol{y} \\rangle = 0$ 。此时 $\\boldsymbol{b}_j$ 属于 $\\mathbb{Z}^\\ell$ 中与 $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 正交的向量的格 $L={\\boldsymbol{x},\\boldsymbol{y}}^\\bot$ 情形2：$\\langle \\boldsymbol{b}_j,\\boldsymbol{x} \\rangle$ 和 $\\langle \\boldsymbol{b}_j,\\boldsymbol{y} \\rangle$ 有绝对值 $\\geq \\mathit{\\Omega}(N)$ ，其中 $\\mathit{\\Omega}(N)$ 是一个小常数。因为 $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 的范数都不超过 $\\sqrt{\\ell N}$ ，由柯西-施瓦茨不等式，这意味着 $||\\boldsymbol{b}_j||\\geq \\mathit{\\Omega}(\\sqrt{\\ell N})$ 因为格 $L={\\boldsymbol{x},\\boldsymbol{y}}^\\bot$ 的秩是 $\\ell-2$ ，当全部 $\\ell-1$ 个向量 $\\boldsymbol{b}_j$ 线性无关时情形1不成立，所以最长的 $\\boldsymbol{b}_{\\ell-1}$ 应该在情形2中，因此 $||\\boldsymbol{b}_{\\ell-1}||\\geq \\mathit{\\Omega}(\\sqrt{\\ell N})$ 。另一方面，其他向量形成一个秩为 $\\ell-2$ 的格，且体积$$V=\\mathrm{vol}(\\mathbb{Z}\\boldsymbol{b}_1\\oplus\\cdots\\oplus\\mathbb{Z}\\boldsymbol{b}_{\\ell-2})\\approx\\frac{\\mathrm{vol}(\\boldsymbol{v}^\\bot)}{||\\boldsymbol{b}_{\\ell-1}||}=\\frac{||\\boldsymbol{v}||}{||\\boldsymbol{b}_{\\ell-1}||}\\leq \\frac{\\sqrt{\\ell}\\cdot N^{3/2}}{\\mathit{\\Omega}(\\sqrt{N/\\ell})}=O(\\ell N)$$盲猜是一个随机的格。特别地，我们有：$$||\\boldsymbol{b}_j||=O(\\sqrt{\\ell-2}\\cdot V^{1/(\\ell-2)})=O(\\ell^{1/2+1/(\\ell-2)}\\cdot N^{1/(\\ell-2)})\\quad\\mathrm{for} \\ j=1,2,\\ldots,\\ell-2$$ 一旦 $\\ell \\geq 5$ ，这个长度就远小于 $\\sqrt{N/\\ell}$ 。假设是这种情况，那么对于 $j=1,2,…,\\ell-2$ ， $\\boldsymbol{b}_j$ 应该是情形1中。这意味着这些向量生成 $L={\\boldsymbol{x},\\boldsymbol{y}}^\\bot$ 中一个满秩的子格 $L’=\\mathbb{Z}\\boldsymbol{b}_1\\oplus\\cdots\\oplus\\mathbb{Z}\\boldsymbol{b}_{\\ell-2}$ 。取正交格，我们得到 $(L’)^\\bot \\supset L^\\bot=\\mathbb{Z}\\boldsymbol{x}\\oplus\\mathbb{Z}\\boldsymbol{y} $。因此， $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 属于 $L’$ 的正交格 $(L’)^\\bot$ 。令 ${\\boldsymbol{x’},\\boldsymbol{y’}}$ 为一组该格的约化基，我们可以枚举 $(L’)^\\bot$ 中的长度不超过 $\\sqrt{\\ell N}$ 且为 $\\boldsymbol{x’}$ 和 $\\boldsymbol{y’}$ 线性组合的所有格向量。高斯启发式表明这大约为：$$\\frac{\\pi(\\sqrt{\\ell N})^2}{\\mathrm{vol}((L’)^\\bot)}=\\frac{\\pi\\ell N}{V}=O(1)$$这样的向量，所以这肯定是可行的。对这些向量 $\\boldsymbol{z}$ ，我们计算 $\\gcd(\\boldsymbol{v}-\\boldsymbol{z},N)$ 。我们将因此很快在其中找到 $\\gcd(\\boldsymbol{v}-\\boldsymbol{x},N)$ ，因为 $\\boldsymbol{x}$ 是一个 $(L’)^\\bot$ 中长度 $\\leq\\sqrt{\\ell N}$ 的向量。但根据 $\\boldsymbol{v}$ 的定义，我们有：$$\\boldsymbol{v}=\\boldsymbol{x}\\mod p\\\\\\boldsymbol{v}=\\boldsymbol{y}\\mod q$$故 $\\gcd(\\boldsymbol{v}-\\boldsymbol{x},N)=p$ ，从而分解 $N$ 。 拓展阅读-正交格令 $\\mathbf{b}_1,…,\\mathbf{b}_d$ 为 $\\mathit{\\Lambda}$ （这玩意念Lambda）中的向量。如果这 $d$ 个向量在 $\\mathbf{Z}$ 上线性无关且 $\\mathit{\\Lambda}$ 中的任意元素可以由 $\\mathbf{b}_i$ 整系数线性表出，则这 $d$ 个向量形成 $\\mathit{\\Lambda}$ 中的一组基。 $\\mathit{\\Lambda}$ 中至少存在一组基。 $\\mathit{\\Lambda}$ 的基都有相同的基数，称为 $\\mathit{\\Lambda}$ 的维度。 如果 $\\mathit{\\Omega}$ 包含 $\\mathit{\\Lambda}$ ，且两者有相同的维度，则称 $\\mathit{\\Lambda}$ 为 $\\mathit{\\Omega}$ 在 $\\mathbf{Z}^n$ 上的一个子格。（子格的定义？） $\\mathit{\\Lambda}$ 的所有基张成相同的 $\\mathbf{Q}^n$ 的 $Q$ 向量子空间（啥玩意？），记为 $E_{\\mathit{\\Lambda}}$ 。 $\\mathbf{Q}^n$ 上 $E_{\\mathit{\\Lambda}}$ 的维度与 $\\mathit{\\Lambda}$ 的维度相同。令格 $\\overline{\\mathit{\\Lambda}}=E_{\\mathit{\\Lambda}}\\cap\\mathbf{Z}^n$ 。 $\\mathit{\\Lambda}$ 是 $\\overline{\\mathit{\\Lambda}}$ 的一个子格。如果 $\\mathit{\\Lambda}=\\overline{\\mathit{\\Lambda}}$ ，那么我们称 $\\mathit{\\Lambda}$ 是一个完备格，特别的， $\\overline{\\mathit{\\Lambda}}$ 是一个完备格。 笔者注记：这里首先将 $\\mathit{\\Lambda}$ 张成一个有理数空间，不局限于整系数向量组合了，记为 $E_{\\mathit{\\Lambda}}$ 的E我猜是欧几里得的意思？然后与 $\\mathbf{Z}^n$ 相交得到的是整数点集合 $\\overline{\\mathit{\\Lambda}}$ ，如此 $\\mathit{\\Lambda}$ 是 $\\overline{\\mathit{\\Lambda}}$ 子格的事应该挺自然的。然后如果两者相等，想象一下，都那样张成了都找不到新的点，那这个格确实也挺完备。PS:发现自己念了十年的欧几里得，难怪输入法打不出来（） 令 $(\\mathbf{x},\\mathbf{y})\\rightarrow\\mathbf{x}.\\mathbf{y}$ 为一般意义上的欧里几德内积， $||.||$ 是它对应的范数 （奇怪的表示方法）。令 $F=(E_{\\mathit{\\Lambda}})^-$ 是关于该内积的正交向量子空间。我们定义正交格 $\\mathit{\\Lambda}^-=F\\cap\\mathbf{Z}^n$ 。因此， $\\mathit{\\Lambda}^-$ 是一个 $\\mathbf{Z}^n$ 上的完备格，其维度为 $n-d$ 。这意味着 $(\\mathit{\\Lambda}^-)^-$ 等于 $\\overline{\\mathit{\\Lambda}}$ 。令 $\\mathcal{B}=(\\mathbf{b}_1,…,\\mathbf{b}_d)$ 为 $\\mathit{\\Lambda}$ 的一组基。 笔者注记：看到这就有点迷糊了，捋一捋： $E_{\\mathit{\\Lambda}}$ 是 $\\mathit{\\Lambda}$ 张成出的有理空间，然后 $F$ 是其正交向量子空间，即任意从 $\\mathit{\\Lambda}$ 和 $F$ 分别抓两个向量出来，其内积都为 $0$ 。再然后 $\\mathit{\\Lambda}^-$ 是 $F$ 的一个子格，注意到 $\\mathit{\\Lambda}^-$ 把 $F$ 所有整数点都框进去了，这就很有意思了，由上面的定义就不难得出正交格 $\\mathit{\\Lambda}^-$ 是一个 $\\mathbf{Z}^n$ 上的完备格。至于其维度为何是 $n-d$ ，有个概念叫正交补，就是正交空间的维数是刚刚好的，对于列空间维数为 $r$ 的矩阵 $A_{r\\times m}$ ，其左零空间的维数是 $m-r$ ，相加恰好为 $m$ 。举例来说，三维中与线正交的是二维空间，与面正交的是一维空间。这篇 paper 习惯用 $E^-$ 表示正交向量子空间，但似乎 $E^\\bot$ 的写法较为广泛。 在 $\\mathbf{Z}^n$ 的正则基上解析每个 $\\mathbf{b}_j$ 如下： $$\\mathbf{b}_j =\\begin{pmatrix}b_{1,j} \\\\b_{2,j} \\\\\\vdots \\\\b_{n,j}\\end{pmatrix}$$（这里吐槽一下，由于下划线和 Markdown 语法有冲突，如果不加反斜杠， $b_j$ 写成 $\\mathbf{b}_j$ Latex 就会炸，下文一开始也炸了几回，弄了几次才发现是这问题） 定义整数 $n\\times d$ 的整数矩阵 $B=(b_{i,j})_{1\\leq i\\leq n,1\\leq j\\leq d}$ ，格 $\\mathit{\\Lambda}$ 由 $B$ 的列向量张成，我们称 $\\mathit{\\Lambda}$ 由 $B$ 张成。令 $Q={^tB}B$ 为 $d\\times d$ 的对称 Gram 矩阵。 $Q$ 的行列式是与 $\\mathcal{B}$ 无关的正整数。 $\\mathit{\\Lambda}$ 的行列式被定义为 $\\det(\\mathit{\\Lambda})=\\sqrt{\\det(B)}$ 。 笔者注记：这是的 ${^tB}$ 应该是 $B^T$ 的意思，又是奇怪的写法（）至于 Gram 矩阵，中文音译为格拉姆矩阵，对 $n$ 维欧氏空间上的 $k$ 个向量，其 Gram 矩阵为$$\\triangle(\\mathbf{v}_1,\\dots,\\mathbf{v}_k) =\\begin{pmatrix}\\langle\\mathbf{v}_1,\\mathbf{v}_1\\rangle &amp; \\cdots &amp; \\langle\\mathbf{v}_1,\\mathbf{v}_k\\rangle \\\\\\vdots &amp; \\ddots &amp; \\vdots \\\\\\langle\\mathbf{v}_k,\\mathbf{v}_1\\rangle &amp; \\cdots &amp; \\langle\\mathbf{v}_k,\\mathbf{v}_k\\rangle\\end{pmatrix}$$不难看出这个可以等价表示为 $V^T\\times V$ ，得出的矩阵也显然是对称的。这里 $\\mathit{\\Lambda}$ 不是一个方阵，故不能直接求出其行列式，那么就应该通过其 Gram 矩阵来求行列式，这里我觉得应该是 $\\det(\\mathit{\\Lambda})=\\sqrt{\\det(Q)}$ ，但我不确定。 定理1 令 $\\mathit{\\Lambda}$ 为 $\\mathbf{Z}^n$ 上的完备格，那么 $\\det(\\mathit{\\Lambda}^-)=\\det(\\mathit{\\Lambda})$ 。证明：我们有 $\\mathit{\\Lambda}=E_{\\mathit{\\Lambda}}\\cap\\mathbf{Z}^n$ 和 $\\mathit{\\Lambda}^-=E_{\\mathit{\\Lambda}}^-\\cap\\mathbf{Z}^n$ 。从另一篇论文（我也没读过）我们知道：$$\\det(\\mathbf{Z}^n)=\\frac{\\det(E_{\\mathit{\\Lambda}}\\cap\\mathbf{Z}^n)}{\\det((E_{\\mathit{\\Lambda}}^-)\\cap(\\mathbf{Z}^n)^*)}$$其中 $(\\mathbf{Z}^n)^*$ 表示 $\\mathbf{Z}^n$ 上的极格。但 $\\det(\\mathbf{Z}^n)=1$ （？为什么要说但呢？）且 $(\\mathbf{Z}^n)^*=\\mathbf{Z}^n$ ，故 $\\det(\\mathit{\\Lambda}^-)=\\det(\\mathit{\\Lambda})$ 。 推论2 令 $\\mathit{\\Lambda}$ 为 $\\mathbf{Z}^n$ 上的格，那么 $\\det((\\mathit{\\Lambda}^-)^-)=\\det(\\mathit{\\Lambda}^-)=\\det(\\overline{\\mathit{\\Lambda}})$ 。 定理3 令 $(\\mathbf{b}_1,…,\\mathbf{b}_d)$为格$\\mathit{\\Lambda}$ 在 $\\mathbf{Z}^n$ 上的一组 LLL 约化基，那么： $\\det(\\mathit{\\Lambda})\\leq \\prod^d_{i=1}||\\mathbf{b}_i||\\leq 2^{d(d-1)/4}\\det(\\mathit{\\Lambda})$ 对任意线性无关的向量 $\\mathbf{x}_1,…,\\mathbf{x}_t\\in\\mathit{\\Lambda}$ ，当 $1\\leq j \\leq t$ 时，有：$$||\\mathbf{b}_j||\\leq 2^{(d-1)/2}\\max(||\\mathbf{x}_1||,…,||\\mathbf{x}_t||)$$ 我们现在描述计算正交格的一组 LLL 约化基的基本方法。令 $\\mathcal{B}=(\\mathbf{b}_1,…,\\mathbf{b}_d)$ 为 $\\mathit{\\Lambda}$ 的一组基， $B=(b_{i,j})$ 为其对应的 $n\\times d$ 的矩阵。令 $c$ 为一个正整数常量。定义 $\\mathit{\\Omega}$为$\\mathbf{Z}^{n+d}$ 上由以下 $(n+d)\\times n$ 矩阵张成的格。 $$B^-=\\begin{pmatrix}c\\times b_{1,1} &amp; c\\times b_{2,1} &amp; \\cdots &amp; c\\times b_{n,1} \\\\c\\times b_{1,2} &amp; c\\times b_{2,2} &amp; \\cdots &amp; c\\times b_{n,2} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\c\\times b_{1,d} &amp; c\\times b_{2,d} &amp; \\cdots &amp; c\\times b_{n,d} \\\\1 &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 1 &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; 0 &amp; \\cdots &amp; 1\\end{pmatrix}$$矩阵 $B^-$ 被分成两块：上面 $d\\times n$ 部分是 $c\\ {^tB}$ ，下面 $n\\times n$ 部分是单位阵。设 $p_{\\uparrow}$ 和 $p_{\\downarrow}$ 是两个投影，将 $\\mathbf{Z}^{n+d}$ 的任何向量分别映射到由其前 $d$ 个坐标构成的 $\\mathbf{Z}^d$ 向量和由其最后 $n$ 个坐标构成的 $\\mathbf{Z}^n$ 向量，所有投影都与正则基有关。（这段翻译累死我了）令 $\\mathbf{x}$ 为 $\\mathit{\\Omega}$ 的一个向量并记 $\\mathbf{y}=p_{\\downarrow}(\\mathbf{x})$ ，那么 $$p_{\\uparrow}(\\mathbf{y})=\\begin{pmatrix}\\mathbf{y}.\\mathbf{b}_1 \\\\\\vdots \\\\\\mathbf{y}.\\mathbf{b}_d\\end{pmatrix}$$因此，当且仅当 $p_{\\uparrow}(\\mathbf{x})=0$ 时有 $\\mathbf{y}\\in \\mathit{\\Lambda}^-$ 。此外，如果 $||\\mathbf{x}||\\leq c$ ，那么 $p_{\\uparrow}(\\mathbf{x})=0$ 。 定理4 令 $(\\mathbf{x}_1,\\mathbf{x}_2,…,\\mathbf{x}_n)$ 为格 $\\mathit{\\Omega}$ 的一组 LLL 约化基。若 $$c&gt;2^{(n-1)/2+(n-d)(n-d-1)/4}\\det(\\overline{\\mathit{\\Lambda}})$$则 $(p_{\\downarrow}(\\mathbf{x}_1),p_{\\downarrow}(\\mathbf{x}_2),…,p_{\\downarrow}(\\mathbf{x}_{n-d}))$ 为 $\\overline{\\mathit{\\Lambda}}$ 的一组 LLL 约化基。 使用阿达马不等式，我们得到以下算法： 算法5 给定一组 $\\mathbf{Z}^n$ 上格 $\\mathit{\\Lambda}$ 的基 $(\\mathbf{b}_1,\\mathbf{b}_2,…,\\mathbf{b}_d)$ ，该算法计算一组 $\\overline{\\mathit{\\Lambda}}$ 的LLL约化基。 选取 $c=\\lceil2^{(n-1)/2+(n-d)(n-d-1)/4}\\prod^d_{j=1}||\\mathbf{b}_j||\\rceil$ 计算 $(n+d)\\times n$ 的整数矩阵 $B^-$ 和 $\\mathbf{b}_1,…,\\mathbf{b}_d$ 对应的 $n\\times d$ 矩阵 $B=(b_{i,j})$ 计算由 $B^-$ 张成的格的一组 LLL 约化基 $(\\mathbf{x}_1,\\mathbf{x}_2,…,\\mathbf{x}_n)$ 输出 $(p_{\\downarrow}(\\mathbf{x}_1),p_{\\downarrow}(\\mathbf{x}_2),…,p_{\\downarrow}(\\mathbf{x}_{n-d}))$ 可以证明，这是一个关于空间维数 $n$ 、格维数 $d$ 和 $||\\mathbf{b}_j||$ 比特长度的任何上界的确定性多项式时间算法。在实践中，不需要选择这样大的常数 $c$ ，因为 LLL 算法的理论界非常悲观。（翻译了这么久都看不懂，我也很悲观.jpg） 笔者注记：$\\lceil$和$\\rceil$表示向上取整，例如$\\lceil 1.2 \\rceil = 2$。 实现之前看过 Herry 师傅从 dbt 那抄的一个求法是用左零空间求解，代码如下 123def orthogonal_lattice(B): LB = B.transpose().left_kernel(basis=&quot;LLL&quot;).basis_matrix() return LB 但笔者发现这样似乎只能在低维下求解，高维情况下时间会爆炸（至少试过一夜都没跑出来）于是照着 paper 搓了一个 implemention ，快了很多，三分钟左右就能求解 $255\\times512$ 矩阵的正交格，代码如下 12345678910def orthogonal_lattice(B): _d, _n = B.nrows(), B.ncols() _c = 2 ** min(((_n-1)/2+(_n-_d)*(_n-_d-1)/4),20) # this bound can be adjusted as needed for b in B: _c *= b.norm() B_bot = (ceil(_c)*B).stack(identity_matrix(ZZ, _n)) B_r = B_bot.transpose().LLL() LB = B_r.matrix_from_rows_and_columns(range(_n-_d), range(_d,_n+_d)) assert (B*LB.transpose()).is_zero() return LB 参考 P. Q. Nguyen and J. Stern. Merkle-Hellman revisited: A cryptoanalysis of the Qu-Vanstone cryptosystem based on group factorizations. In B. S. Kaliski Jr., editor, CRYPTO, volume 1294 of Lecture Notes in Computer Science, pages 198–212. Springer, 1997. Modulus Fault Attacks Against RSA-CRT Signatures 知乎 线性代数之——正交向量与子空间 知乎 格拉姆矩阵（Gram matrix）详细解读","link":"/2022/08/18/2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%20Crypto/"},{"title":"Hackergame 2021 writeups","text":"第一次打CTF比赛 Summary作为新手，第一次参加 CTF ，题目比 MSClub 的招新 puzzle 难得多，但是也好玩得多，前两天有幸短暂地在总榜停留过（或者只是第一天？忘了），最终组内排名第四（因为校内的大佬不在）（ GZTime tql ，凌晨肝神冲到总榜第四orz，此处附上 wp 传送门）。比赛的题目出得都非常得有趣 （除了透明的文件），对新手来说体验确实不错，也确实是名副其实的pythongame（零基础强行入门），做到灯那题的时候我面对线性非齐次方程组的无穷多解毫无头绪，这彻底燃起了我学线代的激情（嗯，有意思），最后我交的第一个错误的 flag 上了花絮也有小小的惊喜（没错我确实是有备而来hiahiahia）。总体体验良好，明年再来。下面是我做出的几题的wp，内容较水，可酌情移步至神（mcfx）的 wp。 签到 为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！ 很简单的web题，注意到网址栏的后面的?page=&lt;当面的数字&gt;，直接修改，疯狂加0，然后二分法试探，最终在 ?page=1635000000 的时候到达当前时间，出 flag (后来才知道这是时间戳)。 进制十六——参上 为严防 flag 泄漏以及其他存在于未来所有可能的意外灾难，神通广大的 Z 同学不仅强制要求每一道题目都加上权限和资源的限制，还给所有参与 Hackergame 2021 命题的计算机施加了一层法术结界。任何试图从结界逃逸的 flag 都会被无情抹除。 而一位明面上是计算机学院的新生，实则为物理学院暗部核心成员的 X 同学，在 Hackergame 2021 命题组已经潜伏多时。妄想趁比赛开始的午时，借阳火正旺之势，冲破 Z 同学的结界，以图片而非明文的形式，将 flag 悄悄传递出来。 好在 Z 同学法力之深厚，不可管窥蠡测。在 flag 被传出去的前两天，就已预知此事并将图片中的 flag 无声消泯了。 只是，这位 X 同学，虽然不会退出 Vim，但是似乎对打开十六进制编辑器颇有造诣…… 同样是很简单的题目，随便找个十六进制编辑器照着抄下然后得出右边的 flag （手打真的累，还打错了一个字母）。 去吧！追寻自由的电波 （前情提要） 为了打破 Z 同学布下的结界，X 同学偷偷搬出社团的业余无线电台试图向外界通讯。 当然，如果只是这样还远远不够。遵依史称“老爹”的上古先贤的至理名言，必须要“用魔法打败魔法”。X 同学向上级申请到了科大西区同步辐射实验室设备的使用权限，以此打通次元空间，借助到另一个平行宇宙中 Z 同学的法力进行数据对冲，方才于乱中搏得一丝机会，将 flag 用无线电的形式发射了出去。 考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母。即使如此，打破次元的强大能量扭曲了时空，使得最终接受到的录音的速度有所改变。 为了保障同步辐射设备的持续运转，组织牺牲了大量的能源，甚至以东北部分地区无计划限电为代价，把这份沉甸甸的录音文件送到了你的手上。而刚刚起床没多久，试图抢签到题一血还失败了的你，可以不辜负同学们对你的殷切期望吗？ 注：flag 花括号内只包含小写字母。 题目说了速度变了，显然是变快了，直接用经典音频隐写软件 Audacity 打开， Ctrl + A 全选，效果-改变速率，然后随手一拖把改变百分比拖到 70 就有非常标准清晰的单词，不看题目都能盲猜是首字母，后来查电报区分字符串中读音相近的字母的方法也确实对应，但是我还是不想自己听，打开翻译软件，嗯，语音识别不错，除了两个花括号我一开始没反应过来把也当成字母了QAQ。 猫咪问答 Pro Max 我猛然一看，就猛然看到这个猫咪问答，我直呼我直呼，上次看到这么这么的发言还是上次，这问答属于是典型的典型了，我之前还没发现，当我发现的时候我已经发现了，这问答就像一个问答，问答的内容充满了内容，我不禁感慨了一句感慨：希望下次看到这么这么的猫咪问答是下次。 题目的废话文学着实是让我涨了见识，这简直简直了，我以前从未想过有如此废话的废话文学，等我看见的时候已经看见了……第一问也是最难的一问，把百度必应谷歌翻烂了也没有，后来终于在一个专门存快照的国外网站上找到了那个已经消失的俱乐部的网页存档，第三问直接在中科大 Linux 用户协会官网找到，第五问也不难搜（虽然我没想到举报信可以发到这么奇怪的…呃不知怎么形容，目录？？去），第四问我看到论文直接望而生畏，搜索 data set 无果后果断爆破，合理猜测在 100 以下，但发现居然不行？？？万分怀疑的我试探性地把第二问改成 3 （或许是我对近五年的理解有问题？），也不行，改成 5 ，行了 （这协会真不要 face ），脚本如下： 1234567891011121314151617181920212223import requests as rimport refrom tqdm import tqdmdef main(): url = 'http://202.38.93.111:10001/' payload = {'q1': 20150504, 'q2': 5, 'q3': 'Development Team of Library', 'q4': 0, 'q5': '/dev/null'} headers = {'Cookie': 'session=eyJ0b2tlbiI6IjQ2Ok1FWUNJUUNyY2xUYU1XcG9sUzZqZzM0Z2IyZnMyeEJBNGtMa01DYnpKV1dERGNKWUJnSWhBT3RQTzBXSnhLMnRmcytWcVRReWd5eHdKMFY2dEZ6bGlycXVNSURHbU9EaSJ9.YXYWYA.2MXfMT2si0FkY-Z9jOc7V4jenTU'} for i in tqdm(range(100)): payload['q4'] = i _ = r.post(url=url, data=payload, headers=headers).text try: rst = re.findall( r'&lt;div class=&quot;alert alert-secondary&quot; role=&quot;alert&quot;&gt;((?:.|\\n)*?)&lt;/div&gt;', _)[0] except IndexError: s=re.findall(r'(flag{.*?})', _)[0] print ('\\n'+s) print('q4答案是'+str(i)) breakif __name__ == '__main__': main() 卖瓜 有一个人前来买瓜。 HQ：哥们，这瓜多少钱一斤啊？ 你：两块钱一斤。 HQ：What’s up！这瓜皮子是金子做的还是瓜粒子是金子做的？ 你：你瞧瞧现在哪有瓜啊？这都是大棚的瓜，只有 6 斤一个和 9 斤一个的，你嫌贵我还嫌贵呢。 （HQ 心里默默一算） HQ：给我来 20 斤的瓜。 你：行！ HQ：行？这瓜能称出 20 斤吗？ 你：我开水果摊的，还不会称重？ HQ：我问你这瓜能称出 20 斤吗？ 你：你是故意找茬，是不是？你要不要吧！ HQ：你这瓜要是刚好 20 斤吗我肯定要啊。那它要是没有怎么办啊？ 你：要是不是 20 斤，我自己吃了它，满意了吧？ （你开始选瓜称重） 在看过上一年的题目后可以直接看出是溢出，但是输入的数字过大后出现了浮点数，于是我上网搜了数据类型，随便复制了一个数（ 2 的多少次方来着？？忘了）过来输入到 9 斤那，出现了一个大负数，然后我掏出大宝贝—— Windows 计算器除以 6 ，结果去掉小数后再输入到 6 斤那，此时称上有了 -2 斤，嗯，可行，再来一次， -4 了，直接再放 4 个 6 斤，逃过一劫，得到 flag 。 FLAG 助力大红包 “听说没？【大砍刀】平台又双叒做活动啦！参与活动就送 0.5 个 flag 呢，攒满 1 个 flag 即可免费提取！” “还有这么好的事情？我也要参加！” “快点吧！我已经拿到 flag 了呢！再不参加 flag 就要发完了呢。” “那怎么才能参加呢？” “这还不简单！点击下面的链接就行” 这应该是让我学到最多东西的一题，看到题目的说明我第一反应就是通过 http 请求头伪造 IP 地址，搜到可以通过 X-Forwarded-For 实现，但中途我试图通过审查元素修改表单数据实现，结果提示前后端地址不匹配（后来才发现我没读题），于是找了个伪造 IP 地址的插件，这次是后端改了前端还是原来的，两个结合，发现可以成功砍到，手改几次后发现速度来不及，被迫找到 Python 的实现，一开始没加时间限制发现有令牌桶防着，就加了个停顿，脚本如下： 1234567891011import requestsimport timefrom tqdm import tqdmurl = 'http://202.38.93.111:10888/invite/77632ca2-c165-46ee-a8d2-ba89094b0401'ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0'for i in tqdm(range(256)): s = (str(i)+'.104.67.89') params = {&quot;ip&quot;: s,} request = requests.post(url, data=params, headers={'User-agent': ua, 'X-Forwarded-For':s}) time.sleep(0.9)print(request.text) Amnesia第一问 你的程序只需要输出字符串 Hello, world!（结尾有无换行均可）并正常结束。 编译指令：gcc -O file.c -m32 运行指令：./a.out 编译器版本：Docker 镜像 ustclug/debian:10 中 apt update &amp;&amp; apt -y upgrade &amp;&amp; apt install -y gcc=4:8.3.0-1 gcc-multilib=4:8.3.0-1 的版本 轻度失忆 编译后 ELF 文件的 .data 和 .rodata 段会被清零。 连接题目：nc 202.38.93.111 10051 或网页终端 判题脚本：下载 第一问不难，发现直接printf(&quot;Hello,world!&quot;)失败后改成用printf(&quot;%c&quot;,&lt;每个字符的ASCII码&gt;)，但提交后错误，仔细检查发现多了几个奇怪的不可显示字符，应该是直接从网页复制的问题，删掉后提交得到flag，比赛结束后才知道还可以putchar呃呃 图之上的信息 小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。 你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？ 第一反应是 SQL 注入，但零基础的我忙活了半天才知道 /graphql 是端点，查看 http 请求看到负载语句{query: &quot;{ notes(userId: 2) { id↵contents }}&quot;}猜测 admin 的 id 是 1 ，于是疯狂查询 1 的 contents ，结果回显都是我没有权限，后来搜到了 Graphql 的 IDE ，找到了存储邮箱的地方，查询得到 flag 。 Easy RSA 自从 Hackergame 2018 公然揭露了大整数可以被神童口算分解的事实，RSA 在 hackergame 中已经只能处于低分值的地位了。如果不在其名称前面加上 Easy 这个单词，似乎就会显得完全对不起其他题目。 更何况，在本题的附件中，你还获得了构造 p 和 q 的方式。数理基础扎实的你应该可以轻松解决这些问题吧。 12345678910111213141516171819202122232425262728293031323334353637import mathimport sympyfrom Crypto.Util.number import *e = 65537def get_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 value_p = sympy.nextprime((math.factorial(y)) % x) # Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征 return value_pdef get_q(): value = [getPrime(256)] for i in range(1, 10): value.append(sympy.nextprime(value[i - 1])) print(&quot;value[-1] = &quot;, value[-1]) # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967 n = 1 for i in range(10): n = n * value[i] q = getPrime(512) value_q = pow(q, e, n) print(&quot;value_q = &quot;, value_q) # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy.nextprime(q)# this destroyes the rsa cryptosystemp = get_p()q = get_q()m = int.from_bytes(open(&quot;flag.txt&quot;, &quot;rb&quot;).read(), &quot;big&quot;)c = pow(m, e, p * q)print(&quot;c = &quot;, c)# c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478 数理杀我的一题， acm 的题中有过类似的，威尔逊定理求出 $p$ ， $q$ 的话不难求，很好，现在是经典 RSA 了，什么，你问我到底怎么求的p？哦？我还等你讲给我听呢（装傻，阿巴阿巴）。首先科普一下模逆元的概念，比如 $x\\equiv 3^{-1}mod \\ 5$ ，这个并非是 $x=\\frac{1}{3}$ 的意思，而是 $x$ 满足 $3x\\equiv 1\\ mod\\ 5$ ，这时口算得出 $x=2$ ，因为 $6\\equiv 1\\ mod\\ 5$ 嘛。然后是威尔逊定理，即 $(p-1)!\\equiv-1(mod\\ p)$ 是 $p$ 为素数的充要条件。题目给出大数 $x$ 和比 $x$ 小一点的 $y$ ，要我们求 $y!\\ mod\\ x$ ，检验发现 $x$ 是一个素数，那么就有 $(x-1)!\\equiv-1(mod\\ x)$ 。继而由 $(x-1)!=y(y+1)(y+2)\\cdots(x-1)$ ，不难推知$$y!\\equiv -1(x-1)^{-1}(x-2)^{-1}\\cdots (y+1)^{-1}\\ mod\\ x$$python 计算逆元有两种方法，一种是pow(a, -1, b)，另一种是用 gmpy2 库，即gmpy2.invert(a,b) 完整exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sympyfrom Crypto.Util.number import *from gmpy2 import inverte = 65537def get_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 facymodx = -1 for i in range(y+1,x): facymodx = facymodx*invert(i,x)%x value_p = sympy.nextprime(facymodx) return value_pdef get_q(): value_inverse = [ 80096058210213458444437404275177554701604739094679033012396452382975889905967] for i in range(1, 10): value_inverse.append(sympy.prevprime(value_inverse[i-1])) n = 1 phi = 1 for i in range(10): n = n * value_inverse[i] phi = phi * (value_inverse[i]-1) value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 d = invert(e, phi) q = pow(value_q, d, n) return sympy.nextprime(q)c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478if __name__ == '__main__': p = get_p() q = get_q() # print(len(str(q))) print(p) print(q) n = p * q phi = (p-1) * (q-1) d = invert(e, phi) m = pow(c, d, n) print(long_to_bytes(m))","link":"/2021/11/05/Hackergame2021-writeups/"},{"title":"Hackergame 2022 writeups","text":"好玩，爆赞！ Summary不知不觉，离上一年Hackergame都一年了 （有点像废话），作为我CTF的启蒙赛， Hackergame 2021 拿分最多的其实还是靠 web ，如今我却出乎意料地成为了队里的密码手。今年已经不像上年那么有空，前面的搜索题都没空做。总体来说，虽然做不出来，但好歹也能将大部分题目阅读一遍了。（有进步，但不多）没好意思填学校的组，直接在公开组注册，最终得分 2850 ，总排名 145 ，也就只有 math 榜上能看见我了。GZTime 还是如同上年一样直线上分，但意想不到的是mcfx也被一个不明来路的直线上分的老六偷了榜一。这里记录一下解出的题的题解，对解不出但尝试过的，也作一些记录，多少从中学到了一些东西。最近要期中考，断断续续更这里吧。 签到点开网页，发现是一个手写签名，四个框内，依次要在2秒，1秒，0.1秒，0.0秒内分别写下2022才能通过。首先直接靠手速必然是不行的，因为第四个框最多只能留下一个点，于是尝试点了个提交，发现顶上的url多了个?result=????，果然还是和上年一样的套路，四个问号改成 2022 ，回车，得到 flag 。 猫咪问答喵第一问直接搜就有，第二问没找到，第三问也直接搜，第四问没找，第六问爆破出来的（）第五问也没找出来，但是找到一个网站叫 Censys.io ，似乎可以搜索 ssh 的 sha256 指纹查 host ，以及有关一堆乱七八糟的查询，不知道以后能不能用得上。 家目录里的秘密Level1 直接搜目录内文件就有。Level2 没下 Rclone ，以为要找到那个rclone.config文件里的真实域名再ftp进去。。。 HeiLangCtrl+H，将 | 全部替换成 ]=a[ 即可。 Xcaptcha用 pyppeteer 干了，简单粗暴。代码如下： 123456789101112131415161718192021222324252627import asynciofrom pyppeteer import launchasync def main(): browser = await launch({ 'executablePath': r'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe', 'headless': False, 'args': ['--no-sandbox', '--window-size=1366,850'] }) page = await browser.newPage() await page.setViewport({'width':1366,'height':768}) await page.goto('http://202.38.93.111:10047/?token=&lt;your_token&gt;') await page.click('.img-fluid') captcha1 = await page.querySelectorEval('label[for=&quot;captcha1&quot;]', 'node =&gt; node.innerText') captcha2 = await page.querySelectorEval('label[for=&quot;captcha2&quot;]', 'node =&gt; node.innerText') captcha3 = await page.querySelectorEval('label[for=&quot;captcha3&quot;]', 'node =&gt; node.innerText') res1=eval(captcha1[:-5]) res2=eval(captcha2[:-5]) res3=eval(captcha3[:-5]) await page.type('#captcha1', str(res1)) await page.type('#captcha2', str(res2)) await page.type('#captcha3', str(res3)) await page.click('#submit') flag = await page.querySelectorEval('body &gt; div &gt; p:nth-child(4)', 'node =&gt; node.innerText') print(flag) await browser.close()asyncio.get_event_loop().run_until_complete(main()) 旅行照片2.0Level1 直接用在线网站就能看，但 EXIF 版本信息显示是 0231 ，结合题目提示，改成 2.31 就行。Level2 一开始谷歌和百度识图都出不来，然后发现识图的结果都是夕阳，于是把图片截去夕阳部分再谷歌识图，就能得到拍摄角度几乎一样但是白天的日本千叶市美滨区的海洋球场，然后找机场就找头疼了，放弃。在做复变函数的时候无意间发现 wolfram 可以通过看到飞机的地点和时间直接查询航班，但是是会员功能。 猜数字（未解出）写了个脚本暴猜一晚上没出，果然运气还是太差了。正解是 NaN ，不提。这里贴一下我爆破的脚本，供君一乐： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requests as rimport reurl = 'http://202.38.93.111:18000/state'cookie = '&lt;your_cookie&gt;'auth = '&lt;your_auth&gt;'def guess(num): data = f'&lt;state&gt;&lt;guess&gt;{num}&lt;/guess&gt;&lt;/state&gt;' r.post(url, headers={'Cookie': cookie, 'authorization': auth}, data=data) def check(): res = r.get(url, headers={'Cookie': cookie, 'authorization': auth}) resp = re.findall(r'&lt;guess less=&quot;(\\w+)&quot; more=&quot;(\\w+)&quot;&gt;(.*?)&lt;/guess&gt;', res.text) if not resp: return ('true', 'true', '0') return resp[0]def crack(n): guess(str(n/1000000)) less, more, num = check() # print(less, more, num) left = 0 right = 1000000 times = 1 while less != 'true' or more != 'true': times += 1 if less == 'true': left = float(num)*1000000 elif more == 'true': right = float(num)*1000000 else: break num = (left + right) // 2 tmp = num guess(str(num/1000000)) less, more, num = check() # print(less, more, num) return times, tmpif __name__ == '__main__': l = [500000] while True: # n = 500000*(len(l)+1) - sum(l) # n = min(n, 1000000) # n = max(n, 0) n = 1000000 - sum(l)//len(l) times, num = crack(n) l.append(int(num)) print(times, n, num, sum(l)//len(l)) if times == 1: break print('done') LaTeX机器人Level1 我的解法： 1\\newread\\myread \\openin\\myread=/flag1 \\read\\myread to \\fileline \\fileline{} Level2 打不通，但找到一个可以取消所有转义的函数 （但我忘了是什么）。 安全的在线测评我 Level1 的解法，但似乎预期是用编译器读？ 123456789101112131415#include &lt;stdio.h&gt;int main() { // read 2 lines from file char buf[400]; scanf(&quot;%s&quot;, buf); FILE *fp = fopen(&quot;./data/static.out&quot;, &quot;r&quot;); fgets(buf, 400, fp); printf(&quot;%s&quot;, buf); fgets(buf, 400, fp); printf(&quot;%s&quot;, buf); fclose(fp); return 0;} Flag自动机第一回正式打逆向，首先题目是一个恶作剧程序，就是不给点 狠心夺取 按钮，于是拖进 IDA 看到有 rand 函数，不难联想到按钮的新位置是通过这个函数产生的，于是再查看 rand 函数的调用，发现只有两处——分别是按钮的 X 坐标和 Y 坐标。然后我的解法是把汇编上把位置 patch 成 0 ，这样按钮就只刷新在左上角了。点击按钮后，弹出一个提示框——获取flag失败！您不是本机的“超级管理员”！ ，于是再次在 IDA 找到一个判断，若该变量不等于 114514 ，则弹出失败的提示框，这里在汇编把 jz patch 成 jnz 就行。最后成功获取 flag 。 杯窗鹅影Level1 我的解法如下： 1234567891011121314#include &lt;stdio.h&gt;// read file in /flag1int main(void) { FILE *fp = fopen(&quot;/flag1&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;open file failed&quot;); } char buf[0x100]; fgets(buf, 0x100, fp); printf(&quot;%s&quot;, buf); return 0;} 蒙特卡洛轮盘赌测试得出 clock() 的大小在 1000 左右，那么假定时间基本同步的情况下爆破 1000 次左右即可出结果。编译开 -O3 的情况下目测大约每秒 20 次，大约在 50s 内可出结果。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import subprocessimport timefrom pwn import *import os# compile the c programos.system('gcc -o setseed setseed.c -O3')def seedtores(seed): p = subprocess.run( ['./setseed', str(seed)], stdout=subprocess.PIPE, stderr=subprocess.STDOUT ) return (p.stdout.decode()).split()def crack(pi2, t): p1, p2 = pi2 while True: res = seedtores(t) print(res[0],res[1], res[2], end='\\r') if res[1] == p1 and res[2] == p2: return t, res else: t += 1now = int(time.time())print(now)r = remote('202.38.93.111', 10091)token = b'&lt;your_token&gt;'r.sendlineafter(b'token:', token)r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), b'0')r.recvuntil('正确答案是：'.encode())p1 = r.recvline().decode().strip()r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), b'0')r.recvuntil('正确答案是：'.encode())p2 = r.recvline().decode().strip()info('p1: %s, p2: %s', p1, p2)t, guess = crack((p1, p2), now)success('guess: %s', guess)r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), guess[3].encode())r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), guess[4].encode())r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), guess[5].encode())print(r.recvlines(3)) 其中 setseed.c 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;double rand01(){ return (double)rand() / RAND_MAX;}// let main receive a seedint main(int argc, char *argv[]){ // disable buffering setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); unsigned int seed = 1666610168+946; seed = atoi(argv[1]); printf(&quot;%u\\n&quot;,seed); srand(seed-1); int games = 5; int win = 0; int lose = 0; char target[20]; char guess[2000]; for (int i = games; i &gt; 0; i--) { int M = 0; int N = 400000; for (int j = 0; j &lt; N; j++) { double x = rand01(); double y = rand01(); if (x*x + y*y &lt; 1) M++; } double pi = (double)M / N * 4; sprintf(target, &quot;%1.5f&quot;, pi); printf(&quot;%1.5f\\n&quot;, pi); } return 0;} 置换魔群打通了，还行。置换群的概念题目已经说得很清楚了，这里不再赘述。Level1 是生成一个置换群 $A_n$ ，并给出 $x^e$ 和 $e=66537$ ，求群 $A_n$ 的元素 $x$ 。那么这就很类似 RSA 了，首先 RSA 的解密原理是，对于模 $n$ 群，对其中的任意元素 $x$ ，都有 $x^{\\varphi(n)}\\equiv1\\mod n$ ，这里的$\\varphi(n)$称为群的阶。所以 $m^{ed}\\equiv m^{k\\varphi(n)+1}\\equiv (m^{\\varphi})^km\\equiv m\\mod n$ 。（srds，这竟然是我在做这道题的时候推公式想明白的）那么回到这个题就很简单了，只需求出 $A_n$ 的阶，然后取 $e$ 模 $A_n$ 阶的逆元就能得到解密指数 $d$ 了。题目给了简陋的求群的阶的函数，但速度比较慢，用 sagemath 实现了一下，快了很多。关键代码如下： 12345def solve(n, c, e=65537): S = SymmetricGroup(n) d = pow(e, -1, S.order()) res = S(c) ** int(d) return str(list(res.tuple())) # 这里应该有更优雅的写法 Level2 同样生成一个置换群 $A_n$ ，给出一个元素 $g$ 和 $g^y$ ，要求 $y$ 。那么这就是一个离散对数问题了，用 sagemath 的 discrete_log 函数就能解决。当然如果你和我一样不知道 sagemath 的置换群用的哪个函数，可以使用万能的 copilot 直接先敲一行注释，然后回车按tab 。关键代码如下：（只有两行，乐） 123def solve(g, y, n): S = SymmetricGroup(n) return discrete_log(S(y), S(g)) Level3 同样是离散对数问题，允许输入两个元素 $g_1$ 和 $g_2$ ，然后给出 $g_1^m$ 和 $g_2^m$ ，要求 $m$ 。上面提到了群的阶，这里引入元素的阶的概念：比如模 $5$ 的群中，群的阶为 $\\varphi(5)=4$ ，也就是说 $1^4\\equiv2^4\\equiv3^4\\equiv4^4\\equiv5\\mod 5$ ，但是我们发现， $1^1 \\mod1$ 就已经是 $1$ 了， $4^2\\mod 5$ 也一样不需要达到 $4$ 次方就到 $1$ ，这里我们称最小的 $k$ 使元素 $x$ 满足 $x^k\\equiv1\\mod n$ 为元素 $x$ 的阶，也就是说如上的例子中 $1$ 的阶为 $1$ ， $4$ 的阶为 $2$ 。现在回到题目，我们发现难点在于要求的 $m$ 是比较大的，记 $g_1$ 和 $g_2$ 的阶分别为 $a$ 和 $b$ ，容易知道我们求离散对数得到的只是 $m_1\\equiv m\\mod a$ 和 $m_2\\equiv m\\mod b$ ，由中国剩余定理可知最后求出的 $m’\\equiv m\\mod \\mathrm{lcm}(a,b)$ ，也就是说，我们构造的 $g_1$ 和 $g_2$ 的阶的最小公倍数需要足够大才能得到 $m$ 。 然后不难搜得求置换群元素的阶最大的问题可以转化成求一组数的和不超过 $n$ ，如果使这组数的最小公倍数最大的问题。显然这组数应该是互质的，但这并不意味着这组数要全为质数！比如 $n=7$ 时，我们可以得到 $3\\times4$ 是最大的， $3$ 和 $4$ 互质，但 $4$ 不是质数。如此我们可以手推几个，然后在数列网站 OEIS 上搜索得到数列A000793，关于这个数列的介绍为 Landau's function g(n): largest order of permutation of n elements. Equivalently, largest LCM of partitions of n.显然这正是我们要找的，于是复制下面给出的代码就可以生成 $g_1$ 了，而对于 $g_2$ ，我的做法是拿到 $g_2$ 中最大数后面的素数列填充进去，若不能继续填充且空间还有剩余，则使最后两个素数尽可能大且尽可能相近。最后我的蹩脚算法得出来的界大部分比题目的界要大，有小部分小 $1/10$ 左右，基本上都能大过 $m$ 。 贴一下完整的垃圾代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from pwn import *from sage.all import *from sympy import primerange, prevprimep = remote(&quot;202.38.93 .111&quot;, 10114)# context.log_level = &quot;debug&quot;token = &lt;your_token&gt;p.sendlineafter(b&quot;token: &quot;, token.encode())p.sendlineafter(b&quot;&gt; your choice: &quot;, b&quot;3&quot;)def n2perm(l): ll = [] i = 1 for x in l: ll.append(tuple(range(i, i+x))) i += x return lldef aupton(N): # compute terms a(0)..a(N) V = [1 for _ in range(N+1)] for i in primerange(2, N+1): for j in range(N, i-1, -1): hi = V[j] pp = i while pp &lt;= j: hi = max((pp if j == pp else V[j-pp]*pp), hi) pp *= i V[j] = hi return Vdef get_fac(n): prod = data[n - 1] f = factor(prod) f_ = str(f).split('*') fl = [] for i in f_: if '^' in i: fl.append(eval(i.replace('^', '**'))) else: fl.append(int(i)) return fldef get_fac2(n, fl1_prod): fl2 = [] i = 2 while sum(fl2) &lt; n: if gcd(i, fl1_prod) == 1: fl2.append(i) i += 1 if sum(fl2) &gt; n: fl2.pop() fl2.pop() fl2.append(prevprime(n - sum(fl2))) return fl2def get_n2l(n): l1 = get_fac(n) l2 = get_fac2(n, prod(l1)) return n2perm(l1), n2perm(l2)def get_n(): p.recvuntil(b'[+] DH public key: n = ') n = int(p.recvline()[:-1].decode()) return ndef get_bound(): p.recvuntil(b'[+] The upper bound for my private key is ') bound = int(p.recvline()[:-1].decode()) return bounddef get_pub(g): p.sendlineafter(b'(a list): ',g.encode()) p.recvuntil(b' : ') y = eval(p.recvline()[:-1].decode()) return yfor i in range(15): n = get_n() bound = get_bound() info(f&quot; n = {n}&quot;) info(f&quot;bound = {bound}&quot;) S = SymmetricGroup(n) data = aupton(2000) g,g_ = get_n2l(n) g1, g2 = S(g), S(g_) opt = lcm(g1.order(), g2.order()) info(f&quot; opt = {opt}&quot;) if opt &lt; bound: warning(&quot;opt &lt; bound&quot;) pub1 = get_pub(str(list(g1.tuple()))) pub2 = get_pub(str(list(g2.tuple()))) pub1, pub2 = S(pub1), S(pub2) m1, m2 = discrete_log(pub1,g1), discrete_log(pub2,g2) # success(f&quot;m1 = {m1}\\nm2 = {m2}&quot;) m = crt([m1,m2],[g1.order(),g2.order()]) success(f&quot; m = {m}&quot;) p.sendlineafter(b'&gt; your answer: ', str(m).encode()) res = p.recvline().decode() assert res == 'Good job\\n', resprint(p.recvline().decode()) 矩阵之困（未解出）开赛做完签到后看的第一题，结果最后也成为本场比赛最难的 1 解题（表面看起来是 2 解，但其实两个号都是 mcfx），不得不说我眼光真好（）查到三向量内积可表示成 $a^TBc$ ，其中 $B$ 的对角线为 $b$ ，但似乎没什么用。用z3梭了几天出不来，放弃。 片上系统（未解出）发现 pulseview 还挺有意思。 量子藏宝图挺有意思的，一直只研究后量子密码学，却没看过量子密码，正好补充知识。 企鹅拼盘Level1 手试即可，结果为 1000 。 火眼金睛的小ELevel1 直接装个 bindiff 人工比对，但是正确率不太高，需要多试几次，有时甚至 bindiff 连函数都没检测出来。。。","link":"/2022/10/30/Hackergame2022-writeups/"},{"title":"NTRUEncrypt","text":"NTRUEncrypt 公钥加密系统 简介这里基本摘自维基百科，少少枯燥，可以自行选择略读。 NTRUEncrypt 是一个公钥加密系统，它的安全性基于这样一个问题的困难性：在一个截断多项式环（这个翻译怪怪的）中将一个给定的多项式分解成两个系数非常小的多项式的商。由于加密与解密都只涉及简单的多项式乘法，故相比于其他的加密系统， NTRUEncrypt 的效率会更高。具体来说， NTRU 的操作基于截断多项式环中的对象 ${\\displaystyle \\ R=\\mathbb {Z} [X]/(X^{N}-1)}$ 中的卷积乘法，并且环上的所有多项式的系数和次数都为不大于 $N-1$ 的整数。实际上， NTRU 是一个参数化系统，每个系统由三个整数指定 $(N,p,q)$ ，其中 $N$ 代表截断环上的所有多项式的最高次为 $N-1$ ， $p$ 和 $q$ 分别代表一个小模数和一个大模数。其中 $N$ 为素数， $q$ 大于 $p$ ，且 $p$ 与 $q$ 互质。由这三个参数生成四个多项式 $\\mathcal {L}_f,\\mathcal {L}_g,\\mathcal {L}_m \\thinspace$ 和 $\\mathcal {L}_r$ ，分别为私钥、公钥、消息和干扰数。 看到这里，我相信懂的人都懂的，不懂的人还不懂（bushi）下面从宏观和微观两方面详细解释 公钥生成又双叒叕来到了密码学的老 CP —— Alice 和 Bob Bob 根据选定的 $N,p,q$ 生成最高次为 $N-1$ 的 $f$ 和 $g$ 两个多项式，并且系数在 ${-1,0,1}$ 中选取（可以认为这俩是在模 $X^{N}-1$ 的剩余类中）。 $f$ 还要满足模 $q$ 和 $p$ 的逆元存在，如果不满足，那就重新生成。 分别计算 $f$ 模 $p$ 和模 $q$ 的逆元，即 $f_{p}$ 和 $f_{q}$ ，保留 $f$ , $f_{p}$ 及 $g$ 作为私钥，公钥 $h=pf_{q} \\cdot g\\ \\pmod{q} $ 。 sagemath 代码如下 123456789101112131415161718192021222324252627282930313233def generate_keys(): ''' 基于提供的参数生成一个公私钥对 返回 f (私钥)和 F_p (公钥)''' # 校验 if validate_params(): while True: try: # 生成两个随机多项式 f 和 g ，并且非零系数小于给定的 d f = generate_polynomial(d) g = generate_polynomial(d) # 假定 q 是 2 的幂，求得 f 模 q 的逆元 f_q = invertmodpowerof2(f,q) # 同样假定 p 是素数，求得 f 模 p 的逆元 f_p = invertmodprime(f,p) break except: # 上面如果抛出异常，即逆元不存在，则重新生成 pass # 公钥 h=pf_p*g (mod q) public_key = balancedmod(p * convolution(f_q,g),q) # 保留 f 和 f_p 作为私钥 secret_key = f,f_p return public_key,secret_key else: print(&quot;Provided params are not correct. q and p should be co-prime, q should be a power of 2 considerably larger than p and p should be prime.&quot;) 加密Alice 将消息 $m$ 转化成一个系数在 ${-1,0,1}$ 之间的多项式（比如转成二进制或三进制，二进制在这里会有些浪费），再随机生成一个系数较小（但不限于 ${-1,0,1}$ 中）的多项式 $r$ 作为干扰以掩盖消息。那么加密计算如下：$$ e=r \\cdot h+m \\pmod{q}$$举个栗子：当取 $N=5,p=3,q=32$ 时（呃这里待更新）$$ f=-1+X+X^2$$ 123456789101112131415def generate_message(): ''' 随机生成一个系数在{-1,0,1}中的多项式''' result = list(randrange(3) - 1 for _ in range(N)) return Zx(result)def encrypt(message, public_key): ''' 基于提供的公钥加密消息''' # 生成一个随机多项式，并且非零系数小于给定的d，作为干扰以掩盖消息 r = generate_polynomial(d) # 加密：e = r * h + m (mod q) # while performing modulo operation, balance coefficients of encrypted_message # for the integers in interval [-q/2, +q/2] return balancedmod(convolution(public_key,r) + message,q) 解密由于其他人不知道 $r$ ，所以无法直接 $m=e-rh$ ，但 Bob 拿到 $e$ 后，可以计算出$$\\begin{equation*}\\begin{split} a &amp; = f \\cdot e \\pmod{q}\\\\ &amp; = f \\cdot (r \\cdot h+m) \\pmod{q}\\\\ &amp; = f \\cdot (r \\cdot pf_{q} \\cdot g+m) \\pmod{q}\\\\ &amp; = pr \\cdot g + f \\cdot m \\pmod{q}\\end{split}\\end{equation*}$$关键部分来了，以上都是在模 $q$ 下进行，而这时忽然就变成了模 $p$$$b=a=f \\cdot m \\pmod{p} \\\\c=f_{p} \\cdot b =f_{p} \\cdot f \\cdot m =m \\pmod{p}$$ 1234567891011def decrypt(encrypted_message, secret_key): ''' 基于提供的私钥解密密文''' # 拿到私钥的两个多项式 f,f_p = secret_key # a = f * e (mod p) a = balancedmod(convolution(encrypted_message,f),q) # c = f_p * a (mod p) return balancedmod(convolution(a,f_p),p) 函数实现下面从微观上解释一下上面函数的实现： 卷积多项式卷积满足公式$$ a(x)*b(x) = c(x) \\ with \\ c_k = \\sum_{i+j=k \\pmod} a_i b_{k-i \\pmod{N}}$$举个栗子：$$ f(x)=-1+4x+x^2 \\\\ g(x)=3-x+5x^2$$注意此时多项式和级数类似，采用低次项在先的书写方式则$$ f(x)*g(x) = c(x) \\pmod{3}$$其中$$c_0 = \\sum_{i+j=0 \\pmod{N}} f_i g_{0-i} = f_0g_0 + f_1g_2 + f_2g_1 = -1 \\times 3 + 4 \\times 5 + 1 \\times (-1) = -3 + 20 + (-1) = 16 \\\\c_1 = f_0g_1 + f_1g_0 + f_2g_2 = -1 \\times (-1) + 4 \\times 3 + 1 \\times 5 = 1 + 12 + 5 = 18 \\\\c_2 = f_0g_2 + f_1g_1 + f_2g_0 = -1 \\times 5 + 4 \\times (-1) + 1 \\times 3 = -5 + (-4) + 3 = -6$$故$$c(x) = 16 + 18x - 6x^2$$代码如下： 1234def convolution(f,g): ''' 多项式卷积运算''' return (f * g) % (x^N-1) 取模这里将多项式的每个系数 $f_i$ 拿出来，然后作变换 $g_i=(f_i+q/2)%q-q/2$ 再塞回去。这样每个系数都在 $[-q/2,q/2]$ 之间，这样可以保证模 $q$ 的运算。比如取 $q=3$ 时，有以下映射关系：$$-3 \\rightarrow (-3+1)%3 -1 = 0 \\\\-2 \\rightarrow (-2+1)%3 -1 = 1 \\\\-1 \\rightarrow (-1+1)%3 -1 = -1 \\\\0 \\rightarrow (0+1)%3-1 = 0 \\\\1 \\rightarrow (1+1)%3-1 = 1 \\\\2 \\rightarrow (2+1)%3-1 = -1 \\\\3 \\rightarrow (3+1)%3-1 = 0$$代码如下： 12345def balancedmod(f,q): ''' 多项式取模''' g = list(((f[i] + q//2) % q) - q//2 for i in range(N)) return Zx(g) 求逆元这也是我比较疑惑的一部分，一直不知道多项式的逆元具体怎么求，现在也看开了，随便怎么样吧，反正不是我手写（）这里先变基到 $X^N-1$ 商环然后求逆元再 lift 到整环上，关于原理我至今有点异或，有缘回来补坑吧。代码如下： 12345678910111213141516171819def invertmodprime(f,p): ''' 假定 p 为素数,计算一个多项式模 x^N-1 下的逆元再模 p 返回一个 Zx 上的多项式 h 满足 h 与 f 卷积模 p 为 1 不存在逆元时会抛出异常''' T = Zx.change_ring(Integers(p)).quotient(x^N-1) return Zx(lift(1 / T(f)))def invertmodpowerof2(f,q): ''' 假定 q 为 2 的幂，计算一个多项式模 x^N-1 下的逆元再模 q 返回一个 Zx 上的多项式 h 满足 h 与 f 卷积模 q 为 1 不存在逆元时会抛出异常''' assert q.is_power_of(2) # 断言 q 是 2 的幂 h = invertmodprime(f,2) # 首先求 f 模 2 的逆元 while True: r = balancedmod(convolution(h,f),q) # 计算 r = h * f (mod q) if r == 1: return h # 若 h * f = 1 (mod q)，则返回 h 即为所求逆元 h = balancedmod(convolution(h,2 - r),q) # 否则，h = h * (2 - r) (mod q) 攻击格约化攻击是一种非常著名的针对 NTRUEncrypt 的攻击，类似于 RSA 分解质因数。当选取的 $N$ 较小时，可以构造维度较低的格分解公钥 $h$ 。 例题 SCTF2020-Lattice12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from base64 import b16encodeZx.&lt;x&gt; = ZZ[]n = 109 q = 2048p = 3Df = 9Dg = 10Dr = 11def mul(f,g): return (f * g) % (x^n-1)def bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g)def random_poly(d): assert d &lt;= n result = n*[0] for j in range(d): while True: r = randrange(n) if not result[r]: break result[r] = 1-2*randrange(2) return Zx(result)def inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))def inv_mod_powerof2(f,q): assert q.is_power_of(2) g = inv_mod_prime(f,2) while True: r = bal_mod(mul(g,f),q) if r == 1: return g g = bal_mod(mul(g,2 - r),q)def keygen(): f = random_poly(Df) while True: try: fp = inv_mod_prime(f,p) fq = inv_mod_powerof2(f,q) break except: f = random_poly(Df) g = random_poly(Dg) h = bal_mod(p * mul(fq,g),q) pub_key = h pri_key = [f,fp] return pub_key,pri_keydef encrypt(m,h): r = random_poly(Dr) e = bal_mod(mul(h,r) + m,q) return eif __name__ == '__main__': pub_key,pri_key = keygen() flag=b'SCTF{***********}'[5:-1] m = Zx(list(bin(int(b16encode(flag), 16))[2:])) print(m) e = encrypt(m,pub_key) print('pub_key=') print(pub_key) print('e=') print(e)# pub_key=# 510*x^108 - 840*x^107 - 926*x^106 - 717*x^105 - 374*x^104 - 986*x^103 + 488*x^102 + 119*x^101 - 247*x^100 + 34*x^99 + 751*x^98 - 44*x^97 - 257*x^96 - 749*x^95 + 648*x^94 - 280*x^93 - 585*x^92 - 347*x^91 + 357*x^90 - 451*x^89 - 15*x^88 + 638*x^87 - 624*x^86 - 458*x^85 + 216*x^84 + 36*x^83 - 199*x^82 - 655*x^81 + 258*x^80 + 845*x^79 + 490*x^78 - 272*x^77 + 279*x^76 + 101*x^75 - 580*x^74 - 461*x^73 - 614*x^72 - 171*x^71 - 1012*x^70 + 71*x^69 - 579*x^68 + 290*x^67 + 597*x^66 + 841*x^65 + 35*x^64 - 545*x^63 + 575*x^62 - 665*x^61 + 304*x^60 - 900*x^59 + 428*x^58 - 992*x^57 - 241*x^56 + 953*x^55 - 784*x^54 - 730*x^53 - 317*x^52 + 108*x^51 + 180*x^50 - 881*x^49 - 943*x^48 + 413*x^47 - 898*x^46 + 453*x^45 - 407*x^44 + 153*x^43 - 932*x^42 + 262*x^41 + 874*x^40 - 7*x^39 - 364*x^38 + 98*x^37 - 130*x^36 + 942*x^35 - 845*x^34 - 890*x^33 + 558*x^32 - 791*x^31 - 654*x^30 - 733*x^29 - 171*x^28 - 182*x^27 + 644*x^26 - 18*x^25 + 776*x^24 + 845*x^23 - 675*x^22 - 741*x^21 - 352*x^20 - 143*x^19 - 351*x^18 - 158*x^17 + 671*x^16 + 609*x^15 - 34*x^14 + 811*x^13 - 674*x^12 + 595*x^11 - 1005*x^10 + 855*x^9 + 831*x^8 + 768*x^7 + 133*x^6 - 436*x^5 + 1016*x^4 + 403*x^3 + 904*x^2 + 874*x + 248# e=# -453*x^108 - 304*x^107 - 380*x^106 - 7*x^105 - 657*x^104 - 988*x^103 + 219*x^102 - 167*x^101 - 473*x^100 + 63*x^99 - 60*x^98 + 1014*x^97 - 874*x^96 - 846*x^95 + 604*x^94 - 649*x^93 + 18*x^92 - 458*x^91 + 689*x^90 + 80*x^89 - 439*x^88 + 968*x^87 - 834*x^86 - 967*x^85 - 784*x^84 + 496*x^83 - 883*x^82 + 971*x^81 - 242*x^80 + 956*x^79 - 832*x^78 - 587*x^77 + 525*x^76 + 87*x^75 + 464*x^74 + 661*x^73 - 36*x^72 - 14*x^71 + 940*x^70 - 16*x^69 - 277*x^68 + 899*x^67 - 390*x^66 + 441*x^65 + 246*x^64 + 267*x^63 - 395*x^62 + 185*x^61 + 221*x^60 + 466*x^59 + 249*x^58 + 813*x^57 + 116*x^56 - 100*x^55 + 109*x^54 + 579*x^53 + 151*x^52 + 194*x^51 + 364*x^50 - 413*x^49 + 614*x^48 + 367*x^47 + 758*x^46 + 460*x^45 + 162*x^44 + 837*x^43 + 903*x^42 + 896*x^41 - 747*x^40 + 410*x^39 - 928*x^38 - 230*x^37 + 465*x^36 - 496*x^35 - 568*x^34 + 30*x^33 - 158*x^32 + 687*x^31 - 284*x^30 + 794*x^29 - 606*x^28 + 705*x^27 - 37*x^26 + 926*x^25 - 602*x^24 - 442*x^23 - 523*x^22 - 260*x^21 + 530*x^20 - 796*x^19 + 443*x^18 + 902*x^17 - 210*x^16 + 926*x^15 + 785*x^14 + 440*x^13 - 572*x^12 - 268*x^11 - 217*x^10 + 26*x^9 + 866*x^8 + 19*x^7 + 778*x^6 + 923*x^5 - 197*x^4 - 446*x^3 - 202*x^2 - 353*x - 852 显然函数和上面的基本一样，只是名称相应地缩短了一下。攻击方法是构造如下的一个格，然后进行规约$$\\left(\\begin{array}{cccc|cccc}\\lambda &amp; 0 &amp; \\cdots &amp; 0 &amp; h_0 &amp; h_1 &amp; \\cdots &amp; h_{N-1} \\\\0 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; h_{N-1} &amp; h_0 &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; \\lambda &amp; h_1 &amp; h_2 &amp; \\cdots &amp; h_0 \\\\ \\hline0 &amp; 0 &amp; \\cdots &amp; 0 &amp; q &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; q &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; q\\end{array}\\right)$$具体可以参考这篇 Paper: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.578.5423&amp;rep=rep1&amp;type=pdf取 $\\lambda=1$ ，规约后最短向量即为 $[f\\enspace g]$ ，然后就可以计算私钥解密了。exp 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from Crypto.Util.number import *import timestart = time.time()Zx.&lt;x&gt; = ZZ[]n = 109 q = 2048p = 3Df = 9Dg = 10Dr = 11h=510*x^108 - 840*x^107 - 926*x^106 - 717*x^105 - 374*x^104 - 986*x^103 + 488*x^102 + 119*x^101 - 247*x^100 + 34*x^99 + 751*x^98 - 44*x^97 - 257*x^96 - 749*x^95 + 648*x^94 - 280*x^93 - 585*x^92 - 347*x^91 + 357*x^90 - 451*x^89 - 15*x^88 + 638*x^87 - 624*x^86 - 458*x^85 + 216*x^84 + 36*x^83 - 199*x^82 - 655*x^81 + 258*x^80 + 845*x^79 + 490*x^78 - 272*x^77 + 279*x^76 + 101*x^75 - 580*x^74 - 461*x^73 - 614*x^72 - 171*x^71 - 1012*x^70 + 71*x^69 - 579*x^68 + 290*x^67 + 597*x^66 + 841*x^65 + 35*x^64 - 545*x^63 + 575*x^62 - 665*x^61 + 304*x^60 - 900*x^59 + 428*x^58 - 992*x^57 - 241*x^56 + 953*x^55 - 784*x^54 - 730*x^53 - 317*x^52 + 108*x^51 + 180*x^50 - 881*x^49 - 943*x^48 + 413*x^47 - 898*x^46 + 453*x^45 - 407*x^44 + 153*x^43 - 932*x^42 + 262*x^41 + 874*x^40 - 7*x^39 - 364*x^38 + 98*x^37 - 130*x^36 + 942*x^35 - 845*x^34 - 890*x^33 + 558*x^32 - 791*x^31 - 654*x^30 - 733*x^29 - 171*x^28 - 182*x^27 + 644*x^26 - 18*x^25 + 776*x^24 + 845*x^23 - 675*x^22 - 741*x^21 - 352*x^20 - 143*x^19 - 351*x^18 - 158*x^17 + 671*x^16 + 609*x^15 - 34*x^14 + 811*x^13 - 674*x^12 + 595*x^11 - 1005*x^10 + 855*x^9 + 831*x^8 + 768*x^7 + 133*x^6 - 436*x^5 + 1016*x^4 + 403*x^3 + 904*x^2 + 874*x + 248e=-453*x^108 - 304*x^107 - 380*x^106 - 7*x^105 - 657*x^104 - 988*x^103 + 219*x^102 - 167*x^101 - 473*x^100 + 63*x^99 - 60*x^98 + 1014*x^97 - 874*x^96 - 846*x^95 + 604*x^94 - 649*x^93 + 18*x^92 - 458*x^91 + 689*x^90 + 80*x^89 - 439*x^88 + 968*x^87 - 834*x^86 - 967*x^85 - 784*x^84 + 496*x^83 - 883*x^82 + 971*x^81 - 242*x^80 + 956*x^79 - 832*x^78 - 587*x^77 + 525*x^76 + 87*x^75 + 464*x^74 + 661*x^73 - 36*x^72 - 14*x^71 + 940*x^70 - 16*x^69 - 277*x^68 + 899*x^67 - 390*x^66 + 441*x^65 + 246*x^64 + 267*x^63 - 395*x^62 + 185*x^61 + 221*x^60 + 466*x^59 + 249*x^58 + 813*x^57 + 116*x^56 - 100*x^55 + 109*x^54 + 579*x^53 + 151*x^52 + 194*x^51 + 364*x^50 - 413*x^49 + 614*x^48 + 367*x^47 + 758*x^46 + 460*x^45 + 162*x^44 + 837*x^43 + 903*x^42 + 896*x^41 - 747*x^40 + 410*x^39 - 928*x^38 - 230*x^37 + 465*x^36 - 496*x^35 - 568*x^34 + 30*x^33 - 158*x^32 + 687*x^31 - 284*x^30 + 794*x^29 - 606*x^28 + 705*x^27 - 37*x^26 + 926*x^25 - 602*x^24 - 442*x^23 - 523*x^22 - 260*x^21 + 530*x^20 - 796*x^19 + 443*x^18 + 902*x^17 - 210*x^16 + 926*x^15 + 785*x^14 + 440*x^13 - 572*x^12 - 268*x^11 - 217*x^10 + 26*x^9 + 866*x^8 + 19*x^7 + 778*x^6 + 923*x^5 - 197*x^4 - 446*x^3 - 202*x^2 - 353*x - 852def mul(f,g): return (f * g) % (x^n-1)def decrypt(pri_key,e): f,fp = pri_key a = bal_mod(mul(f,e),q) b = bal_mod(mul(a,fp),p) pt = ''.join([str(i) for i in b.list()]) return ptdef bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g)def lattice(h,q): n = 109 # h = bal_mod(683*h,q) grid = Matrix(ZZ,2*n,2*n) cof = h.list() offset = 0 for i in range(2*n): for j in range(2*n): if i&lt;n: if j &lt; n: if i==j: grid[i,j] = 1 else: grid[i,j] = cof[(j-n-offset)%n] elif j&gt;=n and i==j: grid[i,j] = q offset += 1 GL = grid.BKZ() return GL,griddef inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))GL,grid = lattice(h,q)SVP = list(GL[0])f = Zx(SVP[:n])g = Zx(SVP[-n:])a = bal_mod(mul(f,e),q)fp = inv_mod_prime(f,p)pv = (f,fp)print(decrypt(pv,e))flag = int(decrypt(pv,e)+'0'*6,2)print(flag)print(long_to_bytes(flag))end = time.time()print(end-start) 勘误维基百科中说 $m$ 转化成系数在 $[-p/2,p/2]$ 间多项式，实际应为 ${-1,0,1}$ 间。代码中加密函数原为return balancedmod(convolution(public_key,p*r) + message,q)，一般版本中的公钥是没乘 $p$ 的，在加密中才乘，但这里公钥已经乘过 $p$ 了，就可以删去。实测不删去也可正常解密，推测应该是在后面取模时消去了，读者可自行推导。 参考https://en.wikipedia.org/wiki/NTRUEncrypthttps://github.com/joannawetesko/NTRU-cryptosystem/blob/master/NTRU.sagehttps://blog.csdn.net/sinat_36742186/article/details/83689529","link":"/2022/04/11/NTRUEncrypt/"},{"title":"复变函数笔记","text":"高数写了笔记再考试效果挺好的 （为什么挂科之前没这觉悟啊），复变也记一下吧。 复数与复变函数复数及其运算通常记复数为 $z=x+\\mathrm{i}y$ ，其中实部与虚部记作$$x=\\mathrm{Re}(z),\\quad y=\\mathrm{Im}(z)$$显然$$\\mathrm{Re}(z)=\\frac{z+\\overline{z}}{2},\\quad \\mathrm{Im}(z)=\\frac{z-\\overline{z}}{2\\mathrm{i}}$$以正实轴为始边，以 $z(z\\neq 0)$ 所对应的向量为终边的角称为复数 $z$ 的辐角，记作 $\\mathrm{Arg}\\ z$ ，把在 $(-\\pi,\\pi]$ 之间的辐角称为 $z$ 的主辐角（或主值或者叫辐角主值），记作 $\\mathrm{arg}\\ z$ 。有个重要点就是辐角要注意正负。 以及大名鼎鼎的欧拉公式：$$e^{\\mathrm{i}\\theta}=\\cos\\theta+\\mathrm{i}\\sin\\theta$$ 一个没什么名但是很有用的公式——棣莫弗公式：$$z^n = \\cos n\\theta + \\mathrm{i}\\sin n\\theta$$ 复数的开方复数开方时，开几次方就有几个结果。求 $w=\\sqrt[n]{z}$ 时，令 $w=\\rho e^{\\mathrm{i}\\varphi}$ ，从而 $\\rho^n e^{\\mathrm{i}n\\varphi} = z = re^{\\mathrm{i}\\theta}$ ，得到$$\\rho^n = r,\\quad n\\varphi = \\theta + 2k\\pi,\\quad k=0,\\pm1,\\pm2,\\cdots$$故$$\\rho = r^{1/n},\\quad \\varphi = \\frac{\\theta + 2k\\pi}{n}$$于是$$w = \\sqrt[n]{r}e^{\\mathrm{i}\\frac{\\theta + 2k\\pi}{n}}$$ 平面点集的一般概念和高数类似，没啥好说的。 复变函数似乎也没啥重要的（） 解析函数解析函数的概念与柯西-黎曼方程奇点：如果函数 $f(z)$ 在点 $z_0$ 不解析，则称 $z_0$ 为 $f(z)$ 的奇点。求有理分式的奇点时，直接取分母零点即可。 柯西-黎曼方程（C-R方程）：$$\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y},\\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}$$ 可导的充要条件： $u(x,y)$ 和 $v(x,y)$ 在点 $x,y$ 可微，且在该点满足C-R方程。 例 证明：柯西-黎曼方程的极坐标形式是$$\\frac{\\partial u}{\\partial r} = \\frac{1}{r}\\frac{\\partial v}{\\partial \\theta},\\quad \\frac{\\partial v}{\\partial r} = -\\frac{1}{r}\\frac{\\partial r}{\\partial \\theta}$$ 初等函数及其解析性指数函数 $z=x+\\mathrm{i}y$ 为任意复数，称 $w=e^z=e^x(\\cos y+\\mathrm{i}\\sin y)$ 为指数函数。 对数函数 满足方程 $e^w = z$ 的函数 $w=\\mathrm{Ln} \\ z$ 称为对数函数，且$$\\mathrm{Ln}\\ z = \\ln z + 2k\\pi\\mathrm{i} = \\ln|z| + \\mathrm{i}\\mathrm{arg}\\ z + 2k\\pi\\mathrm{i},\\quad k=0,\\pm1,\\pm2,\\cdots$$ 幂函数 $w=z^a=e^{a\\mathrm{Ln}\\ z}$ 为幂函数。 三角函数 称 $\\sin z = \\frac{e^{\\mathrm{i}z}-e^{-\\mathrm{i}z}}{2\\mathrm{i}}$ 为正弦函数， $\\cos z = \\frac{e^{\\mathrm{i}z}+e^{-\\mathrm{i}z}}{2}$ 为余弦函数。 双曲函数 称 $\\sinh z = \\frac{e^z-e^{-z}}{2}$ 为双曲正弦函数， $\\cosh z = \\frac{e^z+e^{-z}}{2}$ 为双曲余弦函数。 解析函数与调和函数的关系若实二元函数 $\\varphi(x,y)$ 在区域 $D$ 内具有二阶连续偏导数，且满足 $\\mathrm{Laplace}$ 方程$$\\frac{\\partial^2\\varphi}{\\partial x^2} + \\frac{\\partial^2\\varphi}{\\partial y^2} = 0$$则称 $\\varphi(x,y)$ 为区域 $D$ 的调和函数。 例 验证 $u(x,y)=x^3-3xy^2$ 为调和函数，并求以 $u(x,y)$ 为实部的解析函数 $f(z)$ ，使得 $f(\\mathrm{i}) = -\\mathrm{i}$ 。 解 $u_{xx}=6x$，$u_{yy}=-6y$，故 $u_{xx}+u_{yy}=0$， $u(x,y)$ 为调和函数。下面求虚部 $v(x,y)$ 。法一：偏积分法$$u_x = 3x^2-3y^2 = v_y \\Rightarrow v = \\int (3x^2-3y^2)\\mathrm{d}y = 3x^2y-y^3 + \\varphi(x) \\\\v_x = 6xy+\\varphi’(x) = -u_y = 6xy \\Rightarrow \\varphi(x) = C \\Rightarrow v(x,y) = 3x^2y - y^3 + C$$ 法二：全微分法$$v_y=u_x=3x^2-3y^2,v_x=-u_y=6xy\\\\\\Rightarrow \\mathrm{d}v = v_x’\\mathrm{d}x +v_y’\\mathrm{d}y=6xy\\mathrm{d}x + (3x^2-3y^2)\\mathrm{d}y\\\\\\Rightarrow v(x,y)=\\int_{(0,0)}^{(x,y)}6xy\\mathrm{d}x+(3x^2-3y^2)\\mathrm{d}y + C \\\\=\\int_0^x\\mathrm{d}x+\\int_0^y(3x^2-3y^2)\\mathrm{d}y + C = 3x^2y - y^3 + C$$ 最后代入 $f(\\mathrm{i})=-\\mathrm{i}$ 有 $f(z)=(x^3-3xy^2)+\\mathrm{i}(3x^2y-y^3)=z^3$ 。 复变函数的积分复变函数积分的概念例 计算 $I=\\oint_{\\mathit{\\Gamma}}\\frac{1}{(z-z_0)^n}\\mathrm{d}z$ ，其中 $\\mathit{\\Gamma}$ 为包含 $z_0$ 的一条闭曲线。解 以 $z_0$ 为圆心 $r$ 为半径作圆，则函数 $f(z)=\\frac{1}{(z-z_0)^n}$ 在 $\\overline{D}=D+\\mathit{\\Gamma}+C^-$上解析，因此$$I = \\oint_C\\frac{\\mathrm{d}z}{(z-z_0)^n}\\mathrm{d}z= \\begin{cases}2\\pi\\mathrm{i}, &amp; n = 0 \\\\0, &amp; n\\neq0\\end{cases}$$ 柯西积分定理设函数 $f(z)$ 在单连通域 $D$ 内解析， $\\mathit{\\Gamma}$ 为 $D$ 内的任意一条简单闭曲线，则有$$\\oint_{\\mathit{\\Gamma}}f(z)\\mathrm{d}z=0$$甚至也不用在$ \\mathit{\\Gamma}$ 上解析，在 $\\mathit{\\Gamma}$ 上连续就成立。 复合闭路定理设多连域 $D$ 的边界为 $C=C_0 + C_1^- + C_2^- + \\cdots + C_n^-$ ，函数 $f(z)$ 在 $D$ 内解析，在 $C$ 上连续，则$$\\oint_Cf(z)\\mathrm{d}z = 0$$或$$\\oint_{C_0}f(z)\\mathrm{d}z = \\sum_{k=1}^n\\oint_{C_k}f(z)\\mathrm{d}z$$ 柯西积分公式柯西积分公式 若函数 $f(z)$ 在简单正向闭曲线 $C$ 所围成的区域 $D$ 内解析，在区域 $D$ 的边界 $C$ 上连续， $z_0$ 是区域 $D$ 内任意一点，则$$f(z_0) = \\frac{1}{2\\pi\\mathrm{i}}\\oint_C\\frac{f(z)}{z-z_0}\\mathrm{d}z$$ 高阶求导公式 设 $f(z)$ 在 $D$ 内解析，在 $D$ 的边界 $C$ 上连续， $C$ 为正向简单闭曲线，则 $f^{(n)}(z)$ 在 $D$ 内解析，且有$$f^{(n)}(z_0)=\\frac{n!}{2\\pi\\mathrm{i}}\\oint_C\\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm{d}z, \\quad \\forall z_0\\in D, n=0,1,2,\\cdots$$ 解析函数的幂级数表示复级数的基本概念复数列收敛和一般的数列收敛定义类似，其充要条件为$$\\lim_{n\\to\\infty}a_n=a,\\quad \\lim_{n\\to\\infty}b_n=b$$所以判断级数收不收敛就拆成实部和虚部然后进行判断。 幂级数收敛半径 求法与高数类似，但多个根值法：（1）（比值法） $\\lim\\limits_{n\\to\\infty}\\left|\\frac{a_{n+1}}{a_n}\\right|=L$（2）（根值法） $\\lim\\limits_{n\\to\\infty}\\sqrt[n]{|a_n|}=L$则收敛半径 $R=\\frac{1}{L}$ 幂级数性质与高数也类似，可以逐项求导和逐项求积。 解析函数的泰勒展开与高数类似，不再赘述。 四个重要的已知展开$$\\frac{1}{1-z} = \\sum_{n=0}^\\infty z^n = 1+z+\\frac{z^2}{2}+\\frac{z^3}{3!}+\\cdots,\\enspace |z| &lt; 1 \\\\e^z = \\sum_{n=0}^\\infty \\frac{z^n}{n!} = 1+z+\\frac{z^2}{2!}+\\frac{z^3}{3!}+\\cdots,\\enspace |z| &lt; +\\infty \\\\\\sin z = \\sum_{n=0}^\\infty \\frac{(-1)^nz^{2n+1}}{(2n+1)!} = z-\\frac{z^3}{3!}+\\frac{z^5}{5!}-\\frac{z^7}{7!}+\\cdots,\\enspace |z| &lt; +\\infty \\\\\\cos z = \\sum_{n=0}^\\infty \\frac{(-1)^nz^{2n}}{(2n)!} = 1-\\frac{z^2}{2!}+\\frac{z^4}{4!}-\\frac{z^6}{6!}+\\cdots,\\enspace |z| &lt; +\\infty$$ 展开后注意标出收敛圆！ 洛朗级数泰勒展开有个缺陷，那就是只能展开到解析的地方，如果中间有个奇点卡住，那就不能再往外展开了。这个时候就用到洛朗级数，可以在圆环域展开，弥补泰勒展开的不足。 留数及其应用孤立奇点零点的判断首先很直白的， $f(z_0)=0$ ，那么 $z=z_0$ 就是 $f(z)$ 的零点。若 $f(z)=(z-z_0)^m\\varphi(z)$ ， $\\varphi(z)$ 在 $z_0$ 处解析且 $\\varphi(z_0)\\neq 0$ ，则 $z=z_0$ 是 $f(z)$ 的 $m$ 阶零点。 奇点类型的判断从定义上判断的话就先展开成洛朗级数，即设 $z_0$ 为 $f(z)$ 的孤立奇点，将 $f(z)$ 在 $0 &lt; |z-Z_0| &lt; \\delta$ 内洛朗展开为 $f(z)=\\sum\\limits_{n=0}^{+\\infty} a_n(z-z_0)^n$ 。 可去奇点：展开式中不含负幂次项，直观上看就是 $\\lim\\limits_{z\\to z_0}f(z)=C$ 。 $N$ 阶极点：含有限多的负幂次项，且最高负幂次为 $N$ ，直观上看就是 $\\lim\\limits_{z\\to z_0}f(z)=\\infty$。 本性奇点：含无穷多的负幂次项，直观上看就是 $\\lim\\limits_{z\\to z_0}f(z)$ 不存在且不为 $\\infty$ 。 留数留数的定义设 $z_0$ 为函数 $f(z)$ 的孤立奇点，将 $f(z)$ 在 $z_0$ 的去心邻域内展开成洛朗级数$$f(z) = \\sum_{n=-\\infty}^{+\\infty}a_n(z-z_0)^n = \\cdots + a_{-2}(z-z_0)^{-2} + a_{-1}(z-z_0)^{-1} + a_0 + a_1(z-z_0) + a_2(z-z_0)^2 + \\cdots$$称 $a_{-1}$ 为 $f(z)$ 在 $z_0$ 处的留数，记作$$\\mathrm{Res}[f(z),z_0]=a_{-1}=\\frac{1}{2\\pi i}\\oint\\limits_c f(z)\\mathrm{d}z$$其中 $C$ 是 $z_0$ 的去心邻域内绕 $z_0$ 的一条简单闭曲线。 留数的求解 $z_0$ 为可去奇点： $\\mathrm{Res}[f(z),z_0]=0$ 。 $z_0$ 为本性奇点：需要将$f(z)$在$z_0$的去心邻域内展开成洛朗级数 $z_0$ 为 $m$ 阶极点：$$\\mathrm{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{d^{m-1}}{dz^{m-1}}[(z-z_0)^mf(z)]$$ 无穷远处的留数若函数 $f(z)$ 在无穷远点 $\\infty$ 的去心领域 $R&lt;|f(z)|&lt;+\\infty$ 内解析，则称点 $\\infty$ 为 $f(z)$ 的孤立奇点。 设函数 $f(z)$ 在圆环域 $R&lt;|z|&lt;+\\infty$ 内解析，则 $f(z)$ 在 $\\infty$ 处的留数为：$$\\mathrm{Res}[f(z),\\infty]=\\frac{1}{2\\pi \\mathrm{i}}\\oint_{C^-}f(z)\\mathrm{d}z$$其中， $C$ 为 $|z|=\\rho &gt; R$ 。 $$\\mathrm{Res}[f(z), \\infty] = -\\mathrm{Res}[f(\\frac{1}{z})\\cdot\\frac{1}{z^2}, 0]$$ 利用留数计算实积分形如 $\\int_0^{2\\pi}R(\\cos\\theta,\\sin\\theta)\\mathrm{d}\\theta$ 的积分计算方法： 令 $z=e^{\\mathrm{i}\\theta}=\\cos\\theta+\\mathrm{i}\\sin\\theta$ ，则 $\\mathrm{d}\\theta=\\frac{\\mathrm{d}z}{\\mathrm{i}z}$ ， $\\cos\\theta=\\frac{z^2+1}{2z}$ ， $\\sin\\theta=\\frac{z^2-1}{2\\mathrm{i}z}$ 。 $\\int_0^{2\\pi}R(\\cos\\theta,\\sin\\theta)\\mathrm{d}\\theta=\\oint_{|z|=1}R\\left(\\frac{z^2+1}{2z},\\frac{z^2-1}{2\\mathrm{i}z}\\right)\\frac{1}{\\mathrm{i}z}\\mathrm{d}z=\\oint_{|z|=1}f(z)\\mathrm{d}z=2\\pi\\mathrm{i}\\sum\\limits_k \\mathrm{Res}[f(z),z_k]$ ，其中 $z_k$ 是 $f(z)$ 在 $|z|=1$ 内的孤立奇点。 形如 $\\int^{+\\infty}_{-\\infty}R(x)\\mathrm{d}x$ 的积分要求： $R(x)=\\frac{P(x)}{Q(x)}$ ，其中 $P(x)$ 和 $Q(x)$ 为多项式，且 $Q(x)$ 无实零点。 分母 $Q(x)$ 的次数比分子 $P(x)$ 的次数高 $2$ 或以上。 计算方法： $\\int^{+\\infty}_{-\\infty}R(x)\\mathrm{d}x=2\\pi\\mathrm{i}\\sum\\limits_k\\mathrm{Res}[R(z),z_k]$ ， 其中 $z_k$ 为 $R(z)$在上半平面内的孤立奇点。 例 求积分 $I=\\int_{-\\infty}^{+\\infty}\\frac{x^2-x+2}{x^4+10x^2+9}\\mathrm{d}x$ .解 首先显然分母零点均为虚数，且分母次数比分子高 $2$ ，故满足条件。 令 $$R(z)=\\frac{z^2-z+2}{z^4+10z^2+9}=\\frac{z^2-z+2}{(z^2+1)(z^2+9)}$$则上半平面内有一阶极点 $z_1=\\mathrm{i}$ 和 $z_2=3\\mathrm{i}$ 。 则$$\\begin{aligned}I&amp;=\\int_{-\\infty}^{+\\infty}\\frac{x^2-x+2}{x^4+10x^2+9}\\mathrm{d}x\\\\&amp;=2\\pi\\mathrm{i}\\sum\\limits_k\\mathrm{Res}[R(z),z_k] \\\\&amp;=2\\pi\\mathrm{i}\\left(\\mathrm{Res}[R(z),\\mathrm{i}]+\\mathrm{Res}[R(z),3\\mathrm{i}]\\right)\\\\&amp;=2\\pi\\mathrm{i}\\left(-\\frac{1+\\mathrm{i}}{16}+\\frac{3-7\\mathrm{i}}{48}\\right) = \\frac{5\\pi}{12}\\end{aligned}$$ 形如 $\\int^{+\\infty}_{-\\infty}R(x)e^{\\mathrm{i}ax}\\mathrm{d}x(a&gt;0)$ 的积分要求： $R(x)=\\frac{P(x)}{Q(x)}$ ，其中 $P(x)$ 和 $Q(x)$ 为多项式，且 $Q(x)$ 无实零点。 分母 $Q(x)$ 的次数比分子 $P(x)$ 的次数高 $1$ 或以上。 计算方法： $\\int^{+\\infty}_{-\\infty}R(x)e^{\\mathrm{i}ax}\\mathrm{d}x=2\\pi\\mathrm{i}\\sum\\limits_k\\mathrm{Res}[R(z)e^{\\mathrm{i}az},z_k]$ ， 其中 $z_k$ 为 $R(z)$在上半平面内的孤立奇点。 Fourier变换记得上一年的这个时候就对傅里叶变换有所接触了，然而时光荏苒，却一直没能有什么更深的理解，有些惭愧了。 Fourier 积分公式$$f(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\left[\\int_{-\\infty}^{+\\infty}f(t)e^{-\\mathrm{i}\\omega t} \\mathrm{d}t\\right]e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega$$这个式子有点奇怪，两边都有 $f(t)$ ，那我要来干嘛呢，这时你先别急，下面拆解一下就有意思了。 Fourier 变换上式中令 $F(\\omega)=\\int_{-\\infty}^{+\\infty}f(t)e^{-\\mathrm{i}\\omega t} \\mathrm{d}t$ ，则 $f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F(\\omega)e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega$ ，那么这个关于 $\\omega$ 的函数 $F(\\omega)$ 就是 $f(t)$ 的傅里叶变换。这样一来就可以粗略地理解为傅里叶变换就是把关于时间的函数转换为关于频率的函数，也就是所谓的时域转换为频域。 例 求矩形脉冲函数 $f(t)=\\begin{cases}1, &amp; |t|\\leq a\\\\0, &amp; |t|&gt; a\\end{cases}$ 的傅里叶变换及傅里叶积分表达式。 解 经典例题$$\\begin{aligned}F(\\omega)=\\mathscr{F}[f(t)]&amp;=\\int_{-\\infty}^{+\\infty}f(t)e^{-\\mathrm{i}\\omega t} \\mathrm{d}t\\\\&amp;=\\int_{-a}^{a}e^{-\\mathrm{i}\\omega t} \\mathrm{d}t\\\\&amp;=\\frac{1}{-\\mathrm{i}\\omega}\\left(e^{-\\mathrm{i}\\omega a}-e^{\\mathrm{i}\\omega a}\\right)\\\\&amp;=\\frac{2}{\\omega}\\cdot\\frac{e^{-\\mathrm{i}\\omega a}-e^{\\mathrm{i}\\omega a}}{-2\\mathrm{i}} \\\\&amp;= \\frac{2}{\\omega}\\cdot\\sin a\\omega\\end{aligned}$$再作傅里叶逆变换，即得傅里叶积分表达式$$\\begin{aligned}f(t)=\\mathscr{F}^{-1}[F(\\omega)]&amp;=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\frac{2\\sin a\\omega}{\\omega}e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega\\\\&amp;=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\frac{2\\sin a\\omega}{\\omega}\\cos\\omega t \\mathrm{d}\\omega + \\frac{\\mathrm{i}}{2\\pi}\\int_{-\\infty}^{+\\infty}\\frac{2\\sin a\\omega}{\\omega}\\sin\\omega t \\mathrm{d}\\omega\\\\&amp;=\\frac{1}{\\pi}\\int_{-\\infty}^{+\\infty}\\frac{\\sin a\\omega}{\\omega}\\cos\\omega t \\mathrm{d}\\omega \\\\&amp;=\\begin{cases}1, &amp; |t| &lt; a \\\\ 1/2, &amp; |t| = a \\\\ 0, &amp; |t| &gt; a\\end{cases}\\end{aligned}$$上式中令 $t=0$ ，可得重要积分公式$$\\int_{-\\infty}^{+\\infty}\\frac{\\sin ax}{x} \\mathrm{d}x=\\pi,\\quad (a&gt;0)$$ $\\delta$ 函数及其 Fourier 变换我们称满足如下条件的函数为 $\\delta$ 函数： 当 $t \\neq0$ 时， $\\delta(t)=0$ ； $\\int_{-\\infty}^{+\\infty}\\delta(t)\\mathrm{d}t = 1$可以看出，这是一个直观上矛盾的函数。书本上也说明了它不是一个经典意义上的函数，而是一个广义函数，有兴趣可以另行搜索。 $\\delta$ 函数有一个性质，就是对任意的连续函数 $f(t)$ ，都有$$\\int_{-\\infty}^{+\\infty}f(t)\\delta(t)\\mathrm{d}t = f(0)$$更一般地，若 $f(t)$ 在 $t=t_0$ 处连续，则$$\\int_{-\\infty}^{+\\infty}f(t)\\delta(t-t_0)\\mathrm{d}t = f(t_0)$$ 这是一个很好的筛选性质。同时其傅里叶变换也很有意思：$$F(\\omega) = \\mathscr{F}[\\delta(t)] = \\int_{-\\infty}^{+\\infty}\\delta(t)e^{-\\mathrm{i}\\omega t}\\mathrm{d}t = e^{-\\mathrm{i}\\omega t}|_{t=0} = 1 \\\\\\delta(t) = \\mathscr{F}^{-1}[1] = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega$$ Fourier 变换的性质Fourier 变换的卷积性质简单来说，就是$$f_1(t)*f_2(t) = \\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t-\\tau)\\mathrm{d}\\tau$$ Laplace 变换Laplace 变换的概念例 求指数函数 $f(t)=e^{kt} ,k \\in \\mathbb{R}$ 的 Laplace 变换。解 $$\\begin{aligned}F(s)&amp;=\\mathscr{L}[f(t)]\\\\&amp;=\\int_{0}^{\\infty}e^{kt}e^{-st}\\mathrm{d}t\\\\&amp;=\\frac{1}{s-k} \\quad, \\mathrm{Re}(s)&gt;k\\end{aligned}$$ 类似地， $f(t)=\\cos kt$ 的 Laplace 变换为 $F(s)=\\frac{s}{s^2+k^2}$ ， $f(t)=\\sin kt$ 的 Laplace 变换为 $F(s)=\\frac{k}{s^2+k^2}$ 。 Laplace 变换的性质$$\\mathscr{L}[f’(t)]=sF(s)-f(0) \\\\$$更一般地，有$$\\mathscr{L}[f^{(n)}(t)]=s^nF(s) - s^{n-1}f(0) - s^{n-2}f’(0) - \\cdots - f^{(n-1)}(0)$$ Laplace 逆变换例 求 $F(s)=\\frac{1}{s^2(s+1)}$ 的 Laplace 逆变换。解 函数 $F(s)$满足条件 $\\lim\\limits_{s \\to 0}F(s)=0$ ，且 $s=0$ 是 $F(s)$ 的二级极点， $s=-1$是 $F(s)$的一级极点，故$$\\begin{aligned}f(t) = \\mathscr{L}^{-1}[F(s)]&amp;= \\mathrm{Res}\\left[\\frac{e^{st}}{s^s(s+1)},0\\right] + \\mathrm{Res}\\left[\\frac{e^{st}}{s^s(s+1)},-1\\right] \\\\&amp;= (t-1) + e^{-t},\\quad t &gt; 0\\end{aligned}$$ 卷积Laplace 变换的应用例 求解微分方程 $y’’+\\omega^2y(t)=0, y(0)=0, y’(0)=\\omega$ 。 解 令 $Y(s)=\\mathscr{L}[y(t)]$ ，对方程两边取 Laplace 变换，得$$s^2Y(s)-sy(0)-y’(0)+\\omega^2Y(s)=0$$代入初值条件，得$$s^2Y(s)-\\omega+\\omega^2Y(s)=0 \\\\\\Rightarrow Y(s)=\\frac{\\omega}{s^2+\\omega^2}$$求逆变换，得$$\\begin{aligned}y(t)=\\mathscr{L}^{-1}\\left[\\frac{\\omega}{s^2+\\omega^2}\\right] &amp;= \\mathrm{Res}\\left[\\frac{we^{s\\mathrm{i}}}{s^2+w^2},w\\mathrm{i}\\right] + \\mathrm{Res}\\left[\\frac{we^{s\\mathrm{i}}}{s^2+w^2},-w\\mathrm{i}\\right] \\\\&amp;= \\lim_{s\\to w\\mathrm{i}}\\frac{we^{s\\mathrm{i}}}{(s^2+w^2)’} + \\lim_{s\\to -w\\mathrm{i}}\\frac{we^{s\\mathrm{i}}}{(s^2+w^2)’} \\\\&amp;=\\frac{we^w\\mathrm{i}t}{2w\\mathrm{i}}+\\frac{we^{-w\\mathrm{i}t}}{-2w\\mathrm{i}} \\\\&amp;=\\frac{2\\mathrm{i}\\sin wt}{2\\mathrm{i}}=\\sin wt\\end{aligned}$$","link":"/2022/10/09/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"材料力学笔记","text":"莫名其妙考了个第一，来还个愿。 最近买了台二手服务器，折腾了一些集群、容器、虚拟化之类的东西，比较偏操作也没啥好记的，就很长时间没更了。 这里大致记一下概念，捋一下思路。 绪论材料力学的任务使材料满足三个要求：强度、刚度、稳定性。 变形固体的基本假设三个假设：连续性、均匀性、各向同性。 变形与应变应变 $\\varepsilon$ 和切应变 $\\gamma$ 是度量一点处变形程度的两个基本量，量纲为一。 杆件变形的基本形式拉伸或压缩、剪切、弯曲、扭转。 拉伸、压缩与剪切直杆轴向拉伸或压缩时斜截面上的应力拉（压）杆的破坏并不总是沿横截面发生，有时沿斜截面发生。 设与横截面成 $\\alpha$ 角的斜截面 $k-k$ 的面积为 $A_\\alpha$，横截面的面积为 $A$，则$$A_\\alpha = \\frac{A}{\\cos\\alpha}$$ 把应力 $p_\\alpha$ 分解成垂直于斜截面的正应力 $\\sigma_\\alpha$ 和沿斜截面的剪应力 $\\tau_\\alpha$，则$$\\sigma_\\alpha = p_\\alpha\\cos\\alpha = \\sigma\\cos^2\\alpha \\\\\\tau_\\alpha = p_\\alpha\\sin\\alpha = \\sigma\\cos\\alpha\\sin\\alpha = \\frac{\\sigma}{2}\\sin2\\alpha$$ 当 $\\alpha = 0$ 时，$\\sigma_\\alpha$ 达到最大值，即$$\\sigma_{\\alpha \\mathrm{max}} = \\sigma$$ 材料拉伸时的力学性能低碳钢的力学性能大致如下： 弹性阶段：应力 $\\sigma$ 与应变 $\\varepsilon$ 成正比，即有 $\\sigma = E\\varepsilon$ ，$E$ 为弹性模量。直线最高点对应的应力 $\\sigma_\\mathrm{p}$ 称为比例极限，超过这个比例极限后，还有一个弹性极限，这两点间虽然不是直线，但松开后变形还是可以完全消失的，但两点非常接近，所以实际上不作严格区分。 屈服阶段：一段小锯齿，应变明显增加，应力先下降再小波动，先下降的那个最低点为屈服阶段或屈服强度，记作 $\\sigma_\\mathrm{s}$ 。 强化阶段：恢复抵抗变形能力，最高点对应应力 $\\sigma_\\mathrm{b}$ 为强度极限。 局部变形阶段：过强度极限后出现缩颈 铸铁在较小拉应力下就被拉断，没有屈服和缩颈现象，拉断前的应变也小，是典型的脆性材料。 材料压缩时的力学性能 什么？这不是饼干，这是一个压缩毛巾啊……（滑稽） 低碳钢压缩时的弹性模量 $E$ 和屈服极限 $\\sigma_\\mathrm{s}$ 都和拉伸时大致相同，之后越压越扁，也越来越难压，所以得不到压缩时的强度极限。 铸铁仍在较小变形下突然破坏，破坏断面法线与轴线大致成 45° - 55° 角。 失效、安全因数和强度计算对塑性材料，$[\\sigma] = \\frac{\\sigma_\\mathrm{s}}{n_\\mathrm{s}}$；对脆性材料，$[\\sigma] = \\frac{\\sigma_\\mathrm{b}}{n_\\mathrm{b}}$。其中 $n_\\mathrm{s}$ 和 $n_\\mathrm{b}$ 称为安全系数，有$$\\sigma = \\frac{F_\\mathrm{N}}{A} \\leqslant [\\sigma]$$ 轴向拉伸或压缩时的变形$$\\Delta l = \\frac{F_\\mathrm{N}l}{EA} = \\frac{Fl}{EA}$$ 可以看出，对长度相同、受力相等的杆件，$EA$ 越大变形 $\\Delta l$ 就越小，所以 $EA$ 越大的材料越强，称为杆件的抗拉（压）刚度。 试验表明，应力不超过比例极限时横向应变 $\\varepsilon’$ 与轴向应变 $\\varepsilon$ 之比是一个常数，即$$\\mu = -\\frac{\\varepsilon’}{\\varepsilon}$$$\\mu$ 称为横向变形因数或泊松比。之所以有个负号，是因为一般材料都是伸长时横向缩小，压缩时横向增大。 轴向拉伸或压缩时的应变能杆件拉伸时，有 $W = \\frac12F\\Delta l$，忽略动能、热能等变化，杆件就只存到了应变能 $V_\\varepsilon = W = \\frac12F\\Delta l = \\frac{F^2l}{2EA}$，比能 $v_\\varepsilon = \\frac12\\sigma\\varepsilon$。 能量法解题时需要计算应变能。 拉伸、压缩超静定问题理论力学默认材料都是刚体，没法解决超静定问题，但实际上材料总是会变形的。 温度应力和装配应力温度变化为 $\\Delta T$ 时，杆件变形为$$\\Delta l_T = \\alpha_l\\Delta T\\cdot l$$式中 $\\alpha_l$ 为材料的线胀系数。 剪切和挤压的实用计算$$\\tau = \\frac{F_\\mathrm{S}}{A} \\leqslant [\\tau]$$ 扭转外力偶矩的计算由$$2\\pi \\times \\frac{n}{60} \\times M_\\mathrm{e} = P \\times 1000$$得出计算外力偶矩 $M_\\mathrm{e}$ 的公式为$${M_\\mathrm{e}}_{\\mathrm{N\\cdot m}} = 9549 \\frac{{P}_\\mathrm{kW}}{{n}_\\mathrm{r/min}}$$ 纯剪切对各向同性材料，三个弹性常数 $E,G,\\mu$ 之间存在下列关系：$$G = \\frac{E}{2(1+\\mu)}$$ 圆轴扭转时的应力最大切应力$$\\tau_\\mathrm{max} = \\frac{T}{W_\\mathrm{t}}$$式中 $W_\\mathrm{t}=I_p/R$ 为抗扭(twist)截面系数。圆截面的抗扭截面系数为$$W_\\mathrm{t} = \\frac{\\pi D^3}{16}$$空心圆截面的抗扭截面系数为$$W_\\mathrm{t} = \\frac{\\pi}{16D}(D^4 - d^4) = \\frac{\\pi D^3}{16}(1 - \\alpha^4)$$ 圆轴扭转时的变形距离为 $l$ 的两个横截面之间的相对转角为$$\\varphi = \\frac{Tl}{G I_\\mathrm{p}}$$$\\varphi$ 的变化率 $\\varphi’$ 为单位长度扭转角，单位为 rad/m，即$$\\varphi’_\\mathrm{max} = \\frac{T}{G I_\\mathrm{p}} \\leqslant [\\varphi’]$$式中 $I_\\mathrm{p}$ 为横截面对圆心 $O$ 点的极惯性矩，即$$I_\\mathrm{p} = \\int_A \\rho^2 \\mathrm{d}A$$圆截面的 $I_\\mathrm{p} = \\frac{\\pi D^4}{32}$，空心圆截面的 $I_\\mathrm{p} = \\frac{\\pi D^4}{32}(1 - \\alpha^4)$。 圆柱形密圈螺旋弹簧的应力和变形弹簧最大切应力$$\\tau_\\mathrm{max} = \\left(\\frac{4c-1}{4c-4}+\\frac{0.615}{c}\\right)\\frac{8FD}{\\pi d^3} = k\\frac{8FD}{\\pi d^3}$$式中 $c=\\frac Dd$ 为弹簧指数，$k$ 为曲度系数。 刚度系数$$C = \\frac{Gd^4}{8D^3n} = \\frac{Gd^4}{64R^3n}$$代表弹簧抵抗变形的能力。变形 $\\lambda = \\frac{F}{C}$ 。 非圆截面杆扭转的概念$$\\tau_\\mathrm{max} = \\frac{T}{\\alpha hb^2}$$ 弯曲内力弯曲的概念和实例以弯曲变形为主的杆件习惯上称为梁。 剪力和弯矩符号规定： 剪力：截面 $m-m$ 的左段对右段向上相对错动时，截面 $m-m$ 上的剪力规定为正；反之为负。 弯矩：截面 $m-m$ 处弯曲变形凸向下时，截面 $m-m$ 上的弯矩规定为正；反之为负。 计算剪力和弯矩时注意考虑支座反力。弯矩方程对距离求导为剪力方程。 平面曲杆的弯曲内力分析时取圆心角为 $\\varphi$ 的横截面 $m-m$ 将曲杆分成两部分，然后列平衡方程。 符号规定： 引起拉伸变形的轴力 $F_\\mathrm{N}$ 为正 使轴线曲率增加的弯矩 $M$ 为正 以剪力 $F_\\mathrm{S}$ 对所考虑的一段曲杆内任一点取矩，若力矩为顺时针方向，则剪力 $F_\\mathrm{S}$ 为正 弯曲应力概述弯矩 $M$ 只与横截面上的正应力 $\\sigma$ 有关，剪力 $F_\\mathrm{S}$ 只与横截面上的切应力 $\\tau$ 有关。 梁中间段上剪力为零，弯矩为常量的情况称为纯弯曲。 梁发生弯曲变形时长度不变的纤维层称为中性层，中性层与横截面的交线称为中性轴。 横力弯曲时的正应力工程实际中觉的弯曲问题多为横力弯曲，此时梁的横截面上不仅有正应力而且有切应力。 一般情况下，最大正应力 $\\sigma_\\mathrm{max}$ 发生于弯矩最大的截面上，且离中性轴最远处，即$$\\sigma_\\mathrm{max} = \\frac{M_\\mathrm{max}y_\\mathrm{max}}{I_z}$$引入记号$$W = \\frac{I_z}{y_\\mathrm{max}}$$则有$$\\sigma_\\mathrm{max} = \\frac{M_\\mathrm{max}}{W}$$$W$ 称为抗弯截面系数，与截面的几何形状有关，单位为 $\\mathrm{m}^3$ 。 若截面是高为 $h$、宽为 $b$ 的矩形，则$$W = \\frac{I_z}{h/2} = \\frac{bh^3/12}{h/2} = \\frac{bh^2}{6}$$若截面是直径为 $d$ 的圆形，则$$W = \\frac{I_z}{d/2} = \\frac{\\pi d^4/64}{d/2} = \\frac{\\pi d^3}{32}$$类似地，空心圆形截面的抗弯截面系数为$$W = \\frac{\\pi d^3(1-\\alpha^4)}{32}$$弯曲正应力的强度条件为$$\\sigma_\\mathrm{max} = \\frac{M_\\mathrm{max}}{W} \\leqslant [\\sigma]$$ 弯曲切应力$$S_z^* = \\int_{A_1}y_1\\mathrm{d}A$$是横截面的部分面积 $A_1$ 对中性轴的静矩。 一般说，在剪力为最大值的截面的中性轴上，出现最大切应力，且$$\\tau_\\mathrm{max} = \\frac{F_\\mathrm{Smax}S^*_\\mathrm{zmax}}{I_z b}$$ 矩形截面梁的最大切应力$$\\tau_\\mathrm{max} = \\frac{3}{2}\\frac{F_\\mathrm{S}}{bh}$$为平均切应力的 1.5 倍。 圆形截面梁的最大切应力$$\\tau_\\mathrm{max} = \\frac43\\frac{F_\\mathrm{S}}{\\pi R^2}$$为平均切应力的 $\\frac43$ 倍。 提高弯曲强度的措施对抗拉和抗压强度相同的材料（如碳钢）宜采用中性轴对称的截面，对抗拉和抗压强度不相等的材料（如铸铁）宜采用中性轴偏向于受拉一侧的截面形状。如能使 $y_1$ 和 $y_2$ 之比接近于下列关系：$$\\frac{\\sigma_\\mathrm{tmax}}{\\sigma_\\mathrm{cmax}} = \\frac{M_\\mathrm{max}y_1}{Iz}/\\frac{M_\\mathrm{max}y_2}{Iz} = \\frac{y_1}{y_2} = \\frac{[\\sigma_\\mathrm{t}]}{[\\sigma_\\mathrm{c}]}$$式中 $[\\sigma_\\mathrm{t}]$ 和 $[\\sigma_\\mathrm{c}]$ 分别表示拉伸（Tension）和压缩（Compression）的许用应力，则最大拉应力和最大压应力可同时接近许用应力。强度校核时超过百分之 $5$ 以内都可接受（跟开车超速一点点不扣分差不多）。 弯曲变形挠曲线的微分方程发生弯曲变形时，变形前为直线的梁轴线，变形后成为一条连续且光滑的曲线，称为挠曲线。 用积分法求弯曲变形边界条件：在固定端，挠度和转角都为零，在铰支座上，挠度为零。$$EIw’’ = M(x)$$然后对 $x$ 积分两次，代入边界条件和连续条件确定积分常数，得到挠曲线方程。注意 $w’$ 即为 $\\theta$ 。 用叠加法求弯曲变形弯曲变形很小且材料服从胡克定律时，挠曲线的微分方程是线性的。 应力和应变分析 强度理论应力状态概述切应力等于零的面称为主平面，主平面上的正应力称为主应力。 二向和三向应力状态的实例圆筒的壁厚 $\\delta$ 远小于它的内径 $D$ 时，称为薄壁圆筒。若封闭的薄壁圆筒所受内压为 $p$ ，则其横截面上应力$$\\sigma’ = \\frac FA = \\frac{p\\cdot\\frac{\\pi D^2}{4}}{\\pi D\\delta} = \\frac{pD}{4\\delta}$$纵向截面上应力$$\\sigma’’ = \\frac{pD}{2\\delta}$$ 在研究一点的应力状态时，通常用 $\\sigma_1,\\sigma_2,\\sigma_3$ 代表该点的三个主应力，并以 $\\sigma_1$ 代表代数值最大的主应力，$\\sigma_3$ 代表代数值最小的主应力，即 $\\sigma_1 \\geqslant \\sigma_2 \\geqslant \\sigma_3$ 。 二向应力状态分析————解析法$\\sigma_x$ 和 $\\tau_{xy}$ 是法线与 $x$ 轴平行的面上的正应力和切应力；$\\sigma_y$ 和 $\\tau_{yx}$ 是法线与 $y$ 轴平行的面上的正应力和切应力。符号规定：正应力拉正压负，切应力对单元体内任意点的矩为顺时针转向时为正，反之为负，这里与平常不同。取任意斜截面，其外法线 $n$ 与 $x$ 轴的夹角为 $\\alpha$ 。规定：由 $x$ 轴转到外法线 $n$ 为逆时针转向时，则 $\\alpha$ 为正。 $$\\left.\\begin{aligned}\\sigma_\\mathrm{max} \\\\\\sigma_\\mathrm{min}\\end{aligned}\\right\\}= \\frac{\\sigma_x+\\sigma_y}{2} \\pm \\sqrt{\\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2}$$$$\\left.\\begin{aligned}\\tau_\\mathrm{max} \\\\\\tau_\\mathrm{min}\\end{aligned}\\right\\}= \\pm \\sqrt{\\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2}$$$$\\sigma_\\alpha = \\frac{\\sigma_x+\\sigma_y}{2} + \\frac{\\sigma_x-\\sigma_y}{2}\\cos2\\alpha - \\tau_{xy}\\sin2\\alpha \\\\\\tau_\\alpha = \\frac{\\sigma_x-\\sigma_y}{2}\\sin2\\alpha + \\tau_{xy}\\cos2\\alpha$$ 二向应力状态分析————图解法上面两式两边平方然后相加可消去 $\\alpha$ ，得$$\\left(\\sigma_\\alpha-\\frac{\\sigma_x+\\sigma_y}{2}\\right)^2 + \\tau_\\alpha^2 = \\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2$$$\\sigma_x,\\sigma_y,\\tau_{xy}$ 均为已知量，可此式是一个以 $\\sigma_\\alpha$ 和 $\\tau_\\alpha$ 为变量的圆方程，以横坐标表示 $\\sigma$ ，纵坐标表示 $\\tau$ ，则圆心横坐标为 $\\frac{1}{2}(\\sigma_x+\\sigma_y)$ ，纵坐标为零，半径为 $\\sqrt{\\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2}$ 。这一圆周称为应力圆。 作法： 在坐标系取点 $A(\\sigma_x,0)$ ，$D(\\sigma_x,\\tau_{xy})$ ，$B(\\sigma_y,0)$ ，$D’(\\sigma_y,-\\tau_{xy})$ 。 连接 $D$ 和 $D’$ ，与横坐标交于 $C$ 点，以 $C$ 为圆心， $CD$ 为半径画圆，得到应力圆。 在应力圆上，从 $D$ 点（它代表以 $x$ 轴为法线的面上的应力）也按逆时针方向沿圆周转到 $E$ 点，且使 $DE$ 弧所对圆心角为 $\\alpha$ 的 $2$ 倍，则 $E$ 点的坐标就代表以 $n$ 为法线的斜面上的应力。 三向应力状态$$\\sigma_\\mathrm{max} = \\sigma_1, \\quad\\sigma_\\mathrm{min} = \\sigma_3, \\quad\\tau_\\mathrm{max} = \\frac{\\sigma_1-\\sigma_3}{2}$$$\\sigma_2$ 就是一般就是垂直于 $\\sigma_1$ 和 $\\sigma_3$ 的应力。 广义胡克定律$$\\varepsilon_x = \\frac1E[\\sigma_x-\\mu(\\sigma_y+\\sigma_z)]$$ $$\\varepsilon_1 = \\frac1E[\\sigma_1-\\mu(\\sigma_2+\\sigma_3)] \\\\\\varepsilon_2 = \\frac1E[\\sigma_2-\\mu(\\sigma_1+\\sigma_3)] \\\\\\varepsilon_3 = \\frac1E[\\sigma_3-\\mu(\\sigma_1+\\sigma_2)]$$ 四种常用强度理论最大拉应力理论（第一强度理论）$$\\sigma_{\\mathrm{r}1} = \\sigma_1$$最大伸长线应力理论（第二强度理论）$$\\sigma_{\\mathrm{r}2} = \\sigma_1 - \\mu(\\sigma_2+\\sigma_3)$$最大切应力理论（第三强度理论）$$\\sigma_{\\mathrm{r}3} = \\sigma_1 - \\sigma_3$$最大畸变能密度理论（第四强度理论）$$\\sigma_{\\mathrm{r}4} = \\sqrt{\\frac12[(\\sigma_1-\\sigma_2)^2+(\\sigma_2-\\sigma_3)^2+(\\sigma_3-\\sigma_1)^2]}$$ 莫尔强度理论$$\\sigma_\\mathrm{rM} = \\sigma_1 - \\frac{[\\sigma_t]}{[\\sigma_c]}\\sigma_3$$ 组合变形扭转与弯曲的组合$$M = \\sqrt{M_{y\\mathrm{max}}^2+M_{z\\mathrm{max}}^2}$$按第三强度理论，有$$\\sqrt{\\sigma^2+4\\tau^2} \\leqslant [\\sigma] \\\\\\frac1W\\sqrt{M^2+T^2} \\leqslant [\\sigma]$$按第四强度理论，有$$\\sqrt{\\sigma^2+3\\tau^2} \\leqslant [\\sigma] \\\\\\frac1W\\sqrt{M^2+0.75T^2} \\leqslant [\\sigma]$$ 压杆稳定压杆稳定的概念细长杆件受压时，设压力与轴线重合，压力小于某一极限值时，压杆一直保持直线形状的平衡，即便有微小的侧向干扰力使其暂时发生轻微弯曲，干扰力解除后，压杆也能恢复直线形状，这表明压杆直线形状的平衡是稳定的。但是如果压力大于某一极限值时，压杆的直线平衡变为不稳定，将转变为曲线形状的平衡。这时再用微小的侧向干扰力使其发生轻微弯曲，干扰力解除后，它将保持曲线形状的平衡，不能恢复到原有的直线形状。 上述压力的极限值称为临界压力或临界力，记为 $F_\\mathrm{cr}$ 。压杆丧失其直线形状的平衡而过渡为曲线平衡，称为丧失稳定性，简称失稳，也称为屈曲。 其他支座条件下细长压杆的临界压力欧拉公式的普遍形式为$$F_\\mathrm{cr} = \\frac{\\pi^2EI}{(\\mu l)^2}$$式中 $\\mu l$ 表示把压杆折算成两端铰支杆的长度，称为相当长度，$\\mu$ 称为长度因数，不同情况下的长度因数 $\\mu$ 列表如下： 压杆的约束条件 长度因数 两端铰支 $\\mu=1$ 一端固定，另一端自由 $\\mu=2$ 两端固定 $\\mu=\\frac12$ 一端固定，另一端铰支 $\\mu\\approx0.7$ 欧拉公式的适用范围 经验公式$$\\sigma_\\mathrm{cr} = \\frac{F_\\mathrm{cr}}{A} = \\frac{\\pi^2EI}{(\\mu l)^2A}$$$ \\sigma_\\mathrm{cr}$ 称为临界应力。把横截面的惯性矩 $I$ 写成$$I = i^2A$$上式可以写成$$\\sigma_\\mathrm{cr} = \\frac{\\pi^2E}{(\\frac{\\mu l}{i})^2A}$$引用记号$$\\lambda = \\frac{\\mu l}{i}$$$\\lambda$ 是一个量纲一的量，称为柔度或长细比，综合反映了压杆的长度、约束条件、截面尺寸和形状等因素对临界应力 $\\sigma_\\mathrm{cr}$ 的影响。计算临界应力的公式可以写成$$\\sigma_\\mathrm{cr} = \\frac{\\pi^2E}{\\lambda^2}$$这是欧拉公式的另一种表达形式，其适用范围为$$\\lambda \\leqslant \\lambda_\\mathrm{p} = \\pi\\sqrt{\\frac{E}{\\sigma_\\mathrm{p}}}$$ 压杆的稳定性校核$F_\\mathrm{cr}$ 与 $F$ 之比即为压杆的工作安全因数 $n$，它应大于规定的稳定安全因数 $n_\\mathrm{st}$，即$$n = \\frac{F_\\mathrm{cr}}{F} \\geqslant n_\\mathrm{st}$$ 平面图形的几何性质静矩和形心在坐标 $(y,z)$ 处，取微面积 $\\mathrm{d}A$ ，遍及整个图形面积 $A$ 的积分$$S_z = \\int_A y\\mathrm{d}A, \\quad S_y = \\int_A z\\mathrm{d}A$$分别定义为图形对 $z$ 轴和 $y$ 轴的静矩，也称为图形对 $z$ 轴和 $y$ 轴的一次矩。这个坐标轴之所以只有 $y$ 和 $z$ 而没有 $x$ ，是因为我们一般分析的是横截面，$x$ 轴是杆的轴线方向。可以看出，平面图形的静矩是对某一坐标轴而言的，也就是说，同一图形对不同的坐标轴的静矩通常是不同的。静矩的量纲是长度的三次方。 平面图形对 $y$ 轴和 $z$ 轴的静矩，分别等于图形面积 $A$ 乘形心的坐标 $\\overline{z}$ 和 $\\overline{y}$ ，即$$S_z = A\\cdot\\overline{y}, \\quad S_y = A\\cdot\\overline{z}$$ 惯性矩和惯性半径在坐标 $(y,z)$ 处，取微面积 $\\mathrm{d}A$ ，遍及整个图形面积 $A$ 的积分$$I_y = \\int_A z^2\\mathrm{d}A, \\quad I_z = \\int_A y^2\\mathrm{d}A$$分别定义为图形对 $y$ 轴和 $z$ 轴的惯性矩，也称为图形对 $y$ 轴和 $z$ 轴的二次矩。惯性矩的量纲是长度的四次方。矩形的对形心轴的 $I_z$ 为 $\\frac{bh^3}{12}$ 。力学计算中，有时把惯性矩写成图形面积 $A$ 与某一长度的平方的乘积，即$$I_y = A\\cdot i_y^2, \\quad I_z = A\\cdot i_z^2$$或者改写为$$i_y = \\sqrt{\\frac{I_y}{A}}, \\quad i_z = \\sqrt{\\frac{I_z}{A}}$$式中的 $i_y$ 和 $i_z$ 分别称为图形对 $y$ 轴和 $z$ 轴的惯性半径。惯性半径的量纲就是长度的量纲。 以 $\\rho$ 表示微面积 $\\mathrm{d}A$ 到坐标原点 $O$ 的距离，下列积分$$I_\\mathrm{p} = \\int_A \\rho^2\\mathrm{d}A$$定义为图形对坐标原点 $O$ 的极惯性矩。又 $\\rho^2 = y^2+z^2$ ，于是有$$I_\\mathrm{p} = \\int_A (y^2+z^2)\\mathrm{d}A = \\int_A y^2\\mathrm{d}A + \\int_A z^2\\mathrm{d}A = I_z + I_y$$ 惯性积在坐标 $(y,z)$ 处，取微面积 $\\mathrm{d}A$ ，遍及整个图形面积 $A$ 的积分$$I_{yz} = \\int_A yz\\mathrm{d}A$$定义为图形对 $y,z$ 轴的惯性积。惯性积的量纲是长度的四次方。坐标系的两根坐标轴中只要有一根为图形对称轴，则图形对这一坐标系的惯性积就等于零。 平行移轴公式$$I_y = I_{yC} + a^2A \\\\I_z = I_{zC} + b^2A \\\\$$","link":"/2023/01/24/%E6%9D%90%E6%96%99%E5%8A%9B%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"title":"高数下笔记","text":"挂科了，还是要学好高数啊！ 前言玩脱了，光顾着搞技术，绩点炸了。高数 59 ，有人问我说我是不是得罪老师了——但是有没有一种可能，就是。。平时分已经给满了（） 笔记正文第六章 多元函数微分学1. 多元函数2. 多元函数的极限3. 多元函数的连续性4. 偏导数与全微分例（2020-2021第二学期期末，1）确定实数 $\\alpha$ 的范围，使函数 $f(x,y)=\\left\\{\\begin{aligned} (x^2+y^2)^\\alpha\\sin\\frac{1}{x^2+y^2},x^2+y^2\\neq0 \\\\ 0,x^2+y^2\\neq0\\end{aligned}\\right.$ 在 $(0,0)$ 处可微。解$$\\lim_{x\\rightarrow0}\\frac{f(x,0)-f(0,0)}{x-0}=\\lim_{x\\rightarrow0}\\frac{x^{2\\alpha}\\sin\\frac{1}{x^2}}{x}=\\lim_{x\\rightarrow0}x^{2\\alpha-1}\\sin\\frac{1}{x^2}$$当 $2\\alpha-1&gt;0$ 时，极限为 $0$ ，即 $f_x’(0,0)=0$ ，此时类似地，有 $f_y’(0,0)=0$ 5. 复合函数与隐函数的微分法6. 方向导数与梯度7. 多元函数的微分中值定理与泰勒公式8. 隐函数存在定理9. 极值问题先用 $f_x’=f_y’=0$ 求出稳定点，再令 $A=f_{xx},B=f_{xy},C=f_{yy}$ ，仅 $B^2 &lt; AC$ 时可以确定极值，此时 $A&gt;0$ 就是极小值， $A &lt; 0$ 就是极大值。与二元函数类似。 例（2021-2022第二学期期末，4）求多元函数 $f(x,y)=xe^{-\\frac{x^2+y^2}{2}}$ 的极值。解 $f_x’=e^{-\\frac{x^2+y^2}{2}}(1-x^2),f_y’=e^{-\\frac{x^2+y^2}{2}}(-xy)$ ，令 $f_x’=f_y’=0$ ，得到 $(-1,0)$ 和 $(1,0)$ 两个稳定点。令 $A=f_{xx}=e^{-\\frac{x^2+y^2}{2}}(x^3-3x),B=f_{xy}=e^{-\\frac{x^2+y^2}{2}}(-y+x^2y),C=f_{yy}=e^{-\\frac{x^2+y^2}{2}}(-x+xy^2)$ ，代入 $(1,0)$ 得到 $A=-2e^{-\\frac{1}{2}}&lt;0$，$B=0$ 第七章 重积分1. 二重积分的概念与性质2. 二重积分的计算例（2021-2022第二学期期末，2）求 $I=\\int_0^1\\mathrm{d}x\\int_0^{\\sqrt{1-x^2}}(x^2+y^2)\\mathrm{d}y$解 作极坐标变换 $x=r\\cos\\theta,y=r\\sin\\theta$，则$$I = \\int_0^{\\frac{\\pi}{4}}\\mathrm{d}\\theta\\int_0^1 r\\cdot r\\mathrm{d}r = \\frac{\\pi}{12}$$例（2017-2018第二学期期末，1）计算二重积分 $\\iint_D\\frac{|y|}{x^2+y^2}\\mathrm{d}x\\mathrm{d}y$，其中 $D$ 为圆环区域 $1\\leq x^2+y^2\\leq 4$。解 作极坐标变换，有$$I = \\int_0^{2\\pi}\\mathrm{d}\\theta\\int_1^2 \\frac{|r\\sin\\theta|}{r^2}\\cdot\\mathrm{d}r = \\int_0^{2\\pi}|\\sin\\theta|\\mathrm{d}\\theta\\int_1^2\\mathrm{d}r = 4\\int_0^{\\frac{\\pi}{2}}\\sin\\theta \\mathrm{d}\\theta\\int_1^2\\mathrm{d}r = 4$$ 3. 三重积分的概念与计算4. 重积分的应用举例曲面 $S$ 由参数方程 $x=x(u,v),y=y(u,v),z=z(u,v), (u,v)\\in D’$ 给出时，可计算$$E = x_u^2+y_u^2+z_u^2 \\\\F = x_ux_v+y_ux_v+z_ux_v \\\\G = x_v^2+y_v^2+z_v^2$$从而$$S = \\iint\\limits_{D’}\\sqrt{EG-F^2}\\mathrm{d}u\\mathrm{d}v$$ 第八章 曲线积分与曲面积分1. 第一型曲线积分（对弧长的曲线积分）这个非常地简单直观，就是求一条曲线（如二次函数的某一段）的长度。平面曲线求法：$$\\int_Lf(x,y)ds=\\int_\\alpha^\\beta f[x(t),y(t)]\\sqrt{[x’(t)]^2+[y’(t)]^2}dt \\\\or \\int_Lf(x,y)ds=\\int_\\alpha^\\beta f[x,y(x)]\\sqrt{[1+[y’(x)]^2}dxdy$$空间曲线类似：$$\\int_Lf(x,y,z)ds=\\int_\\alpha^\\beta f[x(t),y(t),z(t)]\\sqrt{[x’(t)]^2+[y’(t)]^2+[z’(t)]^2}dt \\\\$$ 2. 第二型曲线积分（对坐标的曲线积分）这个看起来就不那么地直观，其物理背景是求变力在曲线上做功，大概想象一下子。计算方法：$$\\int_{\\overset{\\frown}{AB}}P(x,y)dx=\\int_\\alpha^\\beta P[x(t),y(t)]x’(t)dt \\\\\\int_{\\overset{\\frown}{AB}}Q(x,y)dy=\\int_\\alpha^\\beta Q[x(t),y(t)]y’(t)dt$$两类曲线积分关系：$$\\int_LPdx+Qdy=\\int_L(Pcos\\alpha +Qcos\\beta )ds \\\\or \\int_\\Gamma Pdx+Qdy+Rdz=\\int_L(Pcos\\alpha +Qcos\\beta +Rcos\\gamma )ds$$ 3. 格林公式就一道式子：$$∮_L Pdx+Qdy=∬\\limits_D( \\frac{ \\partial Q }{ \\partial x }- \\frac{ \\partial P }{ \\partial y })dxdy\\\\$$条件是函数 $P$ 和 $Q$ 在平面区域 $D$ 上有连续的偏导数 ，这个条件一般不管， 主要是边界曲线 $L$ 闭合就行。格林公式可以将第二类曲线积分化为简单的二重积分，非常地不错。 PS:以下这些符号的 Latex 支持不是很好，直接用字符了。$$∮ \\ ∯ \\ ∰ \\ ∱ \\ ∲ \\ ∳$$ 例（2020-2021第二学期期末，2）计算曲线积分 $∮_L(xy^2-\\sin y)\\mathrm{d}y-(\\cos x+x^2y)\\mathrm{d}x$ ，其中 $L$ 为圆周 $x^2+y^2=4$ ，积分方向为沿 $L$ 逆时针方向。解 $L$ 为闭合曲线，且 $P,Q$ 在 $L$ 围成的 $D$ 上偏导也连续，所以可以用格林公式：$$\\begin{aligned}I&amp;=\\iint\\limits_D[y^2-(-x^2)]\\mathrm{d}x\\mathrm{d}y \\\\&amp;=\\int_0^{2\\pi}\\mathrm{d}\\theta\\int_0^2r^2\\cdot r\\mathrm{d}r \\\\&amp;=8\\pi\\end{aligned}$$ 4. 第一型曲面积分和第一型曲线积分一样直观，就是求一个曲面的面积。计算方法：$$\\iint \\limits_{\\Sigma} f(x,y,z) \\mathrm{d}S=\\iint \\limits_{D_{xy}}f[x,y,z(x,y)]\\sqrt{1+(\\frac{\\partial z}{\\partial x})^2+(\\frac{\\partial z}{\\partial y})^2}\\mathrm{d}x\\mathrm{d}y$$ 5. 第二型曲面积分计算方法：$$\\iint \\limits_{\\Sigma} R(x,y,z) \\mathrm{d}S=\\iint \\limits_{D_{xy}}R[x,y,z(x,y)]\\mathrm{d}x\\mathrm{d}y$$ 两类曲面积分关系：$$\\iint \\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y=\\iint \\limits_\\Sigma(Pcos\\alpha+Qcos\\beta+Rcos\\gamma)\\mathrm{d}S$$ 6. 高斯公式与斯托克斯公式高斯公式：$$∯ \\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y=\\iiint \\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z \\\\or ∯ \\limits_\\Sigma(P\\mathrm{cos}\\alpha+Q\\mathrm{cos}\\beta+R\\mathrm{cos}\\gamma)\\mathrm{d}S=\\iiint \\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$$例（2021-2022第二学期期末，3）计算曲面积分 $∯ \\limits_\\Sigma(x-z)\\mathrm{d}y\\mathrm{d}z+z\\mathrm{d}x\\mathrm{d}y$ ，其中 $\\Sigma$ 是由 $z=x^2+2y^2$ 与 $z=1$ 所围成立体表面的外侧。解 $\\Sigma$ 是封闭曲面，直接上高斯公式，有$$I=\\iiint \\limits_\\Omega(1+1)\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z=2\\iiint \\limits_\\Omega\\mathrm{d}V$$作柱面坐标变换 $x=r\\cos\\theta,y=\\frac{r\\sin\\theta}{\\sqrt2}$ ，得$$I=\\int_0^{2\\pi}\\mathrm{d}\\theta\\int_0^1\\mathrm{d}r\\int_0^1\\frac{r}{\\sqrt{2}}dz=\\frac{\\pi}{\\sqrt2}$$ 直角坐标与柱面坐标关系：$$\\left\\{\\begin{aligned}x&amp;=r\\cos\\theta \\\\y&amp;=r\\sin\\theta \\\\z&amp;=z\\end{aligned}\\right.$$此时 $\\mathrm{d}V=r\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}z$直角坐标与球面坐标关系：$$\\left\\{\\begin{aligned}x&amp;=r\\sin\\varphi\\cos\\theta \\\\y&amp;=r\\sin\\varphi\\sin\\theta \\\\z&amp;=r\\cos\\varphi\\end{aligned}\\right.$$此时 $\\mathrm{d}V=r^2\\sin\\varphi\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}\\varphi$ 斯托克斯公式：$$∮_L P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z=\\iint \\limits_\\Sigma\\begin{vmatrix}\\mathrm{d}y\\mathrm{d}z &amp; \\mathrm{d}x\\mathrm{d}z &amp; \\mathrm{d}x\\mathrm{d}y \\\\\\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} &amp; \\frac{\\partial}{\\partial z} \\\\P &amp; Q &amp; R\\end{vmatrix}=\\iint \\limits_\\Sigma\\begin{vmatrix}\\mathrm{cos}\\alpha &amp; \\mathrm{cos}\\beta &amp; \\mathrm{cos}\\gamma \\\\\\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} &amp; \\frac{\\partial}{\\partial z} \\\\P &amp; Q &amp; R\\end{vmatrix}\\mathrm{d}S$$ 第九章 常微分方程1. 基本概念所谓常微分方程，就是区别于偏微分方程，未知函数是一元函数，而不是多元。常微分方程的阶数即肉眼可见的导数的最高阶，如 $y’’’+2(y’’)^3+y^2+x^5$ 就是三阶常微分方程。通解的概念：$n$ 阶常微分方程有解 $y=\\varphi(x;C_1,\\cdots,C_n)$ ，其中 $C_1,\\cdots,C_n$ 是 $n$ 个独立的任意常数，则称其为方程的一个通解；相对的，就有特解的概念，即方程的任何一个不包含任意常数的解。用数学语言表达独立性，有雅可比行列式不为零，即$$\\frac{D(\\varphi,\\varphi’,\\cdots,\\varphi^{n-1})}{D(C_1,C_2,\\cdots,C_n)}\\ne0$$ 举个例子，经典方程 $y’’+y=0$ 有解 $y=C_1\\mathrm{sin}x+C_2\\mathrm{cos}x$ ，则雅可比行列式为$$\\frac{D(y,y’)}{D(C_1,C_2)}=\\begin{vmatrix}\\mathrm{sin}x &amp; \\mathrm{cos}x \\\\\\mathrm{cos}x &amp; -\\mathrm{sin}x\\end{vmatrix}=-1 \\ne 0$$可能你会问这个雅可比行列式具体怎么出來的，其实第一行就是 $y$ 分别对 $C_1$ 和 $C_2$ 求导，第二行是 $y’$ 对 $C_1$ 和 $C_2$ 求导。故 $C_1,C_2$ 是两个独立的任意常数，进而 $y=C_1\\mathrm{sin}x+C_2\\mathrm{cos}x$ 是方程的通解。 2. 初等积分法2.1 变量分离的方程2.2 可化为变量分离的几类方程2.3 一阶线性微分方程形如$$\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)$$的一阶微分方程就叫一阶线性微分方程。一般套公式就行，若 $Q(x)\\equiv0$ ，则为齐次方程，直接积分有通解 $y=C\\mathrm{e}^{-\\int P(x)\\mathrm{d}x}$ ；若为非齐次方程则用常数变易法求得通解$$y=\\mathrm{e}^{-\\int P(x)\\mathrm{d}x}\\left[\\int Q(x)\\mathrm{e}^{\\int P(x)\\mathrm{d}x}dx+C\\right]$$然后还有贝努里方程（当然贝努利方程也是它，音译嘛）长这样：$$\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)y^n\\ (n\\ne0,1)$$作变量代换 $z=y^{1-n}$ ，可化为一阶线性方程$$\\frac{\\mathrm{d}z}{\\mathrm{d}x}+(1-n)P(x)z=(1-n)Q(x)$$ 2.4 全微分方程与积分因子例（2021-2022第二学期期末，4）求微分方程 $x\\mathrm{d}y+(y+x^2)\\mathrm{d}x=0$ 的通解。解 $\\frac{\\partial P}{\\partial y}=1=\\frac{\\partial Q}{\\partial x}$，且它们在全平面上连续，故方程为全微分方程。下求原函数 $u(x,y)$ ，由 $\\frac{\\partial u}{\\partial x}=P(x,y)=y+x^2$ ，对 $x$ 积分得$$u(x,y)=xy+\\frac{x^3}{3}+\\varphi(y)$$上式对 $y$ 求偏导得$$\\frac{\\partial u}{\\partial y}=x+\\varphi’(y)$$另一方面，$$\\frac{\\partial u}{\\partial y}=Q(x,y)=x$$比较上两式得 $\\varphi’(y)=0$ ，因而 $\\varphi(y)=0$（这里省略积分常数，不影响后面的通积分表达式），故原函数为 $u(x,y)=xy+\\frac{x^3}{3}$ ，故方程的通解为$$xy+\\frac{x^3}{3}=C$$其中 $C$ 为任意常数。 微分方程的通解也叫通积分 2.5 可降阶的二阶微分方程例（2021-2022第二学期期末，5）求微分方程 $y’’=y’\\cdot y$ 的通解。解 方程中不显含变量 $x$ ，令 $p=y’$ ，并将 $y$ 看作自变量，有 $y’’=p\\frac{\\mathrm{d}p}{\\mathrm{d}y}$ ，代入有$$p\\frac{\\mathrm{d}p}{\\mathrm{d}y}=p\\cdot y$$若 $p=y’=0$ ，则通解为 $y=C$ ，若 $p\\ne0$ ，则有$$\\begin{aligned}\\frac{\\mathrm{d}p}{\\mathrm{d}y}&amp;=y \\\\\\int\\mathrm{d}p&amp;=\\int y\\mathrm{d}y \\\\p&amp;=\\frac{1}{2}y^2+C_1\\end{aligned}$$即 $\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{1}{2}y^2+C_1$ ，再次分离分量，有$$\\begin{aligned}\\frac{\\mathrm{d}y}{\\mathrm{d}x}&amp;=\\frac{1}{2}y^2+C_1 \\\\\\int\\frac{2}{y^2}\\mathrm{d}y&amp;=\\int\\mathrm{d}x + C_2 \\\\-\\frac{2}{y}&amp;=x+C_3 \\\\y&amp;=-\\frac{2}{x}+C\\end{aligned}$$ 这里面的常量 $C$ 变得我也很迷糊，但是结果代进去是对的，就先这样吧（） 例（2020-2021第二学期期末，5）求微分方程 $\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}=(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^3+\\frac{\\mathrm{d}y}{\\mathrm{d}x}$ 的通解。解 令 $p=y’$ ，有 $y’’=p\\frac{\\mathrm{d}p}{\\mathrm{d}y}$ ，代入有$$p\\frac{\\mathrm{d}p}{\\mathrm{d}y}=(p^3+p) \\\\\\frac{1}{p^2+p}\\mathrm{d}p=\\mathrm{d}y \\\\\\arctan p=y+C_1$$即有 $\\frac{\\mathrm{d}y}{\\mathrm{d}x}=p=\\tan(y+C_1)$ ，再次分离分量，有$$\\frac{\\mathrm{d}y}{\\tan(y+C_1)}=\\mathrm{d}x \\\\\\ln\\sin(y+C_1)=x+C_2$$最终得出 $y=\\arcsin e^{x+C_2}-C_1$ 3. 微分方程解的存在唯一性定理4. 高阶线性微分方程5. 二阶线性常系数微分方程 特征根 通解形式 两相异实根 $\\lambda_1,\\lambda_2$ $C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}$ 二重根 $\\lambda_1$ $(C_1+C_2x)e^{\\lambda_1x}$ 共轭复根 $\\lambda_{1,2}=\\alpha\\pm\\mathrm{i}\\beta$ $e^{\\alpha x}(C_1\\cos\\beta x+C_2\\sin\\beta x)$ $f(x)$ 的形式 条件 特解的形式 $P_n(x)$ “0”不是/是单/是重特征根 $Q_n(x)/xQ_n(x)/x^2Q_n(x)$ $ae^{\\alpha x}$ $\\alpha$ 不是/是单/是重特征根 $Ae^{\\alpha x}/Axe^{\\alpha x}/Ax^2e^{\\alpha x}$ $a\\cos\\beta x+b\\sin\\beta x$ $\\pm\\mathrm{i}\\beta$ 不是/是特征根 $A\\cos\\beta x+B\\sin\\beta x/x(A\\cos\\beta x+B\\sin\\beta x)$ $P_n(x)e^{\\alpha x}$ $\\alpha$ 不是/是单/是重特征根 $Q_n(x)e^{\\alpha x}/xQ_n(x)e^{\\alpha x}/x^2Q_n(x)e^{\\alpha x}$ $P_n(x)e^{\\alpha x}(a\\cos\\beta x+b\\sin\\beta x)$ $\\alpha\\pm\\mathrm{i}\\beta$ 不是/是特征根 $e^{\\alpha x}[Q_n(x)\\cos\\beta x+R_n(x)\\sin\\beta x]/xe^{\\alpha x}[Q_n(x)\\cos\\beta x+R_n(x)\\sin\\beta x]$ 咋一看很多，其实挺有规律，比如多一个根就多乘一个 $x$ ，原来的系数变成待定的。 例（2021-2022第二学期期末，6）求微分方程 $y’’+y=e^{3x}(x+2)$ 的通解。解 先求对应齐次微分方程 $y’’+y=0$ 的通解，特征方程 $\\lambda^2+1=0$ 的特征根 $\\lambda_{1,2}=\\pm \\mathrm{i}$ ，故通解形式为$$y(x)=e^{ax}(C_1\\cos\\beta x+C_2\\sin\\beta x)=C_1\\cos x+C_2\\cos x$$其中 $C_1,C_2$ 为任意常数再用待定系数法求特解，“3“不是特征根，故设方程有特解 $y=(Ax+B)e^{3x}$ ，则$$\\begin{aligned}y’&amp;=Ae^{3x}+3(Ax+B)e^{3x} \\\\y’’&amp;=3Ae^{3x}+3Ae^{3x}+9(Ax+B)e^{3x}=(9Ax+6A+9B)e^{3x} \\\\\\end{aligned}$$回代得$$y’’+y=(10Ax+6A+10B)e^{3x}=e^{3x}(x+2)$$解得 $A=\\frac{1}{10},\\ B=\\frac{7}{50}$ ，故特解为 $y=(\\frac{1}{10}x+\\frac{7}{50})e^{3x}$ ，与齐次方程通解相加，得出所求非齐次方程通解为$$y(x)=C_1\\cos x+C_2\\cos x+(\\frac{1}{10}x+\\frac{7}{50})e^{3x}$$其中 $C_1,C_2$ 为任意常数。 例（2020-2021第二学期期末，6）求微分方程 $\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}+y=e^x+\\cos x$ 的通解。解 特征方程 $\\lambda^2+1=0$ 的特征根 $\\lambda_{1,2}=\\pm \\mathrm{i}$ ，故齐次方程通解形式为$$y(x)=e^{ax}(C_1\\cos\\beta x+C_2\\sin\\beta x)=C_1\\cos x+C_2\\cos x$$这个方程的非齐次项由两项组成，就先分别求两项的特解，再相加，就是原方程的特解。对方程 $y’’+y=e^x$ 不难求得特解 $y=\\frac{1}{2}e^x$ ，方程 $y’’+y=\\cos x$ 的特解 $y=\\frac{1}{2}x\\cos x$ ，故原方程的特解为$$y=\\frac{1}{2}(e^x+x\\cos x)$$与齐次方程通解相加，得出所求非齐次方程通解为$$y(x)=C_1\\cos x+C_2\\cos x+\\frac{1}{2}(e^x+x\\cos x)$$ 6. 用常数变易法求解二阶线性非齐次方程与欧拉方程的解法7. 常系数线性微分方程组第十章 无穷级数1. 柯西收敛原理与数项级数的概念2. 正项级数的收敛判别法 比较审敛法比收敛小的就收敛，比发散大的就发散 比值审敛法$\\lim\\limits_{n\\to\\infty}\\frac{u_{n+1}}{u_n}$ 小于 1 就收敛，大于 1 就发散，等于 1 时敛散性不定 根值审敛法与上面类似，$\\lim\\limits_{n\\to\\infty}\\sqrt[n]{u_n}$ 小于 1 就收敛，大于 1 就发散，等于 1 时敛散性不定 对数审敛法 例（2021-2022第二学期期末，10-1）判断数项级数 $\\sum\\limits_{n=1}^{\\infty}3^n\\sin(\\frac{\\pi}{4^n})$ 的敛散性。解 放缩一下再比较判别法$$\\sum_{n=1}^{\\infty}3^n\\sin(\\frac{\\pi}{4^n})&lt;\\sum_{n=1}^{\\infty}3^n(\\frac{\\pi}{4^n})=\\pi\\sum_{n=1}^{\\infty}(\\frac{3}{4})^n$$由于 $\\sum_{n=1}^{\\infty}(\\frac{3}{4})^n$ 收敛，故原级数收敛。 3. 任意项级数莱布尼茨判别法 若交错级数满足下列条件：$$(1)u_n\\geqslant u_{n+1}; \\\\(2)\\lim_{n\\rightarrow\\infty}=0,$$则级数收敛。狄利克雷判别法 考虑级数$$\\sum_{k=1}^{\\infty}a_kb_k$$若序列 ${a_k}$ 单调且 $\\lim\\limits_{k\\rightarrow\\infty}a_k=0$ ，又级数 $\\sum\\limits_{n=1}^{\\infty}b_k$ 的部分和序列有界，则级数 $\\sum\\limits_{k=1}^{\\infty}a_kb_k$ 收敛。例（2021-2022第二学期期末，10-2）判断数项级数 $\\sum\\limits_{n=2}^{\\infty}\\frac{\\cos(2n)}{\\ln n}$ 的敛散性。解 取 $a_k=\\frac{1}{\\ln n}$ ，易证得 $a_k$ 单调且 $\\lim\\limits_{k\\rightarrow\\infty}a_k=0$ ，下证级数 $\\sum\\limits_{n=2}^{\\infty}\\cos(2n)$ 的部分和序列有界：$$\\begin{aligned}\\left|\\sum_{k=2}^{n}\\cos(2k)\\right|&amp;=\\left|\\cos4+\\cos6+\\cdots+\\cos2n\\right| \\\\&amp;=\\frac{1}{\\sin1}\\left|\\cos4\\sin1+\\cos6\\sin1+\\cdots+\\cos2n\\sin1\\right| \\\\&amp;=\\frac{1}{\\sin1}\\left|\\frac{\\sin5-\\sin3}{2}+\\frac{\\sin7-\\sin5}{2}+\\cdots+\\frac{\\sin(2n+1)-\\sin(2n-1)}{2}\\right| \\\\&amp;=\\frac{1}{\\sin1}\\left|\\frac{\\sin(2n+1)-\\sin3}{2}\\right| \\\\&amp;\\leqslant\\frac{1}{\\sin1}\\end{aligned}$$故级数 $\\sum\\limits_{n=2}^{\\infty}\\frac{\\cos(2n)}{\\ln n}$ 收敛。 积化和差公式$${\\displaystyle \\sin \\alpha \\cos \\beta ={\\sin(\\alpha +\\beta )+\\sin(\\alpha -\\beta ) \\over 2}} \\\\{\\displaystyle \\cos \\alpha \\sin \\beta ={\\sin(\\alpha +\\beta )-\\sin(\\alpha -\\beta ) \\over 2}} \\\\{\\displaystyle \\cos \\alpha \\cos \\beta ={\\cos(\\alpha +\\beta )+\\cos(\\alpha -\\beta ) \\over 2}} \\\\{\\displaystyle \\sin \\alpha \\sin \\beta ={\\cos(\\alpha +\\beta )-\\cos(\\alpha -\\beta ) \\over -2}}$$ 阿贝尔判别法（1）无穷数列 ${a_k}$ 单调有界（2）级数 $\\sum\\limits_{k=1}^\\infty b_k$ 收敛则级数 $\\sum\\limits_{k=1}^\\infty a_kb_k$ 收敛。 4. 函数项级数4.1 函数序列及函数项级数的一致收敛性4.2 函数项级数一致收敛的必要条件与判别法强级数判别法 若函数项级数 $\\sum\\limits_{n=1}^\\infty u_n(x)$ 的一般项满足：$$|u_n(x)|\\leqslant a_n,\\quad \\forall x\\in X,n=1,2,\\cdots,$$且正项级数 $\\sum\\limits_{n=1}^\\infty a_n$ 收敛，则该函数项级数在 $X$ 上一致收敛。 狄利克雷判别法 与数项级数的狄利克雷判别法类似。（1）在 $X$ 中任意取定一个 $x$ ，数列 ${a_n(x)}$ 对 $n$ 单调，且函数序列 ${a_n(x)}$ 在 $X$ 上一致收敛于 $0$（2）函数项级数 $\\sum\\limits_{n=1}^\\infty b_n(x)$ 的部分和序列 ${B_n(x)}$ 在 $X$ 上一致有界则 $\\sum\\limits_{n=1}^\\infty a_n(x)b_n(x)$ 在 $X$ 上一致收敛。 阿贝尔判别法 与数项级数的阿贝尔判别法类似。（1）在 $X$ 中任意取定一个 $x$ ，数列 ${a_n(x)}$ 单调，又函数序列 ${a_n(x)}$ 在 $X$ 上一致有界（2）级数 $\\sum\\limits_{n=1}^\\infty b_n(x)$ 在 $X$ 上一致收敛则级数 $\\sum\\limits_{n=1}^\\infty a_n(x)b_n(x)$ 在 $X$ 上一致收敛。 4.3 一致收敛级数的性质和函数的连续性 设函数项级数 $\\sum\\limits_{n=1}^\\infty u_n(x)$ 在 $[a,b]$ 上一致收敛，且其每一项 $u_n(x)$ 在 $[a,b]$ 上都连续，则其和函数 $S(x)=\\sum\\limits_{n=1}^\\infty u_n(x)$ 在 $[a,b]$ 上也连续。 例（2021-2022第二学期期末，11）考虑函数项级数 $\\sum\\limits_{n=2}^{\\infty}\\frac{1}{n^2\\sqrt x}$ ，证明：（1）级数在 $(0,1)$ 上收敛（2）级数在 $(0,1)$ 上不一致收敛（3）级数的和函数 $S(x)$ 在 $(0,1)$ 上连续解 （1）就是数项级数，随便证。（2）存在点列 $x_n=\\frac{1}{n^4}\\in(0,1)(n=1,2,\\cdots)$ 使 $u_n(x_n)=1$ 5. 幂级数幂级数是函数项级数的一种，长这样：$$a_0+a_1(x-x_0)+a_2(x-x_0)^2+\\cdots+a_n(x-x_0)^n+\\cdots$$ 5.1 幂级数的收敛半径$$\\lim_{n\\rightarrow\\infty}\\left|\\frac{a_{n+1}}{a_{n}}\\right|=l$$那么级数 $\\sum\\limits^n_{n=0}a_nx^n$ 的收敛半径 $R=1/l$ ，当然直接反着除直接出也行。收敛区间就是 $(-R,R)$ ，收敛域就根据端点的收敛情况再修正下区间闭不闭合。 例（2021-2022第二学期期末，8）求幂级数 $\\sum\\limits^\\infty_{n=0}\\frac{1}{n+1}x^n$ 的收敛半径与和函数。解$$\\lim_{n\\rightarrow\\infty}\\left|\\frac{a_n}{a_{n+1}}\\right|=\\lim_{n\\rightarrow\\infty}\\left|\\frac{n}{n+1}\\right|=1$$故收敛半径 $R=1$ ，收敛区间 $(-1,1)$ 。然后讨论两个端点，当 $x=1$ 时，原级数发散；当 $x=-1$ 时，原级数收敛，故收敛域为 $[-1,1)$设和函数 $S(x)=\\sum\\limits^\\infty_{n=0}\\frac{1}{n+1}x^n$ ，则两边乘 $x$ 有 $xS(x)=\\sum\\limits^\\infty_{n=0}\\frac{1}{n+1}x^{n+1}$ ，两边求导有$$\\left[xS(x)\\right]’=\\sum\\limits^\\infty_{n=0}x^n=\\frac{1}{1-x}$$再两边求积，有$$xS(x)=\\int^x_0\\frac{1}{1-x}\\mathrm{d}x=-\\ln(1-x),\\ x\\in[-1,1)$$故当 $x\\ne0$ 时，$S(x)=-\\frac{1}{x}\\ln(1-x)$ ；当 $x=0$ 时，肉眼可见 $S(x)=1$ 。 这里有个小 trick ，就是幂级数里认定 $0^0=1$ ，至于为什么是这样，网上众说纷纭，读者可自行查阅。 5.2 幂级数的性质和函数项级数一样，可以逐项求积，也可以逐项求导。 6. 泰勒级数求函数在 $x=k$ 处的泰勒展开式就作 $t=x-k$ 变换，然后求出来的式子再代回去就行了。 记一下常用的几条泰勒展开式：$$\\frac{1}{1-x}=1+x+x^2+x^3+\\cdots+x^n+\\cdots,\\ x\\in(-1,1)\\\\e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\cdots+\\frac{x^n}{n!}+\\cdots\\\\\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\cdots+(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!}+\\cdots\\\\\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\cdots+(-1)^{n}\\frac{x^{2n}}{(2n)!}+\\cdots\\\\\\arctan x=x-\\frac{x^3}{3}+\\frac{x^5}{5}-\\frac{x^7}{7}+\\cdots+(-1)^{n}\\frac{x^{2n+1}}{(2n+1)}+\\cdots\\\\\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\cdots+(-1)^{n-1}\\frac{x^n}{n}+\\cdots\\\\(1+x)^\\alpha=1+\\alpha x+\\frac{\\alpha(\\alpha-1)}{2!}x^2+\\frac{\\alpha(\\alpha-1)(\\alpha-2)}{3!}x^3+\\cdots+\\frac{\\alpha(\\alpha-1)(\\alpha-2)\\cdots(\\alpha-n+1)}{n!}x^n+R_n(x)$$关于最后这个 $R_n(x)$ ，一堆证明后得出，当 $x\\in (-1,1)$ 时有 $\\lim\\limits_{n\\rightarrow \\infty}=0$ 例（2021-2022第二学期期末，10）求函数 $y=\\frac{x}{4+x^2}$ 在 $x=0$ 处的泰勒级数，并指出其收敛域。解 $y=\\frac{x}{4}\\cdot\\frac{1}{1+(\\frac{x}{2})^2}$，右边显然就是 $\\arctan x$ 导数的形式了，故我们由 $\\arctan x$ 的泰勒展开式逐项求导有$$\\frac{1}{1+x^2}=(\\arctan x)’=1-x^2+x^4-x^6+\\cdots+(-1)^{n}x^{2n}+\\cdots$$变形得$$\\frac{1}{1+(\\frac{x}{2})^2}=1-\\frac{x^2}{4}+\\frac{x^4}{16}-\\frac{x^6}{64}+\\cdots+(-1)^{n}\\frac{x^{2n}}{2^{2n}}+\\cdots$$最后代入 $y=\\frac{x}{4}\\cdot\\frac{1}{1+(\\frac{x}{2})^2}$，有$$y=\\frac{x}{4}-\\frac{x^3}{16}+\\frac{x^5}{64}-\\frac{x^7}{256}+\\cdots+(-1)^n\\frac{x^{2n+1}}{2^{2n+2}}+\\cdots$$那么级数形式为$$y=\\sum\\limits^\\infty_{n=0}\\frac{(-1)^n}{4^{n+1}}x^{2n+1}$$收敛半径 $R=\\lim\\limits_{n\\rightarrow\\infty}\\left|\\frac{(-1)^{n}}{4^{n+1}}\\cdot\\frac{4^{n+2}}{(-1)^{n+1}}\\right|=4$故收敛区间为 $(-4,4)$ ，当 $x=-4$ 时，","link":"/2022/08/07/%E9%AB%98%E6%95%B0%E4%B8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Code-server","slug":"Code-server","link":"/tags/Code-server/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"抽象代数","slug":"抽象代数","link":"/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"二进制安全","slug":"二进制安全","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"格","slug":"格","link":"/tags/%E6%A0%BC/"},{"name":"CVP","slug":"CVP","link":"/tags/CVP/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"高数","slug":"高数","link":"/tags/%E9%AB%98%E6%95%B0/"},{"name":"复变函数","slug":"复变函数","link":"/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"材料力学","slug":"材料力学","link":"/tags/%E6%9D%90%E6%96%99%E5%8A%9B%E5%AD%A6/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"环境搭建","slug":"环境搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"小项目","slug":"小项目","link":"/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"},{"name":"小玩意","slug":"小玩意","link":"/categories/%E5%B0%8F%E7%8E%A9%E6%84%8F/"},{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"}],"pages":[{"title":"关于","text":"因为淋过雨，所以想给别人撑伞。 成长历程初见故事得从我初一的时候说起，当时年轻气盛，在 QQ 建了一个级群，里面各种鱼龙混杂，机缘巧合之下，有人在群里发了一个安卓 AIDE 开发群的二维码，我进去后也跟着下了一个玩，迷迷糊糊写了个 HelloWorld ，算是初步踏入了编程之路。 走马观花到初二的时候，我一个同班同学开始带着我研究计算机。毕竟他是跟电脑从小玩到大的，会很多东西，比如会视频剪辑，精通 Office（是真的精通），而且也会用虚拟机破解 WIFI 密码，知道 Windows 系统的很多东西，其他还有 OCR 等很杂的，我现在大都忘了，但仍很清楚地记得他带我写了几个 vb 程序。从那以后，我开始知道了程序设计的基本结构（比如 if-else ），也算是正式开始编程了。 临近生地中考的时候，我借着打印复习资料的由头（虽然现在回想起来有点离谱）成功劝服家里买了第一台电脑。买之前我是和我同学研究了许久的，以至于我现在仍清楚地记得最初的配置——CPU 是英特尔的 i5-7500，内存条 8G ，2400Hz ，金士顿的，硬盘买了希捷的 2T 机械硬盘，其他不提。后来断断续续又补了两个固态作主盘，加了张显卡和内存条，也撑了 5 年直到现在没出过什么毛病。 总之，从初二开始，我便开始广泛地接触到计算机的许多方面了，诸如 Office、AE 等软件大概鼓捣过，用 vb.net 写（Ctrl+C &amp; Ctrl+V）了几个窗体应用程序，但也仅此而已。 登堂入室高考结束后，我开始研究起写网站，毕竟想搞这个很久了，几经摸索，我在阿里云租了一个轻量级应用服务器（新人优惠，一年也就 99 元，不算很贵），然后就是各种百度了。 建站的过程非常艰辛，或许是我对搜索引擎的使用不够熟练，我查了很多资料，但很多都是在本地部署网络服务，或是 WordPress 的搭建教程，而我是想写一个空白的页面（或者说是不依赖于框架运行的），又折腾许久，在 WordPress 的应用镜像下更换了目录下的文件，勉强可以实现。再后来又换了 LNMP 的应用镜像，直到几个月后 GZTime 学长告诉我有个东西叫宝塔，我才发现都白忙活了。。。 在七月末的时候，我开始在 B 站看 C 语言的视频，2 倍速每天看五个钟连着五天把 1500 分钟的视频刷完了，才算是真正开始入门编程。 八月初，花了将近 10 天细细啃读了一遍高一就买了的《x86 汇编————从实模式到保护模式》，然而看完实模式已经晕了，就没有再看了。 至此，计算机底层的基础就打下来一点了。 找到组织在入学之后进了一个学校里的计算机吹水群（bushi），某一天，我在上面看见一个社团招新公告，上面附有一个解谜游戏的链接，国庆在家无聊就玩了起来，从此踏上了 CTF 的不归路， 也因此结识了 GZTime 学长————可以说是我计算机方面真正的领路人，教会了我很多东西。同时也遇到了 tel 、大菠萝、yescallop、Hanmur 等志同道合的伙伴，还进了学校的计算机社团和 CTF 战队。 如果上天再给我一次填报高考志愿的机会，我想我还是会作出同样的选择，与学校本身无关，只因我舍不得我的这些朋友。也只有在与他们水群和打比赛的时候，我才能忘却内卷与一切烦恼。 彼岸不论如何，我今后仍旧会坚持自己的热爱，与同道一齐，追寻梦想。愿与诸君共勉，在网络空间上做些贡献，也算不枉一身所学。 我现在在干什么玩 CTF、学算法、学数学以及写一些没什么基础也能看懂的文章，谨以此记念我曾经在搜索引擎上摸爬滚打的经历。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"友链","text":"DaLaosGZTime Walking on the Time Axis. TonyCrane 一个我也没看过他视频的up主 小傅Fox 一个博客不写技术的dalao Darkyzhou MC爱好者 jiahonzheng 请叫他++ 春哥 一人攻沙虐全场 朋友们Hanmur 一位帅气且有趣的学长 yescallop Rust水平相当高 FluoriteFire Walking to a new world Tel where are you a39 歩いても、歩いても 欢迎来交换友链ヾ(≧▽≦*)o 1234- name: weyung link: https://blog.weyung.cc/ avatar: https://blog.weyung.cc/images/wy.png descr: 写一些和我一样菜也能看懂的文章","link":"/links/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}