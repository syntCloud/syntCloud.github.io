---
title: 计组笔记
date: 2024-06-05 02:10:00
tags: [计组, 汇编]
categories: 学习
---

功夫再高，也怕挂科。

<!--more-->

## 第一章 概述

CPU 主要由**运算器**和**控制器**组成。
高速缓存 cache 采用 SRAM，内存采用 DRAM。
MIPS 和 ARM 都属于 RISC（Reduced Instruction Set Computer），x86 属于 CISC（Complex Instruction Set Computer）。
**Amdahl 定律**：$t_{new} = t_{related}/S + t_{unrelated}$，$S$ 为**加速比**。

时钟周期数 = 指令数 x 平均每条指令所需周期数（即cycles = IC x CPI）
CPU 执行时间 = 指令数 x CPI x 时钟周期长（即 CPUtimes = IC x CPI x T）
或 **CPUtimes = IC x CPI / f**

**能耗** = 负载电容 x 电压^2
**功耗** = 1/2 x 负载电容 x 电压^2 x 开关频率

## 指令

MIPS 一共有 32 个 **32 位**的寄存器
程序中的变量放在**保存寄存器**（store reg）中：`$s0~7` 共 8 个
运算的临时变量放在**临时寄存器**（temp reg）中：`$t0~9` 共 10 个
**零寄存器**（zero reg）：`$zero`，常用于赋值为 0

三类指令：
**运算指令**：`add`、`sub`、`mul`、`div`、`and`、`or`、`xor`、`nor`、`slt`、`sll`、`srl`、`sra`
**数据传送指令**：`lw`、`sw`、`lb`、`sb`、`lui`
**决策指令**：`beq`、`bne`、`j`、`jal`、`jr`

三种指令格式：
R 型：`op rd, rs, rt`
I 型：`op rt, rs, imm`
J 型：`op target`

### 算术运算指令

如 a, b, c 三个变量分别存放在 `$s0, $s1, $s2` 中，要计算 `c = a + b`，则汇编代码为：

```asm
add $s2, $s0, $s1
```

计算 `c = a - b`，则汇编代码为：

```asm
sub $s2, $s0, $s1
```

加立即数，假设变量 `i` 位于 `$s0`，要计算 `i = i + 1`，则汇编代码为：

```asm
addi $s0, $s0, 1
```

要减就**把立即数设为负数**，故 MIPS 无 `subi` 指令。

### 逻辑运算指令

比较简单，`nor` 为或非，就是先或再非，与 0 或非可以实现取反。

```asm
sll $s2, $s0, 2 # $s2 = $s0 << 2
```

### 运算指令例子

result(`$s3`) = a(`$s0`) - 10 + (b(`$s1`) + c(`$s2`) * 5)

```asm
sll $t0, $s2, 2     # $t0 = c * 4
add $t1, $t0, $s2   # $t1 = c * 5
add $t2, $t1, $s1   # $t2 = b + c * 5
addi $t3, $s0, -10  # $t3 = a - 10
add $s3, $t3, $t2   # $s3 = a - 10 + (b + c * 5)
```

### 寄存器-存储器数据传送

`lw` 即 load word
假设数组 `a` 基址存放在 `$s1` 中，要把 `a[5]` 的值传送到 `$s0` 中：

```asm
lw $s0, 20($s1)
```

`a[0]` 到 `a[5]` 的距离是 5 个字，而**在 MIPS 中，一个字是 4 个字节**，所以 `a[5]` 的地址是 `a` 的基址加上 20。
把 `$t0` 的值传送到 `a[2]`：

```asm
sw $t0, 8($s1)
```

### 寄存器间数据传送

把 `$t0` 的值传送到 `$s1`：

```asm
addi $s1, $t0, 0
add $s1, $t0, $zero
move $s1, $t0           # move 是伪指令，等价于 add $s1, $t0, $zero
```

把常数 10 传送到 `$s2`：

```asm
addi $s2, $zero, 10
li $s2, 10              # li 是伪指令，即 load immediate
```

### 装载 32 位立即数

把 10A2 7FFF 放进 `$s2`：

```asm
lui $s2, 0x10A2         # load upper immediate
ori $s2, $s2, 0x7FFF    # or immediate
```

这里不能用 `addi`，因为如果低 16 位的最高位是 1，那么会被当作负数，造成结果错误。

例：**数组元素运算与赋值**
`a[i] = a[0] + 100000`，数组 `a` 的基址存放在 `$s0` 中，`i` 存放在 `$s1` 中：

```asm
lw $t0, 0($s0)          # $t0 = a[0]
lui $t1, 1              # notice: 100000 = 0x186A0 > 0xFFFF
ori $t1, $t1, 0x86A0
add $t2, $t0, $t1       # $t2 = a[0] + 100000
sll $t3, $s1, 2         # $t3 = i * 4
add $t4, $s0, $t3       # $t4 = &a[i]
sw $t2, 0($t4)          # a[i] = a[0] + 100000
```

### 决策指令

`beq` 即 branch equal，`bne` 即 branch not equal
`j` 即 jump，无条件跳转
例子：将如下代码翻译成 MIPS 汇编代码

```c
if (i == j) f = g + h;
else f = g - h;
```

假设 `f, g, h` 分别存放在 `$s0, $s1, $s2` 中，`i, j` 分别存放在 `$s3, $s4` 中：

```asm
beq $s3, $s4, Else
add $s0, $s1, $s2
j Exit
Else:
sub $s0, $s1, $s2
Exit:
```

`slt` 即 set on less than，即小于则置位，否则清零（复位）
比如 `$s0 = 0, $s1 = 0, $s2 = 1`，则：

```asm
slt $s0, $s1, $s2
```

`$s0` 的会被置为 1，因为 0 < 1。

例子：

```c
while (a[i] == k) i++;
```

假设 `i` 存放在 `$s3`，`k` 存放在 `$s5`，`a` 的基址存放在 `$s6`：

```asm
Loop:
sll $t0, $s3, 2     # $t0 = i * 4
add $t1, $s6, $t0   # $t1 = &a[i]
lw $t2, 0($t1)      # $t2 = a[i]
beq $t2, $s5, Exit  # if a[i] == k, exit
addi $s3, $s3, 1    # i++
j Loop
Exit:
```

### 指令格式

#### R 型指令

指令中含三个寄存器的运算指令都属于 R 型（register type）指令，格式为 `op rd, rs, rt`。
32 位的 MIPS 指令一共分为 6 个字段：

- 操作码（opcode）：6 位
- 源寄存器 1（register source 1，rs）：5 位
- 源寄存器 2（register source 2，rt，叫 rt 应该是因为 t 是 s 的下一个字母）：5 位
- 目的寄存器（register destination，rd）：5 位
- 移位量（shamt）：5 位
- 功能码（funct）：6 位

MIPS 有 32 个寄存器，所以 5 位就可以表示全部的 32 个寄存器，所以 **rs、rt、rd 都是 5 位**。
**R 型指令的 opcode 都是 0**，由 6 位功能码指定操作，`$t0 ~ $t7` 的编号是 8~15，`$s0 ~ $s7` 的编号是 16~23，`add` 的 funct 是 32，`sub` 的 funct 是 34。
`sll/srl` 也是 R 型指令，没有第二个源寄存器，rt 被置为 0，用 `shamt` 表示移位量。

#### I 型指令

`addi` 和 `ori` 都属于 I 型（immediate type）指令，格式为 `op rt, rs, imm`。
I 型指令用 opcode 表示操作，rs 表示源寄存器，rt 表示目的寄存器，并把 rd-shamt-funct 三个字段合并成了 16 位的 imm，即立即数。

`lw` 和 `sw` 也是 I 型指令，但是 **rt 表示目的寄存器，rs 表示基址寄存器，和上面相反**，imm 表示偏移量，这两个指令的操作码分别是 35 和 43。

I 型指令还有 `beq` 和 `bne`，用于分支。

#### J 型指令

`j` 和 `jal` 都属于 J 型（jump type）指令，格式为 `op target`。

### 过程

支持过程的三大寄存器：4 个**参数寄存器** `$a0 ~ $a3`，两个**返回值寄存器** `$v0 ~ $v1`，**返回地址寄存器** `$ra`。

`jal` 即 jump and link，跳转到标签并**保存返回地址**到寄存器 `$ra`，由调用者主程序使用。
`jr` 即 jump register，跳转到寄存器中的地址，由被调用者过程使用，一般是 `jr $ra`。

两个栈指针寄存器 `$sp`（stack pointer） 和 `$fp` （frame pointer），分别表示栈指针和帧指针。在过程调用时，**如果要用到保存寄存器，就要先压入栈中，调用结束后再弹出**。

还有一个全局指针寄存器 `$gp`，便于寻找位置固定的数据，如主程序使用的变量、声明为 static 的变量，统称静态变量。

一般程序在内存中有 5 个段，地址从低到高依次为

1. 保留段
2. 代码段
3. 静态数据段
4. 堆段（动态数据段）
5. 栈段

**堆由低向高增长，栈由高向低增长**，双向奔赴，实现了内存空间的高效利用。

### 寻址

R 型指令都是寄存器寻址。
I 型指令第三个操作数（即第二个源操作数）是立即数的指令采用立即数寻址。`lw` 和 `sw` 采用基址偏移寻址。`beq` 和 `bne` 采用 PC(program counter) 相对寻址，**分支 32 位地址 = PC + 4 + 字地址偏移量**。
J 型指令都是伪直接寻址，因为 J 型指令是由 6 位操作码和 26 位目标地址组成的，寻址时**先左移 2 位形成 28 位字节地址，再和 PC 的高 4 位拼接成 32 位地址**。

假设第一行代码的地址是 10000，对如下代码：

```asm
Loop:
sll $t1, $s3, 2         # Temp reg $t1 = i * 4
add $t1, $t1, $s6       # $t1 = address of save[i]
lw $t0, 0($t1)          # Temp reg $t0 = save[i]
bne $t0, $s5, Exit      # go to Exit if save[i] != k
addi $s3, $s3, 1        # i = i + 1
j Loop                  # go to Loop
Exit:
```

`bne $t0, $s5, Exit` 中的立即数应该是 2，这里可以大概理解成隔了两条指令，而 `j Loop` 中的立即数稍微麻烦，首先因为 PC 的高 4 位是一样的，都是全 0，所以只需要考虑低 28 位，`Loop` 的地址是 10000，右移 2 位就是 100，所以 `j Loop` 的立即数是 100 （十进制的 4）的**补码**。

PC 相对寻址的范围是 (PC + 4) - 2e17 ~ (PC + 4 + 2e17 - 4)，大约是前后各 128 KB。
伪直接寻址的范围是和 PC 高 4 位相同的一切地址，即 256 MB。
要分支到更远的地址，就要把 `beq` 或者 `bne` 切换一下，然后下面跟一个 `j` 指令。
比如 `beq $s0, $s1, L1` 就换成如下代码：

```asm
bne $s0, $s1, L2
j L1
L2:
```

扩展跳转范围就直接换成 `jr` 指令，把目标地址放在寄存器中即可。
32 位系统最多只能支持 4 GB 的内存，所以 32 位的寄存器已经支持全部的内存寻址了。

### C 语言的 4 个翻译层次

编译器将高级语言文件（.c）翻译成汇编文件（.asm），然后由汇编器将汇编文件翻译成机器码文件（.obj），再由链接器将机器码文件链接成可执行文件（.exe），最后由加载器将可执行文件加载到内存中执行。

## 算术运算

### 整数的表示

以下以 8 位二进制数为例：
无符号整数很好理解，就是 8 位全用来表示数值，如 0000 0000 表示 0，1111 1111 表示 255。
**原码**：用最高位表示正负号，其余 7 位表示绝对值
**反码**：将最高位为 0 的原码按位取反表示负数
**补码**：按位取反再加 1

符号扩展：
16 位扩展到 32 位时，将最高位（即符号位）复制到高 16 位。

大端编址和小端编址：
**大端编址是将高位放在低地址**，小端编址是将高位放在高地址。

比如 0xFFE0 在内存中时
大端编址：
低 8 位：0xFF
高 8 位：0xE0
小端编址：
低 8 位：0xE0
高 8 位：0xFF

### ALU

符号位进位称为上溢，符号位借位称为下溢，统称溢出。

比较简单的 32 位 ALU 是行波进位加法器，即**每一位都是一个全加器**，每个全加器有三个输入：两个加数和上一位的进位，两个输出：和位和进位。
但是每次进位都要过一次或门和与门，就产生了 64 个门延迟。

为了加快进位，进而加速加法运算，现在广泛采用**超前进位加法器**，通过将进位分为 4 位一组，抽象成每组的进行，实现加法器的并行执行。

要执行 n 位加法，求出 n 是 4 的几次方，并向上取整，再乘 2 加 1，就是超前进位加法器的门延迟。
用数学表达式表示就是 $2 \times \lceil \log_4 n \rceil + 1$，**n 为 16 时是 5，n 为 32 和 64 时都是 7**。

除法中，规定**余数和被除数同号**，比如 -7/2 = -3 余 -1，而不是商 -4 余 1。

MIPS 中的乘除指令有 4 条，`mult` 和 `div` 是有符号的乘法和除法，`multu` 和 `divu` 是无符号的乘法和除法，均为双操作数 R 型指令。
`mfhi` 和 `mflo` 分别是将乘法和除法的高 32 位和低 32 位传送到寄存器中，均为单操作数 R 型指令。

### 浮点数

IEEE 754 标准规定了浮点数的表示方法，**32 位单精度浮点数由 1 位符号位、8 位指数位和 23 位尾数位组成**。注意**指数要加 127 的偏差**，同时这里的**尾数是指小数点后的部分**，因为二进制的科学计数法里，只要不是 0.0，那么小数点前的部分一定是 1。
举个例子 -0.00101 = -1.01 x 2^-3，很明显，因为是负数，所以符号位是 1，指数位是 -3 + 127 = 124，尾数位是 01（后面补 0）。
64 位双精度浮点数由 1 位符号位、11 位指数位和 52 位尾数位组成，指数偏差是 1023。

MIPS 中增加了单独的 32 个单精度浮点寄存器 `$f0 ~ $f31`，一对单精度浮点寄存器组合成一个双精度寄存器，以偶数编号。

`add.s` 和 `sub.s` 是单精度浮点数的加减法，`mul.s` 和 `div.s` 是单精度浮点数的乘除法，s 换成 d 就是双精度浮点数的运算。
比较两个浮点数大小，用 `c.eq.s` 和 `c.lt.s`，分别表示等于和小于，为真时用 `bc1t` 跳转，为假时用 `bc1f` 跳转。

> 这里我查了一下应该是 `bc1t` 和 `bc1f`，但是课本写的是 `bclt` 和 `bclf`，我觉得应该是笔误。

IEEE 754 在运算时引入了两个尾数位，分别是保护位和舍入位，运算误差不超过 0.5 个 ulp（unit in the last place，即尾数最低位）。

## 处理器

最核心的部分。

### 数字逻辑基础

组合逻辑不含存储器，给定输入时输出唯一确定，如 ALU。
状态逻辑（又称时序逻辑）含存储器，至少拥有两个输入：数据输入和时钟输入和一个输出。
总线表示数据信息多于一位的信号线，在数字电路图中加粗表示并标记位宽，由于 MIPS-32 采用 32 位字，所以当总线为 32 位时不必写出位宽。

### 指令周期

一条 MIPS 指令的执行分为 5 个阶段，统称一个**指令周期**，分别是：

1. 取指令（IF，Instruction Fetch）：从内存中取指令
2. 指令译码（ID，Instruction Decode）：译码并取寄存器
3. 执行（EX，Execute）：执行指令
4. 访存（MEM，Memory）：访问内存
5. 写回（WB，Write Back）：写回结果

R 型指令和 `lw/sw/beq` 在 IF 的时候都是根据 PC 从存储器中取出指令。
R 型指令在 ID 时取源操作数 rs 和 rt，在 EX 时执行运算，没有 MEM，因为三个操作数都是寄存器，WB 时将结果写回 rd。
`lw/sw` 在 ID 时取基址寄存器 rs，并将偏移量 imm 符号扩展，EX 时计算内存地址，`lw` 在 MEM 时从内存中取数据，WB 时写回寄存器 rt，`sw` 在 MEM 时将数据写入内存，WB 时不做任何操作。
`beq` 在 ID 时取 rs 和 rt，将字地址符号扩展并左移两位，EX 时比较 rs 和 rt，计算分支地址，MEM 时写回 PC，WB 时不做任何操作。

在单周期实现中，每条指令都在一个时钟周期内完成，CPI 为 1。
多周期实现中可以缩减时钟周期到一个阶段的长度，一条指令占用几个阶段，就执行几个周期。

### 指令周期与流水级

与指令周期的五个阶段相对应，把数据通路分为五个流水级，形成流水线（pipeline）。
时钟周期数=指令数+流水级级数-1（cycles = IC + stages - 1）。
理想加速比=流水级级数（$S_{理想}$ = stages）。
理想条件为：1.每个流水级时间等长 2.流水线没有开销 3.指令数足够多。
省略流水周期可能导致两条指令抢占同一流水级的硬件部件，引发结构冒险（structural hazard），解决的通行方法是添加硬件。

### 流水线性能

流水线在同一时间处理多条指令的不同阶段，实现指令级并行。
由时钟周期长度决定的吞吐率是评价流水线性能的重要指标。
在两个流水级间插入流水线寄存器，以左右两个流水级命名，分别叫 IF/ID、ID/EX、EX/MEM、MEM/WB。
流水线的时钟周期是由最慢的流水级决定的。
流水线的控制信号在译码时产生，逐级递减。
前半个周期写寄存器堆，后半个周期读寄存器堆，可以减少一次数据冒险。

### 控制单元信号

控制信号 | 功能
---------|----------
RegDst | 启用 rd
ALUSrc | imm 输入 ALU
MemtoReg | 存储器写回
RegWrite | 写寄存器堆
MemRead | 读存储器
MemWrite | 写存储器
Branch | 分支
ALUOp1 / ALUOp0 | ALU 操作码

以指令 `and rd, rs, rt` 为例，`RegDst` 为 1，没有立即数，所以 `ALUSrc` 为 0，没有任何与存储器有关的操作，所以 `MemtoReg MemRead MemWrite` 均为 0，不是 `beq`，所以 Branch 也为 0，然后 R 型指令的 `ALUOp` 信号都是 10。

加速比 = 改进前的时钟周期数 / 改进后的时钟周期数

## 存储层次

### cache 和 内存

L1~L3 **高速缓存**
cache 通常集成在 CPU 中，采用静态随机访问存储器（SRAM）集成电路，由双稳态触发器构成，每 B（byte） 由 6~8 个晶体管组成，硬件规模较大
L4 **内存**
采用动态随机访问存储器（DRAM）集成电路，使用电容保存电荷，进而存储数据，每 B 仅使用一个晶体管，硬件规模远小于 SRAM（密度大于 SRAM），由于电荷只能短暂留存，需要周期性地将一行上的数据读出后重新写入，完成刷新
SRAM 和 DRAM 在断电后很快丢失数据，称为易失性存储器（volatile memory）
L5 **二级存储器或辅存**
磁盘每个盘片由数万道磁道组成，每个磁道又被分为几千个扇区，扇区是最小的存储单位。
现在多使用闪存，一种集成电路制造的电可擦除可编程只读存储器（EEPROM），数据更快，功耗更低。  
磁盘和闪存断电后不丢失数据，称为非易失性存储器（non-volatile memory）

## 参考

<https://www.bilibili.com/video/BV1je4y1Q7BK>
