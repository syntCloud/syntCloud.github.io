---
title: 计组笔记
date: 2024-06-05 02:10:00
tags: [计组, 汇编]
categories: 学习
---

功夫再高，也怕挂科。

<!--more-->

## 第一章 概述

CPU 主要由**运算器**和**控制器**组成。
高速缓存 cache 采用 SRAM，内存采用 DRAM。
MIPS 和 ARM 都属于 RISC（Reduced Instruction Set Computer），x86 属于 CISC（Complex Instruction Set Computer）。
**Amdahl 定律**：$t_{new} = t_{related}/S + t_{unrelated}$，$S$ 为**加速比**。

时钟周期数 = 指令数 x 平均每条指令所需周期数（即cycles = IC x CPI）
CPU 执行时间 = 指令数 x CPI x 时钟周期长（即 CPUtimes = IC x CPI x T）
或 **CPUtimes = IC x CPI / f**

**能耗** = 负载电容 x 电压^2
**功耗** = 1/2 x 负载电容 x 电压^2 x 开关频率

## 指令

MIPS 一共有 32 个 32 位的寄存器
程序中的变量放在保存寄存器（store reg）中：`$s0~7` 共 8 个
运算的临时变量放在临时寄存器（temp reg）中：`$t0~9` 共 10 个
零寄存器（zero reg）：`$zero`，常用于赋值为 0

三类指令：
运算指令：`add`、`sub`、`mul`、`div`、`and`、`or`、`xor`、`nor`、`slt`、`sll`、`srl`、`sra`
数据传送指令：`lw`、`sw`、`lb`、`sb`、`lui`
决策指令：`beq`、`bne`、`j`、`jal`、`jr`

三种指令格式：
R 类型：`op rd, rs, rt`
I 类型：`op rt, rs, imm`
J 类型：`op target`

### 算术运算指令

如 a, b, c 三个变量分别存放在 `$s0, $s1, $s2` 中，要计算 `c = a + b`，则汇编代码为：

```asm
add $s2, $s0, $s1
```

计算 `c = a - b`，则汇编代码为：

```asm
sub $s2, $s0, $s1
```

加立即数，假设变量 `i` 位于 `$s0`，要计算 `i = i + 1`，则汇编代码为：

```asm
addi $s0, $s0, 1
```

要减就把立即数设为负数，故 MIPS 无 `subi` 指令。

### 逻辑运算指令

比较简单，`nor` 为或非，先或再非，与 0 或非可以取反。

```asm
sll $s2, $s0, 2 # $s2 = $s0 << 2
```

### 指令运算例子

result(`$s3`) = a(`$s0`) - 10 + (b(`$s1`) + c(`$s2`) * 5)

```asm
sll $t0, $s2, 2     # $t0 = c * 4
add $t1, $t0, $s2   # $t1 = c * 5
add $t2, $t1, $s1   # $t2 = b + c * 5
addi $t3, $s0, -10  # $t3 = a - 10
add $s3, $t3, $t2   # $s3 = a - 10 + (b + c * 5)
```

### 寄存器-存储器数据传送

`lw` 即 load word
数组 `a` 基址存放在 `$s1` 中，把 `a[5]` 的值传送到 `$s0` 中：

```asm
lw $s0, 20($s1)
```

`a[0]` 到 `a[5]` 的距离是 5 个字，而在 MIPS 中，一个字是 4 个字节，所以 `a[5]` 的地址是 `a` 的基址加上 20。
把 `$t0` 的值传送到 `a[2]`：

```asm
sw $t0, 8($s1)
```

### 寄存器间数据传送

把 `$t0` 的值传送到 `$s1`：

```asm
addi $s1, $t0, 0
add $s1, $t0, $zero
move $s1, $t0   # move 是伪指令，等价于 add $s1, $t0, $zero
```

把常数 10 传送到 `$s2`：

```asm
addi $s2, $zero, 10
li $s2, 10  # li 是伪指令，即 load immediate
```

### 装载 32 位立即数

把 10A2 7FFF 放进 `$s2`：

```asm
lui $s2, 0x10A2         # load upper immediate
ori $s2, $s2, 0x7FFF    # or immediate
```

这里不能用 `addi`，因为如果低 16 位的最高位是 1，那么会被当作负数。

数组元素运算与赋值
`a[i] = a[0] + 100000`，数组 `a` 的基址存放在 `$s0` 中，`i` 存放在 `$s1` 中：

```asm
lw $t0, 0($s0)      # $t0 = a[0]
lui $t1, 1          # notice: 100000 = 0x186A0 > 0xFFFF
ori $t1, $t1, 0x86A0
add $t2, $t0, $t1   # $t2 = a[0] + 100000
sll $t3, $s1, 2     # $t3 = i * 4
add $t4, $s0, $t3   # $t4 = &a[i]
sw $t2, 0($t4)      # a[i] = a[0] + 100000
```

### 决策指令

`beq` 即 branch equal，`bne` 即 branch not equal
`j` 即 jump，无条件跳转
例子：

```c
if (i == j) f = g + h;
else f = g - h;
```

假设 `f, g, h` 分别存放在 `$s0, $s1, $s2` 中，`i, j` 分别存放在 `$s3, $s4` 中：

```asm
beq $s3, $s4, Else
add $s0, $s1, $s2
j Exit
Else:
sub $s0, $s1, $s2
Exit:
```

`slt` 即 set on less than，即小于则置位，否则清零（复位）
比如 `$s0 = 0, $s1 = 0, $s2 = 1`，则：

```asm
slt $s0, $s1, $s2
```

`$s0` 的会被置为 1，因为 0 < 1。

例子：

```c
while (a[i] == k) i++;
```

假设 `i` 存放在 `$s3`，`k` 存放在 `$s5`，`a` 的基址存放在 `$s6`：

```asm
Loop:
sll $t0, $s3, 2     # $t0 = i * 4
add $t1, $s6, $t0   # $t1 = &a[i]
lw $t2, 0($t1)      # $t2 = a[i]
beq $t2, $s5, Exit  # if a[i] == k, exit
addi $s3, $s3, 1    # i++
j Loop
Exit:
```

### 指令格式

#### R 型指令

指令中含三个寄存器的运算指令都属于 R 型（register type）指令，格式为 `op rd, rs, rt`。
32 位的 MIPS 指令一共分为 6 个字段：

- 操作码（opcode）：6 位
- 源寄存器 1（register source 1，rs）：5 位
- 源寄存器 2（register source 2，rt，叫 rt 应该是因为 t 是 s 的下一个字母）：5 位
- 目的寄存器（register destination，rd）：5 位
- 移位量（shamt）：5 位
- 功能码（funct）：6 位

MIPS 有 32 个寄存器，所以 5 位就可以表示全部的 32 个寄存器，所以 rs、rt、rd 都是 5 位。
R 型指令的 opcode 都是 0，由 6 位功能码指定操作，`$t0 ~ $t7` 的编号是 8~15，`$s0 ~ $s7` 的编号是 16~23，`add` 的 funct 是 32，`sub` 的 funct 是 34。
`sll/srl` 也是 R 型指令，没有第二个源寄存器，rt 被置为 0，用 `shamt` 表示移位量。

#### I 型指令

`addi` 和 `ori` 都属于 I 型（immediate type）指令，格式为 `op rt, rs, imm`。
I 型指令用 opcode 表示操作，rs 表示源寄存器，rt 表示目的寄存器，并把 rd-shamt-funct 三个字段合并成了 16 位的 imm，即立即数。

`lw` 和 `sw` 也是 I 型指令，但是 **rt 表示目的寄存器，rs 表示基址寄存器，和上面相反**，imm 表示偏移量，这两个指令的操作码分别是 35 和 43。

### 过程

支持过程的三大寄存器：4 个参数寄存器 `$a0 ~ $a3`，两个返回值寄存器 `$v0 ~ $v1`，返回地址寄存器 `$ra`。

`jal` 即 jump and link，跳转到标签并保存返回地址到寄存器 `$ra`，由调用者主程序使用。
`jr` 即 jump register，跳转到寄存器中的地址，由被调用者过程使用，一般是 `jr $ra`。
两个栈指针寄存器 `$sp`（stack pointer） 和 `$fp` （frame pointer），分别表示栈指针和帧指针。在过程调用时，如果要用到保存寄存器，就要先压入栈中，调用结束后再弹出。
还有一个全局指针寄存器 `$gp`，便于寻找位置固定的数据，如主程序使用的变量、声明为 static 的变量，统称静态变量。

一般程序在内存中有 5 个段，地址从低到高依次为

1. 保留段
2. 代码段
3. 静态数据段
4. 堆段（动态数据段）
5. 栈段

堆由低向高增长，栈由高向低增长，双向奔赴，实现了内存空间的高效利用。

## 算术运算

## 处理器

## 存储层次

## 参考

<https://www.bilibili.com/video/BV1je4y1Q7BK>
